#!/usr/bin/env node
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

'use strict';

var fs = require('fs');
var glob = require('glob');
var path = require('path');
var semver = require('semver');
var vm2 = require('vm2');
var protobufjs = require('protobufjs');
var $protobuf = require('protobufjs/minimal');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var glob__namespace = /*#__PURE__*/_interopNamespace(glob);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var semver__namespace = /*#__PURE__*/_interopNamespace(semver);
var $protobuf__namespace = /*#__PURE__*/_interopNamespace($protobuf);

var VerifyProtoErrorBehaviour;
(function (VerifyProtoErrorBehaviour) {
    VerifyProtoErrorBehaviour[VerifyProtoErrorBehaviour["DEFAULT"] = 0] = "DEFAULT";
    VerifyProtoErrorBehaviour[VerifyProtoErrorBehaviour["SUGGEST_REPORTING_TO_DATAFORM_TEAM"] = 1] = "SUGGEST_REPORTING_TO_DATAFORM_TEAM";
    VerifyProtoErrorBehaviour[VerifyProtoErrorBehaviour["SHOW_DOCS_LINK"] = 2] = "SHOW_DOCS_LINK";
})(VerifyProtoErrorBehaviour || (VerifyProtoErrorBehaviour = {}));
function encode64(protoType, value = {}) {
    return toBase64(protoType.encode(protoType.create(value)).finish());
}
function toBase64(value) {
    return protobufjs.util.base64.encode(value, 0, value.length);
}

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

// Common aliases
const $Reader = $protobuf__namespace.Reader, $Writer = $protobuf__namespace.Writer, $util = $protobuf__namespace.util;

// Exported root namespace
const $root = $protobuf__namespace.roots["default"] || ($protobuf__namespace.roots["default"] = {});

const dataform = $root.dataform = (() => {

    /**
     * Namespace dataform.
     * @exports dataform
     * @namespace
     */
    const dataform = {};

    dataform.WorkflowSettings = (function() {

        /**
         * Properties of a WorkflowSettings.
         * @memberof dataform
         * @interface IWorkflowSettings
         * @property {string|null} [dataformCoreVersion] WorkflowSettings dataformCoreVersion
         * @property {string|null} [defaultProject] WorkflowSettings defaultProject
         * @property {string|null} [defaultDataset] WorkflowSettings defaultDataset
         * @property {string|null} [defaultLocation] WorkflowSettings defaultLocation
         * @property {string|null} [defaultAssertionDataset] WorkflowSettings defaultAssertionDataset
         * @property {Object.<string,string>|null} [vars] WorkflowSettings vars
         * @property {string|null} [projectSuffix] WorkflowSettings projectSuffix
         * @property {string|null} [datasetSuffix] WorkflowSettings datasetSuffix
         * @property {string|null} [namePrefix] WorkflowSettings namePrefix
         * @property {dataform.INotebookRuntimeOptionsConfig|null} [defaultNotebookRuntimeOptions] WorkflowSettings defaultNotebookRuntimeOptions
         * @property {string|null} [builtinAssertionNamePrefix] WorkflowSettings builtinAssertionNamePrefix
         */

        /**
         * Constructs a new WorkflowSettings.
         * @memberof dataform
         * @classdesc Represents a WorkflowSettings.
         * @implements IWorkflowSettings
         * @constructor
         * @param {dataform.IWorkflowSettings=} [properties] Properties to set
         */
        function WorkflowSettings(properties) {
            this.vars = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorkflowSettings dataformCoreVersion.
         * @member {string} dataformCoreVersion
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.dataformCoreVersion = "";

        /**
         * WorkflowSettings defaultProject.
         * @member {string} defaultProject
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.defaultProject = "";

        /**
         * WorkflowSettings defaultDataset.
         * @member {string} defaultDataset
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.defaultDataset = "";

        /**
         * WorkflowSettings defaultLocation.
         * @member {string} defaultLocation
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.defaultLocation = "";

        /**
         * WorkflowSettings defaultAssertionDataset.
         * @member {string} defaultAssertionDataset
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.defaultAssertionDataset = "";

        /**
         * WorkflowSettings vars.
         * @member {Object.<string,string>} vars
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.vars = $util.emptyObject;

        /**
         * WorkflowSettings projectSuffix.
         * @member {string} projectSuffix
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.projectSuffix = "";

        /**
         * WorkflowSettings datasetSuffix.
         * @member {string} datasetSuffix
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.datasetSuffix = "";

        /**
         * WorkflowSettings namePrefix.
         * @member {string} namePrefix
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.namePrefix = "";

        /**
         * WorkflowSettings defaultNotebookRuntimeOptions.
         * @member {dataform.INotebookRuntimeOptionsConfig|null|undefined} defaultNotebookRuntimeOptions
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.defaultNotebookRuntimeOptions = null;

        /**
         * WorkflowSettings builtinAssertionNamePrefix.
         * @member {string} builtinAssertionNamePrefix
         * @memberof dataform.WorkflowSettings
         * @instance
         */
        WorkflowSettings.prototype.builtinAssertionNamePrefix = "";

        /**
         * Creates a new WorkflowSettings instance using the specified properties.
         * @function create
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {dataform.IWorkflowSettings=} [properties] Properties to set
         * @returns {dataform.WorkflowSettings} WorkflowSettings instance
         */
        WorkflowSettings.create = function create(properties) {
            return new WorkflowSettings(properties);
        };

        /**
         * Encodes the specified WorkflowSettings message. Does not implicitly {@link dataform.WorkflowSettings.verify|verify} messages.
         * @function encode
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {dataform.IWorkflowSettings} message WorkflowSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorkflowSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dataformCoreVersion != null && Object.hasOwnProperty.call(message, "dataformCoreVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.dataformCoreVersion);
            if (message.defaultProject != null && Object.hasOwnProperty.call(message, "defaultProject"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.defaultProject);
            if (message.defaultDataset != null && Object.hasOwnProperty.call(message, "defaultDataset"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.defaultDataset);
            if (message.defaultLocation != null && Object.hasOwnProperty.call(message, "defaultLocation"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.defaultLocation);
            if (message.defaultAssertionDataset != null && Object.hasOwnProperty.call(message, "defaultAssertionDataset"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.defaultAssertionDataset);
            if (message.vars != null && Object.hasOwnProperty.call(message, "vars"))
                for (let keys = Object.keys(message.vars), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.vars[keys[i]]).ldelim();
            if (message.projectSuffix != null && Object.hasOwnProperty.call(message, "projectSuffix"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.projectSuffix);
            if (message.datasetSuffix != null && Object.hasOwnProperty.call(message, "datasetSuffix"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.datasetSuffix);
            if (message.namePrefix != null && Object.hasOwnProperty.call(message, "namePrefix"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.namePrefix);
            if (message.defaultNotebookRuntimeOptions != null && Object.hasOwnProperty.call(message, "defaultNotebookRuntimeOptions"))
                $root.dataform.NotebookRuntimeOptionsConfig.encode(message.defaultNotebookRuntimeOptions, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.builtinAssertionNamePrefix != null && Object.hasOwnProperty.call(message, "builtinAssertionNamePrefix"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.builtinAssertionNamePrefix);
            return writer;
        };

        /**
         * Encodes the specified WorkflowSettings message, length delimited. Does not implicitly {@link dataform.WorkflowSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {dataform.IWorkflowSettings} message WorkflowSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorkflowSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorkflowSettings message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.WorkflowSettings} WorkflowSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorkflowSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.WorkflowSettings(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dataformCoreVersion = reader.string();
                        break;
                    }
                case 2: {
                        message.defaultProject = reader.string();
                        break;
                    }
                case 3: {
                        message.defaultDataset = reader.string();
                        break;
                    }
                case 4: {
                        message.defaultLocation = reader.string();
                        break;
                    }
                case 5: {
                        message.defaultAssertionDataset = reader.string();
                        break;
                    }
                case 6: {
                        if (message.vars === $util.emptyObject)
                            message.vars = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.vars[key] = value;
                        break;
                    }
                case 7: {
                        message.projectSuffix = reader.string();
                        break;
                    }
                case 8: {
                        message.datasetSuffix = reader.string();
                        break;
                    }
                case 9: {
                        message.namePrefix = reader.string();
                        break;
                    }
                case 10: {
                        message.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptionsConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.builtinAssertionNamePrefix = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WorkflowSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.WorkflowSettings} WorkflowSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorkflowSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorkflowSettings message.
         * @function verify
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorkflowSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                if (!$util.isString(message.dataformCoreVersion))
                    return "dataformCoreVersion: string expected";
            if (message.defaultProject != null && message.hasOwnProperty("defaultProject"))
                if (!$util.isString(message.defaultProject))
                    return "defaultProject: string expected";
            if (message.defaultDataset != null && message.hasOwnProperty("defaultDataset"))
                if (!$util.isString(message.defaultDataset))
                    return "defaultDataset: string expected";
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                if (!$util.isString(message.defaultLocation))
                    return "defaultLocation: string expected";
            if (message.defaultAssertionDataset != null && message.hasOwnProperty("defaultAssertionDataset"))
                if (!$util.isString(message.defaultAssertionDataset))
                    return "defaultAssertionDataset: string expected";
            if (message.vars != null && message.hasOwnProperty("vars")) {
                if (!$util.isObject(message.vars))
                    return "vars: object expected";
                let key = Object.keys(message.vars);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.vars[key[i]]))
                        return "vars: string{k:string} expected";
            }
            if (message.projectSuffix != null && message.hasOwnProperty("projectSuffix"))
                if (!$util.isString(message.projectSuffix))
                    return "projectSuffix: string expected";
            if (message.datasetSuffix != null && message.hasOwnProperty("datasetSuffix"))
                if (!$util.isString(message.datasetSuffix))
                    return "datasetSuffix: string expected";
            if (message.namePrefix != null && message.hasOwnProperty("namePrefix"))
                if (!$util.isString(message.namePrefix))
                    return "namePrefix: string expected";
            if (message.defaultNotebookRuntimeOptions != null && message.hasOwnProperty("defaultNotebookRuntimeOptions")) {
                let error = $root.dataform.NotebookRuntimeOptionsConfig.verify(message.defaultNotebookRuntimeOptions);
                if (error)
                    return "defaultNotebookRuntimeOptions." + error;
            }
            if (message.builtinAssertionNamePrefix != null && message.hasOwnProperty("builtinAssertionNamePrefix"))
                if (!$util.isString(message.builtinAssertionNamePrefix))
                    return "builtinAssertionNamePrefix: string expected";
            return null;
        };

        /**
         * Creates a WorkflowSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.WorkflowSettings} WorkflowSettings
         */
        WorkflowSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.WorkflowSettings)
                return object;
            let message = new $root.dataform.WorkflowSettings();
            if (object.dataformCoreVersion != null)
                message.dataformCoreVersion = String(object.dataformCoreVersion);
            if (object.defaultProject != null)
                message.defaultProject = String(object.defaultProject);
            if (object.defaultDataset != null)
                message.defaultDataset = String(object.defaultDataset);
            if (object.defaultLocation != null)
                message.defaultLocation = String(object.defaultLocation);
            if (object.defaultAssertionDataset != null)
                message.defaultAssertionDataset = String(object.defaultAssertionDataset);
            if (object.vars) {
                if (typeof object.vars !== "object")
                    throw TypeError(".dataform.WorkflowSettings.vars: object expected");
                message.vars = {};
                for (let keys = Object.keys(object.vars), i = 0; i < keys.length; ++i)
                    message.vars[keys[i]] = String(object.vars[keys[i]]);
            }
            if (object.projectSuffix != null)
                message.projectSuffix = String(object.projectSuffix);
            if (object.datasetSuffix != null)
                message.datasetSuffix = String(object.datasetSuffix);
            if (object.namePrefix != null)
                message.namePrefix = String(object.namePrefix);
            if (object.defaultNotebookRuntimeOptions != null) {
                if (typeof object.defaultNotebookRuntimeOptions !== "object")
                    throw TypeError(".dataform.WorkflowSettings.defaultNotebookRuntimeOptions: object expected");
                message.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptionsConfig.fromObject(object.defaultNotebookRuntimeOptions);
            }
            if (object.builtinAssertionNamePrefix != null)
                message.builtinAssertionNamePrefix = String(object.builtinAssertionNamePrefix);
            return message;
        };

        /**
         * Creates a plain object from a WorkflowSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {dataform.WorkflowSettings} message WorkflowSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorkflowSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.vars = {};
            if (options.defaults) {
                object.dataformCoreVersion = "";
                object.defaultProject = "";
                object.defaultDataset = "";
                object.defaultLocation = "";
                object.defaultAssertionDataset = "";
                object.projectSuffix = "";
                object.datasetSuffix = "";
                object.namePrefix = "";
                object.defaultNotebookRuntimeOptions = null;
                object.builtinAssertionNamePrefix = "";
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                object.dataformCoreVersion = message.dataformCoreVersion;
            if (message.defaultProject != null && message.hasOwnProperty("defaultProject"))
                object.defaultProject = message.defaultProject;
            if (message.defaultDataset != null && message.hasOwnProperty("defaultDataset"))
                object.defaultDataset = message.defaultDataset;
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                object.defaultLocation = message.defaultLocation;
            if (message.defaultAssertionDataset != null && message.hasOwnProperty("defaultAssertionDataset"))
                object.defaultAssertionDataset = message.defaultAssertionDataset;
            let keys2;
            if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                object.vars = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.vars[keys2[j]] = message.vars[keys2[j]];
            }
            if (message.projectSuffix != null && message.hasOwnProperty("projectSuffix"))
                object.projectSuffix = message.projectSuffix;
            if (message.datasetSuffix != null && message.hasOwnProperty("datasetSuffix"))
                object.datasetSuffix = message.datasetSuffix;
            if (message.namePrefix != null && message.hasOwnProperty("namePrefix"))
                object.namePrefix = message.namePrefix;
            if (message.defaultNotebookRuntimeOptions != null && message.hasOwnProperty("defaultNotebookRuntimeOptions"))
                object.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptionsConfig.toObject(message.defaultNotebookRuntimeOptions, options);
            if (message.builtinAssertionNamePrefix != null && message.hasOwnProperty("builtinAssertionNamePrefix"))
                object.builtinAssertionNamePrefix = message.builtinAssertionNamePrefix;
            return object;
        };

        /**
         * Converts this WorkflowSettings to JSON.
         * @function toJSON
         * @memberof dataform.WorkflowSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorkflowSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WorkflowSettings
         * @function getTypeUrl
         * @memberof dataform.WorkflowSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WorkflowSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.WorkflowSettings";
        };

        return WorkflowSettings;
    })();

    dataform.ActionConfigs = (function() {

        /**
         * Properties of an ActionConfigs.
         * @memberof dataform
         * @interface IActionConfigs
         * @property {Array.<dataform.IActionConfig>|null} [actions] ActionConfigs actions
         */

        /**
         * Constructs a new ActionConfigs.
         * @memberof dataform
         * @classdesc Represents an ActionConfigs.
         * @implements IActionConfigs
         * @constructor
         * @param {dataform.IActionConfigs=} [properties] Properties to set
         */
        function ActionConfigs(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionConfigs actions.
         * @member {Array.<dataform.IActionConfig>} actions
         * @memberof dataform.ActionConfigs
         * @instance
         */
        ActionConfigs.prototype.actions = $util.emptyArray;

        /**
         * Creates a new ActionConfigs instance using the specified properties.
         * @function create
         * @memberof dataform.ActionConfigs
         * @static
         * @param {dataform.IActionConfigs=} [properties] Properties to set
         * @returns {dataform.ActionConfigs} ActionConfigs instance
         */
        ActionConfigs.create = function create(properties) {
            return new ActionConfigs(properties);
        };

        /**
         * Encodes the specified ActionConfigs message. Does not implicitly {@link dataform.ActionConfigs.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionConfigs
         * @static
         * @param {dataform.IActionConfigs} message ActionConfigs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionConfigs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ActionConfig.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionConfigs message, length delimited. Does not implicitly {@link dataform.ActionConfigs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionConfigs
         * @static
         * @param {dataform.IActionConfigs} message ActionConfigs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionConfigs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionConfigs message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionConfigs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionConfigs} ActionConfigs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionConfigs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfigs();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.dataform.ActionConfig.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionConfigs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionConfigs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionConfigs} ActionConfigs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionConfigs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionConfigs message.
         * @function verify
         * @memberof dataform.ActionConfigs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionConfigs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ActionConfig.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ActionConfigs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionConfigs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionConfigs} ActionConfigs
         */
        ActionConfigs.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionConfigs)
                return object;
            let message = new $root.dataform.ActionConfigs();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.ActionConfigs.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.ActionConfigs.actions: object expected");
                    message.actions[i] = $root.dataform.ActionConfig.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionConfigs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionConfigs
         * @static
         * @param {dataform.ActionConfigs} message ActionConfigs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionConfigs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ActionConfig.toObject(message.actions[j], options);
            }
            return object;
        };

        /**
         * Converts this ActionConfigs to JSON.
         * @function toJSON
         * @memberof dataform.ActionConfigs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionConfigs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionConfigs
         * @function getTypeUrl
         * @memberof dataform.ActionConfigs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionConfigs";
        };

        return ActionConfigs;
    })();

    dataform.ActionConfig = (function() {

        /**
         * Properties of an ActionConfig.
         * @memberof dataform
         * @interface IActionConfig
         * @property {dataform.ActionConfig.ITableConfig|null} [table] ActionConfig table
         * @property {dataform.ActionConfig.IViewConfig|null} [view] ActionConfig view
         * @property {dataform.ActionConfig.IIncrementalTableConfig|null} [incrementalTable] ActionConfig incrementalTable
         * @property {dataform.ActionConfig.IAssertionConfig|null} [assertion] ActionConfig assertion
         * @property {dataform.ActionConfig.IOperationConfig|null} [operation] ActionConfig operation
         * @property {dataform.ActionConfig.IDeclarationConfig|null} [declaration] ActionConfig declaration
         * @property {dataform.ActionConfig.INotebookConfig|null} [notebook] ActionConfig notebook
         * @property {dataform.ActionConfig.IDataPreparationConfig|null} [dataPreparation] ActionConfig dataPreparation
         */

        /**
         * Constructs a new ActionConfig.
         * @memberof dataform
         * @classdesc Represents an ActionConfig.
         * @implements IActionConfig
         * @constructor
         * @param {dataform.IActionConfig=} [properties] Properties to set
         */
        function ActionConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionConfig table.
         * @member {dataform.ActionConfig.ITableConfig|null|undefined} table
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.table = null;

        /**
         * ActionConfig view.
         * @member {dataform.ActionConfig.IViewConfig|null|undefined} view
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.view = null;

        /**
         * ActionConfig incrementalTable.
         * @member {dataform.ActionConfig.IIncrementalTableConfig|null|undefined} incrementalTable
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.incrementalTable = null;

        /**
         * ActionConfig assertion.
         * @member {dataform.ActionConfig.IAssertionConfig|null|undefined} assertion
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.assertion = null;

        /**
         * ActionConfig operation.
         * @member {dataform.ActionConfig.IOperationConfig|null|undefined} operation
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.operation = null;

        /**
         * ActionConfig declaration.
         * @member {dataform.ActionConfig.IDeclarationConfig|null|undefined} declaration
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.declaration = null;

        /**
         * ActionConfig notebook.
         * @member {dataform.ActionConfig.INotebookConfig|null|undefined} notebook
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.notebook = null;

        /**
         * ActionConfig dataPreparation.
         * @member {dataform.ActionConfig.IDataPreparationConfig|null|undefined} dataPreparation
         * @memberof dataform.ActionConfig
         * @instance
         */
        ActionConfig.prototype.dataPreparation = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ActionConfig action.
         * @member {"table"|"view"|"incrementalTable"|"assertion"|"operation"|"declaration"|"notebook"|"dataPreparation"|undefined} action
         * @memberof dataform.ActionConfig
         * @instance
         */
        Object.defineProperty(ActionConfig.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["table", "view", "incrementalTable", "assertion", "operation", "declaration", "notebook", "dataPreparation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ActionConfig instance using the specified properties.
         * @function create
         * @memberof dataform.ActionConfig
         * @static
         * @param {dataform.IActionConfig=} [properties] Properties to set
         * @returns {dataform.ActionConfig} ActionConfig instance
         */
        ActionConfig.create = function create(properties) {
            return new ActionConfig(properties);
        };

        /**
         * Encodes the specified ActionConfig message. Does not implicitly {@link dataform.ActionConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionConfig
         * @static
         * @param {dataform.IActionConfig} message ActionConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                $root.dataform.ActionConfig.TableConfig.encode(message.table, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.view != null && Object.hasOwnProperty.call(message, "view"))
                $root.dataform.ActionConfig.ViewConfig.encode(message.view, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.incrementalTable != null && Object.hasOwnProperty.call(message, "incrementalTable"))
                $root.dataform.ActionConfig.IncrementalTableConfig.encode(message.incrementalTable, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.assertion != null && Object.hasOwnProperty.call(message, "assertion"))
                $root.dataform.ActionConfig.AssertionConfig.encode(message.assertion, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                $root.dataform.ActionConfig.OperationConfig.encode(message.operation, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.declaration != null && Object.hasOwnProperty.call(message, "declaration"))
                $root.dataform.ActionConfig.DeclarationConfig.encode(message.declaration, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.notebook != null && Object.hasOwnProperty.call(message, "notebook"))
                $root.dataform.ActionConfig.NotebookConfig.encode(message.notebook, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.dataPreparation != null && Object.hasOwnProperty.call(message, "dataPreparation"))
                $root.dataform.ActionConfig.DataPreparationConfig.encode(message.dataPreparation, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionConfig
         * @static
         * @param {dataform.IActionConfig} message ActionConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionConfig} ActionConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.table = $root.dataform.ActionConfig.TableConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.view = $root.dataform.ActionConfig.ViewConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.incrementalTable = $root.dataform.ActionConfig.IncrementalTableConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.assertion = $root.dataform.ActionConfig.AssertionConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.operation = $root.dataform.ActionConfig.OperationConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.declaration = $root.dataform.ActionConfig.DeclarationConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.notebook = $root.dataform.ActionConfig.NotebookConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.dataPreparation = $root.dataform.ActionConfig.DataPreparationConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionConfig} ActionConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionConfig message.
         * @function verify
         * @memberof dataform.ActionConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.table != null && message.hasOwnProperty("table")) {
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.TableConfig.verify(message.table);
                    if (error)
                        return "table." + error;
                }
            }
            if (message.view != null && message.hasOwnProperty("view")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.ViewConfig.verify(message.view);
                    if (error)
                        return "view." + error;
                }
            }
            if (message.incrementalTable != null && message.hasOwnProperty("incrementalTable")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.IncrementalTableConfig.verify(message.incrementalTable);
                    if (error)
                        return "incrementalTable." + error;
                }
            }
            if (message.assertion != null && message.hasOwnProperty("assertion")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.AssertionConfig.verify(message.assertion);
                    if (error)
                        return "assertion." + error;
                }
            }
            if (message.operation != null && message.hasOwnProperty("operation")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.OperationConfig.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
            }
            if (message.declaration != null && message.hasOwnProperty("declaration")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.DeclarationConfig.verify(message.declaration);
                    if (error)
                        return "declaration." + error;
                }
            }
            if (message.notebook != null && message.hasOwnProperty("notebook")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.NotebookConfig.verify(message.notebook);
                    if (error)
                        return "notebook." + error;
                }
            }
            if (message.dataPreparation != null && message.hasOwnProperty("dataPreparation")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.dataform.ActionConfig.DataPreparationConfig.verify(message.dataPreparation);
                    if (error)
                        return "dataPreparation." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ActionConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionConfig} ActionConfig
         */
        ActionConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionConfig)
                return object;
            let message = new $root.dataform.ActionConfig();
            if (object.table != null) {
                if (typeof object.table !== "object")
                    throw TypeError(".dataform.ActionConfig.table: object expected");
                message.table = $root.dataform.ActionConfig.TableConfig.fromObject(object.table);
            }
            if (object.view != null) {
                if (typeof object.view !== "object")
                    throw TypeError(".dataform.ActionConfig.view: object expected");
                message.view = $root.dataform.ActionConfig.ViewConfig.fromObject(object.view);
            }
            if (object.incrementalTable != null) {
                if (typeof object.incrementalTable !== "object")
                    throw TypeError(".dataform.ActionConfig.incrementalTable: object expected");
                message.incrementalTable = $root.dataform.ActionConfig.IncrementalTableConfig.fromObject(object.incrementalTable);
            }
            if (object.assertion != null) {
                if (typeof object.assertion !== "object")
                    throw TypeError(".dataform.ActionConfig.assertion: object expected");
                message.assertion = $root.dataform.ActionConfig.AssertionConfig.fromObject(object.assertion);
            }
            if (object.operation != null) {
                if (typeof object.operation !== "object")
                    throw TypeError(".dataform.ActionConfig.operation: object expected");
                message.operation = $root.dataform.ActionConfig.OperationConfig.fromObject(object.operation);
            }
            if (object.declaration != null) {
                if (typeof object.declaration !== "object")
                    throw TypeError(".dataform.ActionConfig.declaration: object expected");
                message.declaration = $root.dataform.ActionConfig.DeclarationConfig.fromObject(object.declaration);
            }
            if (object.notebook != null) {
                if (typeof object.notebook !== "object")
                    throw TypeError(".dataform.ActionConfig.notebook: object expected");
                message.notebook = $root.dataform.ActionConfig.NotebookConfig.fromObject(object.notebook);
            }
            if (object.dataPreparation != null) {
                if (typeof object.dataPreparation !== "object")
                    throw TypeError(".dataform.ActionConfig.dataPreparation: object expected");
                message.dataPreparation = $root.dataform.ActionConfig.DataPreparationConfig.fromObject(object.dataPreparation);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionConfig
         * @static
         * @param {dataform.ActionConfig} message ActionConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.table != null && message.hasOwnProperty("table")) {
                object.table = $root.dataform.ActionConfig.TableConfig.toObject(message.table, options);
                if (options.oneofs)
                    object.action = "table";
            }
            if (message.view != null && message.hasOwnProperty("view")) {
                object.view = $root.dataform.ActionConfig.ViewConfig.toObject(message.view, options);
                if (options.oneofs)
                    object.action = "view";
            }
            if (message.incrementalTable != null && message.hasOwnProperty("incrementalTable")) {
                object.incrementalTable = $root.dataform.ActionConfig.IncrementalTableConfig.toObject(message.incrementalTable, options);
                if (options.oneofs)
                    object.action = "incrementalTable";
            }
            if (message.assertion != null && message.hasOwnProperty("assertion")) {
                object.assertion = $root.dataform.ActionConfig.AssertionConfig.toObject(message.assertion, options);
                if (options.oneofs)
                    object.action = "assertion";
            }
            if (message.operation != null && message.hasOwnProperty("operation")) {
                object.operation = $root.dataform.ActionConfig.OperationConfig.toObject(message.operation, options);
                if (options.oneofs)
                    object.action = "operation";
            }
            if (message.declaration != null && message.hasOwnProperty("declaration")) {
                object.declaration = $root.dataform.ActionConfig.DeclarationConfig.toObject(message.declaration, options);
                if (options.oneofs)
                    object.action = "declaration";
            }
            if (message.notebook != null && message.hasOwnProperty("notebook")) {
                object.notebook = $root.dataform.ActionConfig.NotebookConfig.toObject(message.notebook, options);
                if (options.oneofs)
                    object.action = "notebook";
            }
            if (message.dataPreparation != null && message.hasOwnProperty("dataPreparation")) {
                object.dataPreparation = $root.dataform.ActionConfig.DataPreparationConfig.toObject(message.dataPreparation, options);
                if (options.oneofs)
                    object.action = "dataPreparation";
            }
            return object;
        };

        /**
         * Converts this ActionConfig to JSON.
         * @function toJSON
         * @memberof dataform.ActionConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionConfig
         * @function getTypeUrl
         * @memberof dataform.ActionConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionConfig";
        };

        ActionConfig.Target = (function() {

            /**
             * Properties of a Target.
             * @memberof dataform.ActionConfig
             * @interface ITarget
             * @property {string|null} [project] Target project
             * @property {string|null} [dataset] Target dataset
             * @property {string|null} [name] Target name
             * @property {boolean|null} [includeDependentAssertions] Target includeDependentAssertions
             */

            /**
             * Constructs a new Target.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a Target.
             * @implements ITarget
             * @constructor
             * @param {dataform.ActionConfig.ITarget=} [properties] Properties to set
             */
            function Target(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Target project.
             * @member {string} project
             * @memberof dataform.ActionConfig.Target
             * @instance
             */
            Target.prototype.project = "";

            /**
             * Target dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.Target
             * @instance
             */
            Target.prototype.dataset = "";

            /**
             * Target name.
             * @member {string} name
             * @memberof dataform.ActionConfig.Target
             * @instance
             */
            Target.prototype.name = "";

            /**
             * Target includeDependentAssertions.
             * @member {boolean} includeDependentAssertions
             * @memberof dataform.ActionConfig.Target
             * @instance
             */
            Target.prototype.includeDependentAssertions = false;

            /**
             * Creates a new Target instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {dataform.ActionConfig.ITarget=} [properties] Properties to set
             * @returns {dataform.ActionConfig.Target} Target instance
             */
            Target.create = function create(properties) {
                return new Target(properties);
            };

            /**
             * Encodes the specified Target message. Does not implicitly {@link dataform.ActionConfig.Target.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {dataform.ActionConfig.ITarget} message Target message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Target.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.project);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                if (message.includeDependentAssertions != null && Object.hasOwnProperty.call(message, "includeDependentAssertions"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeDependentAssertions);
                return writer;
            };

            /**
             * Encodes the specified Target message, length delimited. Does not implicitly {@link dataform.ActionConfig.Target.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {dataform.ActionConfig.ITarget} message Target message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Target.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Target message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.Target} Target
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Target.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.Target();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.project = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 4: {
                            message.name = reader.string();
                            break;
                        }
                    case 5: {
                            message.includeDependentAssertions = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Target message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.Target} Target
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Target.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Target message.
             * @function verify
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Target.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.includeDependentAssertions != null && message.hasOwnProperty("includeDependentAssertions"))
                    if (typeof message.includeDependentAssertions !== "boolean")
                        return "includeDependentAssertions: boolean expected";
                return null;
            };

            /**
             * Creates a Target message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.Target} Target
             */
            Target.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.Target)
                    return object;
                let message = new $root.dataform.ActionConfig.Target();
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.includeDependentAssertions != null)
                    message.includeDependentAssertions = Boolean(object.includeDependentAssertions);
                return message;
            };

            /**
             * Creates a plain object from a Target message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {dataform.ActionConfig.Target} message Target
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Target.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.project = "";
                    object.dataset = "";
                    object.name = "";
                    object.includeDependentAssertions = false;
                }
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.includeDependentAssertions != null && message.hasOwnProperty("includeDependentAssertions"))
                    object.includeDependentAssertions = message.includeDependentAssertions;
                return object;
            };

            /**
             * Converts this Target to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.Target
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Target.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Target
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.Target
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Target.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.Target";
            };

            return Target;
        })();

        ActionConfig.ColumnDescriptor = (function() {

            /**
             * Properties of a ColumnDescriptor.
             * @memberof dataform.ActionConfig
             * @interface IColumnDescriptor
             * @property {Array.<string>|null} [path] ColumnDescriptor path
             * @property {string|null} [description] ColumnDescriptor description
             * @property {Array.<string>|null} [bigqueryPolicyTags] ColumnDescriptor bigqueryPolicyTags
             * @property {Array.<string>|null} [tags] ColumnDescriptor tags
             */

            /**
             * Constructs a new ColumnDescriptor.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a ColumnDescriptor.
             * @implements IColumnDescriptor
             * @constructor
             * @param {dataform.ActionConfig.IColumnDescriptor=} [properties] Properties to set
             */
            function ColumnDescriptor(properties) {
                this.path = [];
                this.bigqueryPolicyTags = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnDescriptor path.
             * @member {Array.<string>} path
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @instance
             */
            ColumnDescriptor.prototype.path = $util.emptyArray;

            /**
             * ColumnDescriptor description.
             * @member {string} description
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @instance
             */
            ColumnDescriptor.prototype.description = "";

            /**
             * ColumnDescriptor bigqueryPolicyTags.
             * @member {Array.<string>} bigqueryPolicyTags
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @instance
             */
            ColumnDescriptor.prototype.bigqueryPolicyTags = $util.emptyArray;

            /**
             * ColumnDescriptor tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @instance
             */
            ColumnDescriptor.prototype.tags = $util.emptyArray;

            /**
             * Creates a new ColumnDescriptor instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {dataform.ActionConfig.IColumnDescriptor=} [properties] Properties to set
             * @returns {dataform.ActionConfig.ColumnDescriptor} ColumnDescriptor instance
             */
            ColumnDescriptor.create = function create(properties) {
                return new ColumnDescriptor(properties);
            };

            /**
             * Encodes the specified ColumnDescriptor message. Does not implicitly {@link dataform.ActionConfig.ColumnDescriptor.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {dataform.ActionConfig.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.path.length)
                    for (let i = 0; i < message.path.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path[i]);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                if (message.bigqueryPolicyTags != null && message.bigqueryPolicyTags.length)
                    for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.bigqueryPolicyTags[i]);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                return writer;
            };

            /**
             * Encodes the specified ColumnDescriptor message, length delimited. Does not implicitly {@link dataform.ActionConfig.ColumnDescriptor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {dataform.ActionConfig.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnDescriptor message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.ColumnDescriptor} ColumnDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.ColumnDescriptor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.path && message.path.length))
                                message.path = [];
                            message.path.push(reader.string());
                            break;
                        }
                    case 2: {
                            message.description = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.bigqueryPolicyTags && message.bigqueryPolicyTags.length))
                                message.bigqueryPolicyTags = [];
                            message.bigqueryPolicyTags.push(reader.string());
                            break;
                        }
                    case 4: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnDescriptor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.ColumnDescriptor} ColumnDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnDescriptor message.
             * @function verify
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path")) {
                    if (!Array.isArray(message.path))
                        return "path: array expected";
                    for (let i = 0; i < message.path.length; ++i)
                        if (!$util.isString(message.path[i]))
                            return "path: string[] expected";
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.bigqueryPolicyTags != null && message.hasOwnProperty("bigqueryPolicyTags")) {
                    if (!Array.isArray(message.bigqueryPolicyTags))
                        return "bigqueryPolicyTags: array expected";
                    for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                        if (!$util.isString(message.bigqueryPolicyTags[i]))
                            return "bigqueryPolicyTags: string[] expected";
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ColumnDescriptor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.ColumnDescriptor} ColumnDescriptor
             */
            ColumnDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.ColumnDescriptor)
                    return object;
                let message = new $root.dataform.ActionConfig.ColumnDescriptor();
                if (object.path) {
                    if (!Array.isArray(object.path))
                        throw TypeError(".dataform.ActionConfig.ColumnDescriptor.path: array expected");
                    message.path = [];
                    for (let i = 0; i < object.path.length; ++i)
                        message.path[i] = String(object.path[i]);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.bigqueryPolicyTags) {
                    if (!Array.isArray(object.bigqueryPolicyTags))
                        throw TypeError(".dataform.ActionConfig.ColumnDescriptor.bigqueryPolicyTags: array expected");
                    message.bigqueryPolicyTags = [];
                    for (let i = 0; i < object.bigqueryPolicyTags.length; ++i)
                        message.bigqueryPolicyTags[i] = String(object.bigqueryPolicyTags[i]);
                }
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.ColumnDescriptor.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ColumnDescriptor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {dataform.ActionConfig.ColumnDescriptor} message ColumnDescriptor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.path = [];
                    object.bigqueryPolicyTags = [];
                    object.tags = [];
                }
                if (options.defaults)
                    object.description = "";
                if (message.path && message.path.length) {
                    object.path = [];
                    for (let j = 0; j < message.path.length; ++j)
                        object.path[j] = message.path[j];
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.bigqueryPolicyTags && message.bigqueryPolicyTags.length) {
                    object.bigqueryPolicyTags = [];
                    for (let j = 0; j < message.bigqueryPolicyTags.length; ++j)
                        object.bigqueryPolicyTags[j] = message.bigqueryPolicyTags[j];
                }
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                return object;
            };

            /**
             * Converts this ColumnDescriptor to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ColumnDescriptor
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.ColumnDescriptor
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ColumnDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.ColumnDescriptor";
            };

            return ColumnDescriptor;
        })();

        ActionConfig.TableAssertionsConfig = (function() {

            /**
             * Properties of a TableAssertionsConfig.
             * @memberof dataform.ActionConfig
             * @interface ITableAssertionsConfig
             * @property {Array.<string>|null} [uniqueKey] TableAssertionsConfig uniqueKey
             * @property {Array.<dataform.ActionConfig.TableAssertionsConfig.IUniqueKey>|null} [uniqueKeys] TableAssertionsConfig uniqueKeys
             * @property {Array.<string>|null} [nonNull] TableAssertionsConfig nonNull
             * @property {Array.<string>|null} [rowConditions] TableAssertionsConfig rowConditions
             */

            /**
             * Constructs a new TableAssertionsConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a TableAssertionsConfig.
             * @implements ITableAssertionsConfig
             * @constructor
             * @param {dataform.ActionConfig.ITableAssertionsConfig=} [properties] Properties to set
             */
            function TableAssertionsConfig(properties) {
                this.uniqueKey = [];
                this.uniqueKeys = [];
                this.nonNull = [];
                this.rowConditions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableAssertionsConfig uniqueKey.
             * @member {Array.<string>} uniqueKey
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @instance
             */
            TableAssertionsConfig.prototype.uniqueKey = $util.emptyArray;

            /**
             * TableAssertionsConfig uniqueKeys.
             * @member {Array.<dataform.ActionConfig.TableAssertionsConfig.IUniqueKey>} uniqueKeys
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @instance
             */
            TableAssertionsConfig.prototype.uniqueKeys = $util.emptyArray;

            /**
             * TableAssertionsConfig nonNull.
             * @member {Array.<string>} nonNull
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @instance
             */
            TableAssertionsConfig.prototype.nonNull = $util.emptyArray;

            /**
             * TableAssertionsConfig rowConditions.
             * @member {Array.<string>} rowConditions
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @instance
             */
            TableAssertionsConfig.prototype.rowConditions = $util.emptyArray;

            /**
             * Creates a new TableAssertionsConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {dataform.ActionConfig.ITableAssertionsConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.TableAssertionsConfig} TableAssertionsConfig instance
             */
            TableAssertionsConfig.create = function create(properties) {
                return new TableAssertionsConfig(properties);
            };

            /**
             * Encodes the specified TableAssertionsConfig message. Does not implicitly {@link dataform.ActionConfig.TableAssertionsConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {dataform.ActionConfig.ITableAssertionsConfig} message TableAssertionsConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAssertionsConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uniqueKey != null && message.uniqueKey.length)
                    for (let i = 0; i < message.uniqueKey.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uniqueKey[i]);
                if (message.uniqueKeys != null && message.uniqueKeys.length)
                    for (let i = 0; i < message.uniqueKeys.length; ++i)
                        $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey.encode(message.uniqueKeys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nonNull != null && message.nonNull.length)
                    for (let i = 0; i < message.nonNull.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.nonNull[i]);
                if (message.rowConditions != null && message.rowConditions.length)
                    for (let i = 0; i < message.rowConditions.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.rowConditions[i]);
                return writer;
            };

            /**
             * Encodes the specified TableAssertionsConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.TableAssertionsConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {dataform.ActionConfig.ITableAssertionsConfig} message TableAssertionsConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAssertionsConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableAssertionsConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.TableAssertionsConfig} TableAssertionsConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAssertionsConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.TableAssertionsConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.uniqueKey && message.uniqueKey.length))
                                message.uniqueKey = [];
                            message.uniqueKey.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.uniqueKeys && message.uniqueKeys.length))
                                message.uniqueKeys = [];
                            message.uniqueKeys.push($root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.nonNull && message.nonNull.length))
                                message.nonNull = [];
                            message.nonNull.push(reader.string());
                            break;
                        }
                    case 4: {
                            if (!(message.rowConditions && message.rowConditions.length))
                                message.rowConditions = [];
                            message.rowConditions.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableAssertionsConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.TableAssertionsConfig} TableAssertionsConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAssertionsConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableAssertionsConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableAssertionsConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                    if (!Array.isArray(message.uniqueKey))
                        return "uniqueKey: array expected";
                    for (let i = 0; i < message.uniqueKey.length; ++i)
                        if (!$util.isString(message.uniqueKey[i]))
                            return "uniqueKey: string[] expected";
                }
                if (message.uniqueKeys != null && message.hasOwnProperty("uniqueKeys")) {
                    if (!Array.isArray(message.uniqueKeys))
                        return "uniqueKeys: array expected";
                    for (let i = 0; i < message.uniqueKeys.length; ++i) {
                        let error = $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey.verify(message.uniqueKeys[i]);
                        if (error)
                            return "uniqueKeys." + error;
                    }
                }
                if (message.nonNull != null && message.hasOwnProperty("nonNull")) {
                    if (!Array.isArray(message.nonNull))
                        return "nonNull: array expected";
                    for (let i = 0; i < message.nonNull.length; ++i)
                        if (!$util.isString(message.nonNull[i]))
                            return "nonNull: string[] expected";
                }
                if (message.rowConditions != null && message.hasOwnProperty("rowConditions")) {
                    if (!Array.isArray(message.rowConditions))
                        return "rowConditions: array expected";
                    for (let i = 0; i < message.rowConditions.length; ++i)
                        if (!$util.isString(message.rowConditions[i]))
                            return "rowConditions: string[] expected";
                }
                return null;
            };

            /**
             * Creates a TableAssertionsConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.TableAssertionsConfig} TableAssertionsConfig
             */
            TableAssertionsConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.TableAssertionsConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.TableAssertionsConfig();
                if (object.uniqueKey) {
                    if (!Array.isArray(object.uniqueKey))
                        throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.uniqueKey: array expected");
                    message.uniqueKey = [];
                    for (let i = 0; i < object.uniqueKey.length; ++i)
                        message.uniqueKey[i] = String(object.uniqueKey[i]);
                }
                if (object.uniqueKeys) {
                    if (!Array.isArray(object.uniqueKeys))
                        throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.uniqueKeys: array expected");
                    message.uniqueKeys = [];
                    for (let i = 0; i < object.uniqueKeys.length; ++i) {
                        if (typeof object.uniqueKeys[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.uniqueKeys: object expected");
                        message.uniqueKeys[i] = $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey.fromObject(object.uniqueKeys[i]);
                    }
                }
                if (object.nonNull) {
                    if (!Array.isArray(object.nonNull))
                        throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.nonNull: array expected");
                    message.nonNull = [];
                    for (let i = 0; i < object.nonNull.length; ++i)
                        message.nonNull[i] = String(object.nonNull[i]);
                }
                if (object.rowConditions) {
                    if (!Array.isArray(object.rowConditions))
                        throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.rowConditions: array expected");
                    message.rowConditions = [];
                    for (let i = 0; i < object.rowConditions.length; ++i)
                        message.rowConditions[i] = String(object.rowConditions[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableAssertionsConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {dataform.ActionConfig.TableAssertionsConfig} message TableAssertionsConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableAssertionsConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.uniqueKey = [];
                    object.uniqueKeys = [];
                    object.nonNull = [];
                    object.rowConditions = [];
                }
                if (message.uniqueKey && message.uniqueKey.length) {
                    object.uniqueKey = [];
                    for (let j = 0; j < message.uniqueKey.length; ++j)
                        object.uniqueKey[j] = message.uniqueKey[j];
                }
                if (message.uniqueKeys && message.uniqueKeys.length) {
                    object.uniqueKeys = [];
                    for (let j = 0; j < message.uniqueKeys.length; ++j)
                        object.uniqueKeys[j] = $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey.toObject(message.uniqueKeys[j], options);
                }
                if (message.nonNull && message.nonNull.length) {
                    object.nonNull = [];
                    for (let j = 0; j < message.nonNull.length; ++j)
                        object.nonNull[j] = message.nonNull[j];
                }
                if (message.rowConditions && message.rowConditions.length) {
                    object.rowConditions = [];
                    for (let j = 0; j < message.rowConditions.length; ++j)
                        object.rowConditions[j] = message.rowConditions[j];
                }
                return object;
            };

            /**
             * Converts this TableAssertionsConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableAssertionsConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TableAssertionsConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.TableAssertionsConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TableAssertionsConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.TableAssertionsConfig";
            };

            TableAssertionsConfig.UniqueKey = (function() {

                /**
                 * Properties of an UniqueKey.
                 * @memberof dataform.ActionConfig.TableAssertionsConfig
                 * @interface IUniqueKey
                 * @property {Array.<string>|null} [uniqueKey] UniqueKey uniqueKey
                 */

                /**
                 * Constructs a new UniqueKey.
                 * @memberof dataform.ActionConfig.TableAssertionsConfig
                 * @classdesc Represents an UniqueKey.
                 * @implements IUniqueKey
                 * @constructor
                 * @param {dataform.ActionConfig.TableAssertionsConfig.IUniqueKey=} [properties] Properties to set
                 */
                function UniqueKey(properties) {
                    this.uniqueKey = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UniqueKey uniqueKey.
                 * @member {Array.<string>} uniqueKey
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @instance
                 */
                UniqueKey.prototype.uniqueKey = $util.emptyArray;

                /**
                 * Creates a new UniqueKey instance using the specified properties.
                 * @function create
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {dataform.ActionConfig.TableAssertionsConfig.IUniqueKey=} [properties] Properties to set
                 * @returns {dataform.ActionConfig.TableAssertionsConfig.UniqueKey} UniqueKey instance
                 */
                UniqueKey.create = function create(properties) {
                    return new UniqueKey(properties);
                };

                /**
                 * Encodes the specified UniqueKey message. Does not implicitly {@link dataform.ActionConfig.TableAssertionsConfig.UniqueKey.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {dataform.ActionConfig.TableAssertionsConfig.IUniqueKey} message UniqueKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UniqueKey.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uniqueKey != null && message.uniqueKey.length)
                        for (let i = 0; i < message.uniqueKey.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.uniqueKey[i]);
                    return writer;
                };

                /**
                 * Encodes the specified UniqueKey message, length delimited. Does not implicitly {@link dataform.ActionConfig.TableAssertionsConfig.UniqueKey.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {dataform.ActionConfig.TableAssertionsConfig.IUniqueKey} message UniqueKey message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UniqueKey.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UniqueKey message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.ActionConfig.TableAssertionsConfig.UniqueKey} UniqueKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UniqueKey.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.uniqueKey && message.uniqueKey.length))
                                    message.uniqueKey = [];
                                message.uniqueKey.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UniqueKey message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.ActionConfig.TableAssertionsConfig.UniqueKey} UniqueKey
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UniqueKey.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UniqueKey message.
                 * @function verify
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UniqueKey.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                        if (!Array.isArray(message.uniqueKey))
                            return "uniqueKey: array expected";
                        for (let i = 0; i < message.uniqueKey.length; ++i)
                            if (!$util.isString(message.uniqueKey[i]))
                                return "uniqueKey: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an UniqueKey message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.ActionConfig.TableAssertionsConfig.UniqueKey} UniqueKey
                 */
                UniqueKey.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey)
                        return object;
                    let message = new $root.dataform.ActionConfig.TableAssertionsConfig.UniqueKey();
                    if (object.uniqueKey) {
                        if (!Array.isArray(object.uniqueKey))
                            throw TypeError(".dataform.ActionConfig.TableAssertionsConfig.UniqueKey.uniqueKey: array expected");
                        message.uniqueKey = [];
                        for (let i = 0; i < object.uniqueKey.length; ++i)
                            message.uniqueKey[i] = String(object.uniqueKey[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UniqueKey message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {dataform.ActionConfig.TableAssertionsConfig.UniqueKey} message UniqueKey
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UniqueKey.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.uniqueKey = [];
                    if (message.uniqueKey && message.uniqueKey.length) {
                        object.uniqueKey = [];
                        for (let j = 0; j < message.uniqueKey.length; ++j)
                            object.uniqueKey[j] = message.uniqueKey[j];
                    }
                    return object;
                };

                /**
                 * Converts this UniqueKey to JSON.
                 * @function toJSON
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UniqueKey.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for UniqueKey
                 * @function getTypeUrl
                 * @memberof dataform.ActionConfig.TableAssertionsConfig.UniqueKey
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                UniqueKey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/dataform.ActionConfig.TableAssertionsConfig.UniqueKey";
                };

                return UniqueKey;
            })();

            return TableAssertionsConfig;
        })();

        ActionConfig.TableConfig = (function() {

            /**
             * Properties of a TableConfig.
             * @memberof dataform.ActionConfig
             * @interface ITableConfig
             * @property {string|null} [name] TableConfig name
             * @property {string|null} [dataset] TableConfig dataset
             * @property {string|null} [project] TableConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] TableConfig dependencyTargets
             * @property {string|null} [filename] TableConfig filename
             * @property {Array.<string>|null} [tags] TableConfig tags
             * @property {boolean|null} [disabled] TableConfig disabled
             * @property {Array.<string>|null} [preOperations] TableConfig preOperations
             * @property {Array.<string>|null} [postOperations] TableConfig postOperations
             * @property {string|null} [description] TableConfig description
             * @property {Array.<dataform.ActionConfig.IColumnDescriptor>|null} [columns] TableConfig columns
             * @property {string|null} [partitionBy] TableConfig partitionBy
             * @property {number|null} [partitionExpirationDays] TableConfig partitionExpirationDays
             * @property {boolean|null} [requirePartitionFilter] TableConfig requirePartitionFilter
             * @property {Array.<string>|null} [clusterBy] TableConfig clusterBy
             * @property {Object.<string,string>|null} [labels] TableConfig labels
             * @property {Object.<string,string>|null} [additionalOptions] TableConfig additionalOptions
             * @property {boolean|null} [dependOnDependencyAssertions] TableConfig dependOnDependencyAssertions
             * @property {dataform.ActionConfig.ITableAssertionsConfig|null} [assertions] TableConfig assertions
             * @property {boolean|null} [hermetic] TableConfig hermetic
             */

            /**
             * Constructs a new TableConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a TableConfig.
             * @implements ITableConfig
             * @constructor
             * @param {dataform.ActionConfig.ITableConfig=} [properties] Properties to set
             */
            function TableConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                this.preOperations = [];
                this.postOperations = [];
                this.columns = [];
                this.clusterBy = [];
                this.labels = {};
                this.additionalOptions = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.name = "";

            /**
             * TableConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.dataset = "";

            /**
             * TableConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.project = "";

            /**
             * TableConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * TableConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.filename = "";

            /**
             * TableConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.tags = $util.emptyArray;

            /**
             * TableConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.disabled = false;

            /**
             * TableConfig preOperations.
             * @member {Array.<string>} preOperations
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.preOperations = $util.emptyArray;

            /**
             * TableConfig postOperations.
             * @member {Array.<string>} postOperations
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.postOperations = $util.emptyArray;

            /**
             * TableConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.description = "";

            /**
             * TableConfig columns.
             * @member {Array.<dataform.ActionConfig.IColumnDescriptor>} columns
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.columns = $util.emptyArray;

            /**
             * TableConfig partitionBy.
             * @member {string} partitionBy
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.partitionBy = "";

            /**
             * TableConfig partitionExpirationDays.
             * @member {number} partitionExpirationDays
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.partitionExpirationDays = 0;

            /**
             * TableConfig requirePartitionFilter.
             * @member {boolean} requirePartitionFilter
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.requirePartitionFilter = false;

            /**
             * TableConfig clusterBy.
             * @member {Array.<string>} clusterBy
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.clusterBy = $util.emptyArray;

            /**
             * TableConfig labels.
             * @member {Object.<string,string>} labels
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.labels = $util.emptyObject;

            /**
             * TableConfig additionalOptions.
             * @member {Object.<string,string>} additionalOptions
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.additionalOptions = $util.emptyObject;

            /**
             * TableConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * TableConfig assertions.
             * @member {dataform.ActionConfig.ITableAssertionsConfig|null|undefined} assertions
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.assertions = null;

            /**
             * TableConfig hermetic.
             * @member {boolean} hermetic
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             */
            TableConfig.prototype.hermetic = false;

            /**
             * Creates a new TableConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {dataform.ActionConfig.ITableConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.TableConfig} TableConfig instance
             */
            TableConfig.create = function create(properties) {
                return new TableConfig(properties);
            };

            /**
             * Encodes the specified TableConfig message. Does not implicitly {@link dataform.ActionConfig.TableConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {dataform.ActionConfig.ITableConfig} message TableConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.preOperations != null && message.preOperations.length)
                    for (let i = 0; i < message.preOperations.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.preOperations[i]);
                if (message.postOperations != null && message.postOperations.length)
                    for (let i = 0; i < message.postOperations.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.postOperations[i]);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.description);
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.dataform.ActionConfig.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.partitionBy != null && Object.hasOwnProperty.call(message, "partitionBy"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.partitionBy);
                if (message.partitionExpirationDays != null && Object.hasOwnProperty.call(message, "partitionExpirationDays"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.partitionExpirationDays);
                if (message.requirePartitionFilter != null && Object.hasOwnProperty.call(message, "requirePartitionFilter"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.requirePartitionFilter);
                if (message.clusterBy != null && message.clusterBy.length)
                    for (let i = 0; i < message.clusterBy.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.clusterBy[i]);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 16, wireType 2 =*/130).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.additionalOptions != null && Object.hasOwnProperty.call(message, "additionalOptions"))
                    for (let keys = Object.keys(message.additionalOptions), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 17, wireType 2 =*/138).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.additionalOptions[keys[i]]).ldelim();
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.dependOnDependencyAssertions);
                if (message.assertions != null && Object.hasOwnProperty.call(message, "assertions"))
                    $root.dataform.ActionConfig.TableAssertionsConfig.encode(message.assertions, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.hermetic != null && Object.hasOwnProperty.call(message, "hermetic"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.hermetic);
                return writer;
            };

            /**
             * Encodes the specified TableConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.TableConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {dataform.ActionConfig.ITableConfig} message TableConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.TableConfig} TableConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.TableConfig(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            if (!(message.preOperations && message.preOperations.length))
                                message.preOperations = [];
                            message.preOperations.push(reader.string());
                            break;
                        }
                    case 9: {
                            if (!(message.postOperations && message.postOperations.length))
                                message.postOperations = [];
                            message.postOperations.push(reader.string());
                            break;
                        }
                    case 10: {
                            message.description = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.dataform.ActionConfig.ColumnDescriptor.decode(reader, reader.uint32()));
                            break;
                        }
                    case 12: {
                            message.partitionBy = reader.string();
                            break;
                        }
                    case 13: {
                            message.partitionExpirationDays = reader.int32();
                            break;
                        }
                    case 14: {
                            message.requirePartitionFilter = reader.bool();
                            break;
                        }
                    case 15: {
                            if (!(message.clusterBy && message.clusterBy.length))
                                message.clusterBy = [];
                            message.clusterBy.push(reader.string());
                            break;
                        }
                    case 16: {
                            if (message.labels === $util.emptyObject)
                                message.labels = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.labels[key] = value;
                            break;
                        }
                    case 17: {
                            if (message.additionalOptions === $util.emptyObject)
                                message.additionalOptions = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.additionalOptions[key] = value;
                            break;
                        }
                    case 18: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    case 19: {
                            message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.hermetic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.TableConfig} TableConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.preOperations != null && message.hasOwnProperty("preOperations")) {
                    if (!Array.isArray(message.preOperations))
                        return "preOperations: array expected";
                    for (let i = 0; i < message.preOperations.length; ++i)
                        if (!$util.isString(message.preOperations[i]))
                            return "preOperations: string[] expected";
                }
                if (message.postOperations != null && message.hasOwnProperty("postOperations")) {
                    if (!Array.isArray(message.postOperations))
                        return "postOperations: array expected";
                    for (let i = 0; i < message.postOperations.length; ++i)
                        if (!$util.isString(message.postOperations[i]))
                            return "postOperations: string[] expected";
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.dataform.ActionConfig.ColumnDescriptor.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                    if (!$util.isString(message.partitionBy))
                        return "partitionBy: string expected";
                if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                    if (!$util.isInteger(message.partitionExpirationDays))
                        return "partitionExpirationDays: integer expected";
                if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                    if (typeof message.requirePartitionFilter !== "boolean")
                        return "requirePartitionFilter: boolean expected";
                if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                    if (!Array.isArray(message.clusterBy))
                        return "clusterBy: array expected";
                    for (let i = 0; i < message.clusterBy.length; ++i)
                        if (!$util.isString(message.clusterBy[i]))
                            return "clusterBy: string[] expected";
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    let key = Object.keys(message.labels);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.additionalOptions != null && message.hasOwnProperty("additionalOptions")) {
                    if (!$util.isObject(message.additionalOptions))
                        return "additionalOptions: object expected";
                    let key = Object.keys(message.additionalOptions);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.additionalOptions[key[i]]))
                            return "additionalOptions: string{k:string} expected";
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                if (message.assertions != null && message.hasOwnProperty("assertions")) {
                    let error = $root.dataform.ActionConfig.TableAssertionsConfig.verify(message.assertions);
                    if (error)
                        return "assertions." + error;
                }
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    if (typeof message.hermetic !== "boolean")
                        return "hermetic: boolean expected";
                return null;
            };

            /**
             * Creates a TableConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.TableConfig} TableConfig
             */
            TableConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.TableConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.TableConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.TableConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.TableConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.TableConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.preOperations) {
                    if (!Array.isArray(object.preOperations))
                        throw TypeError(".dataform.ActionConfig.TableConfig.preOperations: array expected");
                    message.preOperations = [];
                    for (let i = 0; i < object.preOperations.length; ++i)
                        message.preOperations[i] = String(object.preOperations[i]);
                }
                if (object.postOperations) {
                    if (!Array.isArray(object.postOperations))
                        throw TypeError(".dataform.ActionConfig.TableConfig.postOperations: array expected");
                    message.postOperations = [];
                    for (let i = 0; i < object.postOperations.length; ++i)
                        message.postOperations[i] = String(object.postOperations[i]);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".dataform.ActionConfig.TableConfig.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.TableConfig.columns: object expected");
                        message.columns[i] = $root.dataform.ActionConfig.ColumnDescriptor.fromObject(object.columns[i]);
                    }
                }
                if (object.partitionBy != null)
                    message.partitionBy = String(object.partitionBy);
                if (object.partitionExpirationDays != null)
                    message.partitionExpirationDays = object.partitionExpirationDays | 0;
                if (object.requirePartitionFilter != null)
                    message.requirePartitionFilter = Boolean(object.requirePartitionFilter);
                if (object.clusterBy) {
                    if (!Array.isArray(object.clusterBy))
                        throw TypeError(".dataform.ActionConfig.TableConfig.clusterBy: array expected");
                    message.clusterBy = [];
                    for (let i = 0; i < object.clusterBy.length; ++i)
                        message.clusterBy[i] = String(object.clusterBy[i]);
                }
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".dataform.ActionConfig.TableConfig.labels: object expected");
                    message.labels = {};
                    for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.additionalOptions) {
                    if (typeof object.additionalOptions !== "object")
                        throw TypeError(".dataform.ActionConfig.TableConfig.additionalOptions: object expected");
                    message.additionalOptions = {};
                    for (let keys = Object.keys(object.additionalOptions), i = 0; i < keys.length; ++i)
                        message.additionalOptions[keys[i]] = String(object.additionalOptions[keys[i]]);
                }
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                if (object.assertions != null) {
                    if (typeof object.assertions !== "object")
                        throw TypeError(".dataform.ActionConfig.TableConfig.assertions: object expected");
                    message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.fromObject(object.assertions);
                }
                if (object.hermetic != null)
                    message.hermetic = Boolean(object.hermetic);
                return message;
            };

            /**
             * Creates a plain object from a TableConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {dataform.ActionConfig.TableConfig} message TableConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                    object.preOperations = [];
                    object.postOperations = [];
                    object.columns = [];
                    object.clusterBy = [];
                }
                if (options.objects || options.defaults) {
                    object.labels = {};
                    object.additionalOptions = {};
                }
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object.description = "";
                    object.partitionBy = "";
                    object.partitionExpirationDays = 0;
                    object.requirePartitionFilter = false;
                    object.dependOnDependencyAssertions = false;
                    object.assertions = null;
                    object.hermetic = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.preOperations && message.preOperations.length) {
                    object.preOperations = [];
                    for (let j = 0; j < message.preOperations.length; ++j)
                        object.preOperations[j] = message.preOperations[j];
                }
                if (message.postOperations && message.postOperations.length) {
                    object.postOperations = [];
                    for (let j = 0; j < message.postOperations.length; ++j)
                        object.postOperations[j] = message.postOperations[j];
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.dataform.ActionConfig.ColumnDescriptor.toObject(message.columns[j], options);
                }
                if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                    object.partitionBy = message.partitionBy;
                if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                    object.partitionExpirationDays = message.partitionExpirationDays;
                if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                    object.requirePartitionFilter = message.requirePartitionFilter;
                if (message.clusterBy && message.clusterBy.length) {
                    object.clusterBy = [];
                    for (let j = 0; j < message.clusterBy.length; ++j)
                        object.clusterBy[j] = message.clusterBy[j];
                }
                let keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.additionalOptions && (keys2 = Object.keys(message.additionalOptions)).length) {
                    object.additionalOptions = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.additionalOptions[keys2[j]] = message.additionalOptions[keys2[j]];
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                if (message.assertions != null && message.hasOwnProperty("assertions"))
                    object.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.toObject(message.assertions, options);
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    object.hermetic = message.hermetic;
                return object;
            };

            /**
             * Converts this TableConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.TableConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TableConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.TableConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TableConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.TableConfig";
            };

            return TableConfig;
        })();

        ActionConfig.ViewConfig = (function() {

            /**
             * Properties of a ViewConfig.
             * @memberof dataform.ActionConfig
             * @interface IViewConfig
             * @property {string|null} [name] ViewConfig name
             * @property {string|null} [dataset] ViewConfig dataset
             * @property {string|null} [project] ViewConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] ViewConfig dependencyTargets
             * @property {string|null} [filename] ViewConfig filename
             * @property {Array.<string>|null} [tags] ViewConfig tags
             * @property {boolean|null} [disabled] ViewConfig disabled
             * @property {Array.<string>|null} [preOperations] ViewConfig preOperations
             * @property {Array.<string>|null} [postOperations] ViewConfig postOperations
             * @property {boolean|null} [materialized] ViewConfig materialized
             * @property {string|null} [description] ViewConfig description
             * @property {Array.<dataform.ActionConfig.IColumnDescriptor>|null} [columns] ViewConfig columns
             * @property {Object.<string,string>|null} [labels] ViewConfig labels
             * @property {Object.<string,string>|null} [additionalOptions] ViewConfig additionalOptions
             * @property {boolean|null} [dependOnDependencyAssertions] ViewConfig dependOnDependencyAssertions
             * @property {boolean|null} [hermetic] ViewConfig hermetic
             * @property {dataform.ActionConfig.ITableAssertionsConfig|null} [assertions] ViewConfig assertions
             */

            /**
             * Constructs a new ViewConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a ViewConfig.
             * @implements IViewConfig
             * @constructor
             * @param {dataform.ActionConfig.IViewConfig=} [properties] Properties to set
             */
            function ViewConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                this.preOperations = [];
                this.postOperations = [];
                this.columns = [];
                this.labels = {};
                this.additionalOptions = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ViewConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.name = "";

            /**
             * ViewConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.dataset = "";

            /**
             * ViewConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.project = "";

            /**
             * ViewConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * ViewConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.filename = "";

            /**
             * ViewConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.tags = $util.emptyArray;

            /**
             * ViewConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.disabled = false;

            /**
             * ViewConfig preOperations.
             * @member {Array.<string>} preOperations
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.preOperations = $util.emptyArray;

            /**
             * ViewConfig postOperations.
             * @member {Array.<string>} postOperations
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.postOperations = $util.emptyArray;

            /**
             * ViewConfig materialized.
             * @member {boolean} materialized
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.materialized = false;

            /**
             * ViewConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.description = "";

            /**
             * ViewConfig columns.
             * @member {Array.<dataform.ActionConfig.IColumnDescriptor>} columns
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.columns = $util.emptyArray;

            /**
             * ViewConfig labels.
             * @member {Object.<string,string>} labels
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.labels = $util.emptyObject;

            /**
             * ViewConfig additionalOptions.
             * @member {Object.<string,string>} additionalOptions
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.additionalOptions = $util.emptyObject;

            /**
             * ViewConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * ViewConfig hermetic.
             * @member {boolean} hermetic
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.hermetic = false;

            /**
             * ViewConfig assertions.
             * @member {dataform.ActionConfig.ITableAssertionsConfig|null|undefined} assertions
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             */
            ViewConfig.prototype.assertions = null;

            /**
             * Creates a new ViewConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {dataform.ActionConfig.IViewConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.ViewConfig} ViewConfig instance
             */
            ViewConfig.create = function create(properties) {
                return new ViewConfig(properties);
            };

            /**
             * Encodes the specified ViewConfig message. Does not implicitly {@link dataform.ActionConfig.ViewConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {dataform.ActionConfig.IViewConfig} message ViewConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.preOperations != null && message.preOperations.length)
                    for (let i = 0; i < message.preOperations.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.preOperations[i]);
                if (message.postOperations != null && message.postOperations.length)
                    for (let i = 0; i < message.postOperations.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.postOperations[i]);
                if (message.materialized != null && Object.hasOwnProperty.call(message, "materialized"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.materialized);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.description);
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.dataform.ActionConfig.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 13, wireType 2 =*/106).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.additionalOptions != null && Object.hasOwnProperty.call(message, "additionalOptions"))
                    for (let keys = Object.keys(message.additionalOptions), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.additionalOptions[keys[i]]).ldelim();
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.dependOnDependencyAssertions);
                if (message.hermetic != null && Object.hasOwnProperty.call(message, "hermetic"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.hermetic);
                if (message.assertions != null && Object.hasOwnProperty.call(message, "assertions"))
                    $root.dataform.ActionConfig.TableAssertionsConfig.encode(message.assertions, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ViewConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.ViewConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {dataform.ActionConfig.IViewConfig} message ViewConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ViewConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ViewConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.ViewConfig} ViewConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.ViewConfig(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            if (!(message.preOperations && message.preOperations.length))
                                message.preOperations = [];
                            message.preOperations.push(reader.string());
                            break;
                        }
                    case 9: {
                            if (!(message.postOperations && message.postOperations.length))
                                message.postOperations = [];
                            message.postOperations.push(reader.string());
                            break;
                        }
                    case 10: {
                            message.materialized = reader.bool();
                            break;
                        }
                    case 11: {
                            message.description = reader.string();
                            break;
                        }
                    case 12: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.dataform.ActionConfig.ColumnDescriptor.decode(reader, reader.uint32()));
                            break;
                        }
                    case 13: {
                            if (message.labels === $util.emptyObject)
                                message.labels = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.labels[key] = value;
                            break;
                        }
                    case 14: {
                            if (message.additionalOptions === $util.emptyObject)
                                message.additionalOptions = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.additionalOptions[key] = value;
                            break;
                        }
                    case 15: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    case 16: {
                            message.hermetic = reader.bool();
                            break;
                        }
                    case 17: {
                            message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ViewConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.ViewConfig} ViewConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ViewConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ViewConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ViewConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.preOperations != null && message.hasOwnProperty("preOperations")) {
                    if (!Array.isArray(message.preOperations))
                        return "preOperations: array expected";
                    for (let i = 0; i < message.preOperations.length; ++i)
                        if (!$util.isString(message.preOperations[i]))
                            return "preOperations: string[] expected";
                }
                if (message.postOperations != null && message.hasOwnProperty("postOperations")) {
                    if (!Array.isArray(message.postOperations))
                        return "postOperations: array expected";
                    for (let i = 0; i < message.postOperations.length; ++i)
                        if (!$util.isString(message.postOperations[i]))
                            return "postOperations: string[] expected";
                }
                if (message.materialized != null && message.hasOwnProperty("materialized"))
                    if (typeof message.materialized !== "boolean")
                        return "materialized: boolean expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.dataform.ActionConfig.ColumnDescriptor.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    let key = Object.keys(message.labels);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.additionalOptions != null && message.hasOwnProperty("additionalOptions")) {
                    if (!$util.isObject(message.additionalOptions))
                        return "additionalOptions: object expected";
                    let key = Object.keys(message.additionalOptions);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.additionalOptions[key[i]]))
                            return "additionalOptions: string{k:string} expected";
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    if (typeof message.hermetic !== "boolean")
                        return "hermetic: boolean expected";
                if (message.assertions != null && message.hasOwnProperty("assertions")) {
                    let error = $root.dataform.ActionConfig.TableAssertionsConfig.verify(message.assertions);
                    if (error)
                        return "assertions." + error;
                }
                return null;
            };

            /**
             * Creates a ViewConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.ViewConfig} ViewConfig
             */
            ViewConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.ViewConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.ViewConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.ViewConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.ViewConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.ViewConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.preOperations) {
                    if (!Array.isArray(object.preOperations))
                        throw TypeError(".dataform.ActionConfig.ViewConfig.preOperations: array expected");
                    message.preOperations = [];
                    for (let i = 0; i < object.preOperations.length; ++i)
                        message.preOperations[i] = String(object.preOperations[i]);
                }
                if (object.postOperations) {
                    if (!Array.isArray(object.postOperations))
                        throw TypeError(".dataform.ActionConfig.ViewConfig.postOperations: array expected");
                    message.postOperations = [];
                    for (let i = 0; i < object.postOperations.length; ++i)
                        message.postOperations[i] = String(object.postOperations[i]);
                }
                if (object.materialized != null)
                    message.materialized = Boolean(object.materialized);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".dataform.ActionConfig.ViewConfig.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.ViewConfig.columns: object expected");
                        message.columns[i] = $root.dataform.ActionConfig.ColumnDescriptor.fromObject(object.columns[i]);
                    }
                }
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".dataform.ActionConfig.ViewConfig.labels: object expected");
                    message.labels = {};
                    for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.additionalOptions) {
                    if (typeof object.additionalOptions !== "object")
                        throw TypeError(".dataform.ActionConfig.ViewConfig.additionalOptions: object expected");
                    message.additionalOptions = {};
                    for (let keys = Object.keys(object.additionalOptions), i = 0; i < keys.length; ++i)
                        message.additionalOptions[keys[i]] = String(object.additionalOptions[keys[i]]);
                }
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                if (object.hermetic != null)
                    message.hermetic = Boolean(object.hermetic);
                if (object.assertions != null) {
                    if (typeof object.assertions !== "object")
                        throw TypeError(".dataform.ActionConfig.ViewConfig.assertions: object expected");
                    message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.fromObject(object.assertions);
                }
                return message;
            };

            /**
             * Creates a plain object from a ViewConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {dataform.ActionConfig.ViewConfig} message ViewConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ViewConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                    object.preOperations = [];
                    object.postOperations = [];
                    object.columns = [];
                }
                if (options.objects || options.defaults) {
                    object.labels = {};
                    object.additionalOptions = {};
                }
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object.materialized = false;
                    object.description = "";
                    object.dependOnDependencyAssertions = false;
                    object.hermetic = false;
                    object.assertions = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.preOperations && message.preOperations.length) {
                    object.preOperations = [];
                    for (let j = 0; j < message.preOperations.length; ++j)
                        object.preOperations[j] = message.preOperations[j];
                }
                if (message.postOperations && message.postOperations.length) {
                    object.postOperations = [];
                    for (let j = 0; j < message.postOperations.length; ++j)
                        object.postOperations[j] = message.postOperations[j];
                }
                if (message.materialized != null && message.hasOwnProperty("materialized"))
                    object.materialized = message.materialized;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.dataform.ActionConfig.ColumnDescriptor.toObject(message.columns[j], options);
                }
                let keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.additionalOptions && (keys2 = Object.keys(message.additionalOptions)).length) {
                    object.additionalOptions = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.additionalOptions[keys2[j]] = message.additionalOptions[keys2[j]];
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    object.hermetic = message.hermetic;
                if (message.assertions != null && message.hasOwnProperty("assertions"))
                    object.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.toObject(message.assertions, options);
                return object;
            };

            /**
             * Converts this ViewConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.ViewConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ViewConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ViewConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.ViewConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ViewConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.ViewConfig";
            };

            return ViewConfig;
        })();

        /**
         * OnSchemaChange enum.
         * @name dataform.ActionConfig.OnSchemaChange
         * @enum {number}
         * @property {number} IGNORE=0 IGNORE value
         * @property {number} FAIL=1 FAIL value
         * @property {number} EXTEND=2 EXTEND value
         * @property {number} SYNCHRONIZE=3 SYNCHRONIZE value
         */
        ActionConfig.OnSchemaChange = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "IGNORE"] = 0;
            values[valuesById[1] = "FAIL"] = 1;
            values[valuesById[2] = "EXTEND"] = 2;
            values[valuesById[3] = "SYNCHRONIZE"] = 3;
            return values;
        })();

        ActionConfig.IncrementalTableConfig = (function() {

            /**
             * Properties of an IncrementalTableConfig.
             * @memberof dataform.ActionConfig
             * @interface IIncrementalTableConfig
             * @property {string|null} [name] IncrementalTableConfig name
             * @property {string|null} [dataset] IncrementalTableConfig dataset
             * @property {string|null} [project] IncrementalTableConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] IncrementalTableConfig dependencyTargets
             * @property {string|null} [filename] IncrementalTableConfig filename
             * @property {Array.<string>|null} [tags] IncrementalTableConfig tags
             * @property {boolean|null} [disabled] IncrementalTableConfig disabled
             * @property {Array.<string>|null} [preOperations] IncrementalTableConfig preOperations
             * @property {Array.<string>|null} [postOperations] IncrementalTableConfig postOperations
             * @property {boolean|null} ["protected"] IncrementalTableConfig protected
             * @property {Array.<string>|null} [uniqueKey] IncrementalTableConfig uniqueKey
             * @property {string|null} [description] IncrementalTableConfig description
             * @property {Array.<dataform.ActionConfig.IColumnDescriptor>|null} [columns] IncrementalTableConfig columns
             * @property {string|null} [partitionBy] IncrementalTableConfig partitionBy
             * @property {number|null} [partitionExpirationDays] IncrementalTableConfig partitionExpirationDays
             * @property {boolean|null} [requirePartitionFilter] IncrementalTableConfig requirePartitionFilter
             * @property {string|null} [updatePartitionFilter] IncrementalTableConfig updatePartitionFilter
             * @property {Array.<string>|null} [clusterBy] IncrementalTableConfig clusterBy
             * @property {Object.<string,string>|null} [labels] IncrementalTableConfig labels
             * @property {Object.<string,string>|null} [additionalOptions] IncrementalTableConfig additionalOptions
             * @property {boolean|null} [dependOnDependencyAssertions] IncrementalTableConfig dependOnDependencyAssertions
             * @property {dataform.ActionConfig.ITableAssertionsConfig|null} [assertions] IncrementalTableConfig assertions
             * @property {boolean|null} [hermetic] IncrementalTableConfig hermetic
             * @property {dataform.ActionConfig.OnSchemaChange|null} [onSchemaChange] IncrementalTableConfig onSchemaChange
             */

            /**
             * Constructs a new IncrementalTableConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents an IncrementalTableConfig.
             * @implements IIncrementalTableConfig
             * @constructor
             * @param {dataform.ActionConfig.IIncrementalTableConfig=} [properties] Properties to set
             */
            function IncrementalTableConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                this.preOperations = [];
                this.postOperations = [];
                this.uniqueKey = [];
                this.columns = [];
                this.clusterBy = [];
                this.labels = {};
                this.additionalOptions = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IncrementalTableConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.name = "";

            /**
             * IncrementalTableConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.dataset = "";

            /**
             * IncrementalTableConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.project = "";

            /**
             * IncrementalTableConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * IncrementalTableConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.filename = "";

            /**
             * IncrementalTableConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.tags = $util.emptyArray;

            /**
             * IncrementalTableConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.disabled = false;

            /**
             * IncrementalTableConfig preOperations.
             * @member {Array.<string>} preOperations
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.preOperations = $util.emptyArray;

            /**
             * IncrementalTableConfig postOperations.
             * @member {Array.<string>} postOperations
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.postOperations = $util.emptyArray;

            /**
             * IncrementalTableConfig protected.
             * @member {boolean} protected
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype["protected"] = false;

            /**
             * IncrementalTableConfig uniqueKey.
             * @member {Array.<string>} uniqueKey
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.uniqueKey = $util.emptyArray;

            /**
             * IncrementalTableConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.description = "";

            /**
             * IncrementalTableConfig columns.
             * @member {Array.<dataform.ActionConfig.IColumnDescriptor>} columns
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.columns = $util.emptyArray;

            /**
             * IncrementalTableConfig partitionBy.
             * @member {string} partitionBy
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.partitionBy = "";

            /**
             * IncrementalTableConfig partitionExpirationDays.
             * @member {number} partitionExpirationDays
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.partitionExpirationDays = 0;

            /**
             * IncrementalTableConfig requirePartitionFilter.
             * @member {boolean} requirePartitionFilter
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.requirePartitionFilter = false;

            /**
             * IncrementalTableConfig updatePartitionFilter.
             * @member {string} updatePartitionFilter
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.updatePartitionFilter = "";

            /**
             * IncrementalTableConfig clusterBy.
             * @member {Array.<string>} clusterBy
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.clusterBy = $util.emptyArray;

            /**
             * IncrementalTableConfig labels.
             * @member {Object.<string,string>} labels
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.labels = $util.emptyObject;

            /**
             * IncrementalTableConfig additionalOptions.
             * @member {Object.<string,string>} additionalOptions
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.additionalOptions = $util.emptyObject;

            /**
             * IncrementalTableConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * IncrementalTableConfig assertions.
             * @member {dataform.ActionConfig.ITableAssertionsConfig|null|undefined} assertions
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.assertions = null;

            /**
             * IncrementalTableConfig hermetic.
             * @member {boolean} hermetic
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.hermetic = false;

            /**
             * IncrementalTableConfig onSchemaChange.
             * @member {dataform.ActionConfig.OnSchemaChange} onSchemaChange
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             */
            IncrementalTableConfig.prototype.onSchemaChange = 0;

            /**
             * Creates a new IncrementalTableConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {dataform.ActionConfig.IIncrementalTableConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.IncrementalTableConfig} IncrementalTableConfig instance
             */
            IncrementalTableConfig.create = function create(properties) {
                return new IncrementalTableConfig(properties);
            };

            /**
             * Encodes the specified IncrementalTableConfig message. Does not implicitly {@link dataform.ActionConfig.IncrementalTableConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {dataform.ActionConfig.IIncrementalTableConfig} message IncrementalTableConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IncrementalTableConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.preOperations != null && message.preOperations.length)
                    for (let i = 0; i < message.preOperations.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.preOperations[i]);
                if (message.postOperations != null && message.postOperations.length)
                    for (let i = 0; i < message.postOperations.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.postOperations[i]);
                if (message["protected"] != null && Object.hasOwnProperty.call(message, "protected"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message["protected"]);
                if (message.uniqueKey != null && message.uniqueKey.length)
                    for (let i = 0; i < message.uniqueKey.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.uniqueKey[i]);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.description);
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.dataform.ActionConfig.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.partitionBy != null && Object.hasOwnProperty.call(message, "partitionBy"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.partitionBy);
                if (message.partitionExpirationDays != null && Object.hasOwnProperty.call(message, "partitionExpirationDays"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.partitionExpirationDays);
                if (message.requirePartitionFilter != null && Object.hasOwnProperty.call(message, "requirePartitionFilter"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.requirePartitionFilter);
                if (message.updatePartitionFilter != null && Object.hasOwnProperty.call(message, "updatePartitionFilter"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.updatePartitionFilter);
                if (message.clusterBy != null && message.clusterBy.length)
                    for (let i = 0; i < message.clusterBy.length; ++i)
                        writer.uint32(/* id 18, wireType 2 =*/146).string(message.clusterBy[i]);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 19, wireType 2 =*/154).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.additionalOptions != null && Object.hasOwnProperty.call(message, "additionalOptions"))
                    for (let keys = Object.keys(message.additionalOptions), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 20, wireType 2 =*/162).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.additionalOptions[keys[i]]).ldelim();
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 21, wireType 0 =*/168).bool(message.dependOnDependencyAssertions);
                if (message.assertions != null && Object.hasOwnProperty.call(message, "assertions"))
                    $root.dataform.ActionConfig.TableAssertionsConfig.encode(message.assertions, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.hermetic != null && Object.hasOwnProperty.call(message, "hermetic"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.hermetic);
                if (message.onSchemaChange != null && Object.hasOwnProperty.call(message, "onSchemaChange"))
                    writer.uint32(/* id 24, wireType 0 =*/192).int32(message.onSchemaChange);
                return writer;
            };

            /**
             * Encodes the specified IncrementalTableConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.IncrementalTableConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {dataform.ActionConfig.IIncrementalTableConfig} message IncrementalTableConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IncrementalTableConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IncrementalTableConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.IncrementalTableConfig} IncrementalTableConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IncrementalTableConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.IncrementalTableConfig(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            if (!(message.preOperations && message.preOperations.length))
                                message.preOperations = [];
                            message.preOperations.push(reader.string());
                            break;
                        }
                    case 9: {
                            if (!(message.postOperations && message.postOperations.length))
                                message.postOperations = [];
                            message.postOperations.push(reader.string());
                            break;
                        }
                    case 10: {
                            message["protected"] = reader.bool();
                            break;
                        }
                    case 11: {
                            if (!(message.uniqueKey && message.uniqueKey.length))
                                message.uniqueKey = [];
                            message.uniqueKey.push(reader.string());
                            break;
                        }
                    case 12: {
                            message.description = reader.string();
                            break;
                        }
                    case 13: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.dataform.ActionConfig.ColumnDescriptor.decode(reader, reader.uint32()));
                            break;
                        }
                    case 14: {
                            message.partitionBy = reader.string();
                            break;
                        }
                    case 15: {
                            message.partitionExpirationDays = reader.int32();
                            break;
                        }
                    case 16: {
                            message.requirePartitionFilter = reader.bool();
                            break;
                        }
                    case 17: {
                            message.updatePartitionFilter = reader.string();
                            break;
                        }
                    case 18: {
                            if (!(message.clusterBy && message.clusterBy.length))
                                message.clusterBy = [];
                            message.clusterBy.push(reader.string());
                            break;
                        }
                    case 19: {
                            if (message.labels === $util.emptyObject)
                                message.labels = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.labels[key] = value;
                            break;
                        }
                    case 20: {
                            if (message.additionalOptions === $util.emptyObject)
                                message.additionalOptions = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.additionalOptions[key] = value;
                            break;
                        }
                    case 21: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    case 22: {
                            message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.hermetic = reader.bool();
                            break;
                        }
                    case 24: {
                            message.onSchemaChange = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IncrementalTableConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.IncrementalTableConfig} IncrementalTableConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IncrementalTableConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IncrementalTableConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IncrementalTableConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.preOperations != null && message.hasOwnProperty("preOperations")) {
                    if (!Array.isArray(message.preOperations))
                        return "preOperations: array expected";
                    for (let i = 0; i < message.preOperations.length; ++i)
                        if (!$util.isString(message.preOperations[i]))
                            return "preOperations: string[] expected";
                }
                if (message.postOperations != null && message.hasOwnProperty("postOperations")) {
                    if (!Array.isArray(message.postOperations))
                        return "postOperations: array expected";
                    for (let i = 0; i < message.postOperations.length; ++i)
                        if (!$util.isString(message.postOperations[i]))
                            return "postOperations: string[] expected";
                }
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    if (typeof message["protected"] !== "boolean")
                        return "protected: boolean expected";
                if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                    if (!Array.isArray(message.uniqueKey))
                        return "uniqueKey: array expected";
                    for (let i = 0; i < message.uniqueKey.length; ++i)
                        if (!$util.isString(message.uniqueKey[i]))
                            return "uniqueKey: string[] expected";
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.dataform.ActionConfig.ColumnDescriptor.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                    if (!$util.isString(message.partitionBy))
                        return "partitionBy: string expected";
                if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                    if (!$util.isInteger(message.partitionExpirationDays))
                        return "partitionExpirationDays: integer expected";
                if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                    if (typeof message.requirePartitionFilter !== "boolean")
                        return "requirePartitionFilter: boolean expected";
                if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                    if (!$util.isString(message.updatePartitionFilter))
                        return "updatePartitionFilter: string expected";
                if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                    if (!Array.isArray(message.clusterBy))
                        return "clusterBy: array expected";
                    for (let i = 0; i < message.clusterBy.length; ++i)
                        if (!$util.isString(message.clusterBy[i]))
                            return "clusterBy: string[] expected";
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    let key = Object.keys(message.labels);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.additionalOptions != null && message.hasOwnProperty("additionalOptions")) {
                    if (!$util.isObject(message.additionalOptions))
                        return "additionalOptions: object expected";
                    let key = Object.keys(message.additionalOptions);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.additionalOptions[key[i]]))
                            return "additionalOptions: string{k:string} expected";
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                if (message.assertions != null && message.hasOwnProperty("assertions")) {
                    let error = $root.dataform.ActionConfig.TableAssertionsConfig.verify(message.assertions);
                    if (error)
                        return "assertions." + error;
                }
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    if (typeof message.hermetic !== "boolean")
                        return "hermetic: boolean expected";
                if (message.onSchemaChange != null && message.hasOwnProperty("onSchemaChange"))
                    switch (message.onSchemaChange) {
                    default:
                        return "onSchemaChange: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an IncrementalTableConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.IncrementalTableConfig} IncrementalTableConfig
             */
            IncrementalTableConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.IncrementalTableConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.IncrementalTableConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.preOperations) {
                    if (!Array.isArray(object.preOperations))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.preOperations: array expected");
                    message.preOperations = [];
                    for (let i = 0; i < object.preOperations.length; ++i)
                        message.preOperations[i] = String(object.preOperations[i]);
                }
                if (object.postOperations) {
                    if (!Array.isArray(object.postOperations))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.postOperations: array expected");
                    message.postOperations = [];
                    for (let i = 0; i < object.postOperations.length; ++i)
                        message.postOperations[i] = String(object.postOperations[i]);
                }
                if (object["protected"] != null)
                    message["protected"] = Boolean(object["protected"]);
                if (object.uniqueKey) {
                    if (!Array.isArray(object.uniqueKey))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.uniqueKey: array expected");
                    message.uniqueKey = [];
                    for (let i = 0; i < object.uniqueKey.length; ++i)
                        message.uniqueKey[i] = String(object.uniqueKey[i]);
                }
                if (object.description != null)
                    message.description = String(object.description);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.columns: object expected");
                        message.columns[i] = $root.dataform.ActionConfig.ColumnDescriptor.fromObject(object.columns[i]);
                    }
                }
                if (object.partitionBy != null)
                    message.partitionBy = String(object.partitionBy);
                if (object.partitionExpirationDays != null)
                    message.partitionExpirationDays = object.partitionExpirationDays | 0;
                if (object.requirePartitionFilter != null)
                    message.requirePartitionFilter = Boolean(object.requirePartitionFilter);
                if (object.updatePartitionFilter != null)
                    message.updatePartitionFilter = String(object.updatePartitionFilter);
                if (object.clusterBy) {
                    if (!Array.isArray(object.clusterBy))
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.clusterBy: array expected");
                    message.clusterBy = [];
                    for (let i = 0; i < object.clusterBy.length; ++i)
                        message.clusterBy[i] = String(object.clusterBy[i]);
                }
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.labels: object expected");
                    message.labels = {};
                    for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.additionalOptions) {
                    if (typeof object.additionalOptions !== "object")
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.additionalOptions: object expected");
                    message.additionalOptions = {};
                    for (let keys = Object.keys(object.additionalOptions), i = 0; i < keys.length; ++i)
                        message.additionalOptions[keys[i]] = String(object.additionalOptions[keys[i]]);
                }
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                if (object.assertions != null) {
                    if (typeof object.assertions !== "object")
                        throw TypeError(".dataform.ActionConfig.IncrementalTableConfig.assertions: object expected");
                    message.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.fromObject(object.assertions);
                }
                if (object.hermetic != null)
                    message.hermetic = Boolean(object.hermetic);
                switch (object.onSchemaChange) {
                default:
                    if (typeof object.onSchemaChange === "number") {
                        message.onSchemaChange = object.onSchemaChange;
                        break;
                    }
                    break;
                case "IGNORE":
                case 0:
                    message.onSchemaChange = 0;
                    break;
                case "FAIL":
                case 1:
                    message.onSchemaChange = 1;
                    break;
                case "EXTEND":
                case 2:
                    message.onSchemaChange = 2;
                    break;
                case "SYNCHRONIZE":
                case 3:
                    message.onSchemaChange = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an IncrementalTableConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {dataform.ActionConfig.IncrementalTableConfig} message IncrementalTableConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IncrementalTableConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                    object.preOperations = [];
                    object.postOperations = [];
                    object.uniqueKey = [];
                    object.columns = [];
                    object.clusterBy = [];
                }
                if (options.objects || options.defaults) {
                    object.labels = {};
                    object.additionalOptions = {};
                }
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object["protected"] = false;
                    object.description = "";
                    object.partitionBy = "";
                    object.partitionExpirationDays = 0;
                    object.requirePartitionFilter = false;
                    object.updatePartitionFilter = "";
                    object.dependOnDependencyAssertions = false;
                    object.assertions = null;
                    object.hermetic = false;
                    object.onSchemaChange = options.enums === String ? "IGNORE" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.preOperations && message.preOperations.length) {
                    object.preOperations = [];
                    for (let j = 0; j < message.preOperations.length; ++j)
                        object.preOperations[j] = message.preOperations[j];
                }
                if (message.postOperations && message.postOperations.length) {
                    object.postOperations = [];
                    for (let j = 0; j < message.postOperations.length; ++j)
                        object.postOperations[j] = message.postOperations[j];
                }
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    object["protected"] = message["protected"];
                if (message.uniqueKey && message.uniqueKey.length) {
                    object.uniqueKey = [];
                    for (let j = 0; j < message.uniqueKey.length; ++j)
                        object.uniqueKey[j] = message.uniqueKey[j];
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.dataform.ActionConfig.ColumnDescriptor.toObject(message.columns[j], options);
                }
                if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                    object.partitionBy = message.partitionBy;
                if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                    object.partitionExpirationDays = message.partitionExpirationDays;
                if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                    object.requirePartitionFilter = message.requirePartitionFilter;
                if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                    object.updatePartitionFilter = message.updatePartitionFilter;
                if (message.clusterBy && message.clusterBy.length) {
                    object.clusterBy = [];
                    for (let j = 0; j < message.clusterBy.length; ++j)
                        object.clusterBy[j] = message.clusterBy[j];
                }
                let keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.additionalOptions && (keys2 = Object.keys(message.additionalOptions)).length) {
                    object.additionalOptions = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.additionalOptions[keys2[j]] = message.additionalOptions[keys2[j]];
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                if (message.assertions != null && message.hasOwnProperty("assertions"))
                    object.assertions = $root.dataform.ActionConfig.TableAssertionsConfig.toObject(message.assertions, options);
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    object.hermetic = message.hermetic;
                if (message.onSchemaChange != null && message.hasOwnProperty("onSchemaChange"))
                    object.onSchemaChange = options.enums === String ? $root.dataform.ActionConfig.OnSchemaChange[message.onSchemaChange] === undefined ? message.onSchemaChange : $root.dataform.ActionConfig.OnSchemaChange[message.onSchemaChange] : message.onSchemaChange;
                return object;
            };

            /**
             * Converts this IncrementalTableConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IncrementalTableConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IncrementalTableConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.IncrementalTableConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IncrementalTableConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.IncrementalTableConfig";
            };

            return IncrementalTableConfig;
        })();

        ActionConfig.AssertionConfig = (function() {

            /**
             * Properties of an AssertionConfig.
             * @memberof dataform.ActionConfig
             * @interface IAssertionConfig
             * @property {string|null} [name] AssertionConfig name
             * @property {string|null} [dataset] AssertionConfig dataset
             * @property {string|null} [project] AssertionConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] AssertionConfig dependencyTargets
             * @property {string|null} [filename] AssertionConfig filename
             * @property {Array.<string>|null} [tags] AssertionConfig tags
             * @property {boolean|null} [disabled] AssertionConfig disabled
             * @property {string|null} [description] AssertionConfig description
             * @property {boolean|null} [hermetic] AssertionConfig hermetic
             * @property {boolean|null} [dependOnDependencyAssertions] AssertionConfig dependOnDependencyAssertions
             */

            /**
             * Constructs a new AssertionConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents an AssertionConfig.
             * @implements IAssertionConfig
             * @constructor
             * @param {dataform.ActionConfig.IAssertionConfig=} [properties] Properties to set
             */
            function AssertionConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AssertionConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.name = "";

            /**
             * AssertionConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.dataset = "";

            /**
             * AssertionConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.project = "";

            /**
             * AssertionConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * AssertionConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.filename = "";

            /**
             * AssertionConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.tags = $util.emptyArray;

            /**
             * AssertionConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.disabled = false;

            /**
             * AssertionConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.description = "";

            /**
             * AssertionConfig hermetic.
             * @member {boolean} hermetic
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.hermetic = false;

            /**
             * AssertionConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             */
            AssertionConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * Creates a new AssertionConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {dataform.ActionConfig.IAssertionConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.AssertionConfig} AssertionConfig instance
             */
            AssertionConfig.create = function create(properties) {
                return new AssertionConfig(properties);
            };

            /**
             * Encodes the specified AssertionConfig message. Does not implicitly {@link dataform.ActionConfig.AssertionConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {dataform.ActionConfig.IAssertionConfig} message AssertionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AssertionConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
                if (message.hermetic != null && Object.hasOwnProperty.call(message, "hermetic"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hermetic);
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.dependOnDependencyAssertions);
                return writer;
            };

            /**
             * Encodes the specified AssertionConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.AssertionConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {dataform.ActionConfig.IAssertionConfig} message AssertionConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AssertionConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AssertionConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.AssertionConfig} AssertionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AssertionConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.AssertionConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.description = reader.string();
                            break;
                        }
                    case 9: {
                            message.hermetic = reader.bool();
                            break;
                        }
                    case 10: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AssertionConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.AssertionConfig} AssertionConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AssertionConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AssertionConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AssertionConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    if (typeof message.hermetic !== "boolean")
                        return "hermetic: boolean expected";
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                return null;
            };

            /**
             * Creates an AssertionConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.AssertionConfig} AssertionConfig
             */
            AssertionConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.AssertionConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.AssertionConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.AssertionConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.AssertionConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.AssertionConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.hermetic != null)
                    message.hermetic = Boolean(object.hermetic);
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                return message;
            };

            /**
             * Creates a plain object from an AssertionConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {dataform.ActionConfig.AssertionConfig} message AssertionConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AssertionConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object.description = "";
                    object.hermetic = false;
                    object.dependOnDependencyAssertions = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    object.hermetic = message.hermetic;
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                return object;
            };

            /**
             * Converts this AssertionConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.AssertionConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AssertionConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AssertionConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.AssertionConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AssertionConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.AssertionConfig";
            };

            return AssertionConfig;
        })();

        ActionConfig.OperationConfig = (function() {

            /**
             * Properties of an OperationConfig.
             * @memberof dataform.ActionConfig
             * @interface IOperationConfig
             * @property {string|null} [name] OperationConfig name
             * @property {string|null} [dataset] OperationConfig dataset
             * @property {string|null} [project] OperationConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] OperationConfig dependencyTargets
             * @property {string|null} [filename] OperationConfig filename
             * @property {Array.<string>|null} [tags] OperationConfig tags
             * @property {boolean|null} [disabled] OperationConfig disabled
             * @property {boolean|null} [hasOutput] OperationConfig hasOutput
             * @property {string|null} [description] OperationConfig description
             * @property {Array.<dataform.ActionConfig.IColumnDescriptor>|null} [columns] OperationConfig columns
             * @property {boolean|null} [dependOnDependencyAssertions] OperationConfig dependOnDependencyAssertions
             * @property {boolean|null} [hermetic] OperationConfig hermetic
             */

            /**
             * Constructs a new OperationConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents an OperationConfig.
             * @implements IOperationConfig
             * @constructor
             * @param {dataform.ActionConfig.IOperationConfig=} [properties] Properties to set
             */
            function OperationConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                this.columns = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.name = "";

            /**
             * OperationConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.dataset = "";

            /**
             * OperationConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.project = "";

            /**
             * OperationConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * OperationConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.filename = "";

            /**
             * OperationConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.tags = $util.emptyArray;

            /**
             * OperationConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.disabled = false;

            /**
             * OperationConfig hasOutput.
             * @member {boolean} hasOutput
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.hasOutput = false;

            /**
             * OperationConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.description = "";

            /**
             * OperationConfig columns.
             * @member {Array.<dataform.ActionConfig.IColumnDescriptor>} columns
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.columns = $util.emptyArray;

            /**
             * OperationConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * OperationConfig hermetic.
             * @member {boolean} hermetic
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             */
            OperationConfig.prototype.hermetic = false;

            /**
             * Creates a new OperationConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {dataform.ActionConfig.IOperationConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.OperationConfig} OperationConfig instance
             */
            OperationConfig.create = function create(properties) {
                return new OperationConfig(properties);
            };

            /**
             * Encodes the specified OperationConfig message. Does not implicitly {@link dataform.ActionConfig.OperationConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {dataform.ActionConfig.IOperationConfig} message OperationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.hasOutput != null && Object.hasOwnProperty.call(message, "hasOutput"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasOutput);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.description);
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.dataform.ActionConfig.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.dependOnDependencyAssertions);
                if (message.hermetic != null && Object.hasOwnProperty.call(message, "hermetic"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.hermetic);
                return writer;
            };

            /**
             * Encodes the specified OperationConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.OperationConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {dataform.ActionConfig.IOperationConfig} message OperationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.OperationConfig} OperationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.OperationConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.hasOutput = reader.bool();
                            break;
                        }
                    case 9: {
                            message.description = reader.string();
                            break;
                        }
                    case 10: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.dataform.ActionConfig.ColumnDescriptor.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    case 12: {
                            message.hermetic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.OperationConfig} OperationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                    if (typeof message.hasOutput !== "boolean")
                        return "hasOutput: boolean expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.dataform.ActionConfig.ColumnDescriptor.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    if (typeof message.hermetic !== "boolean")
                        return "hermetic: boolean expected";
                return null;
            };

            /**
             * Creates an OperationConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.OperationConfig} OperationConfig
             */
            OperationConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.OperationConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.OperationConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.OperationConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.OperationConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.OperationConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.hasOutput != null)
                    message.hasOutput = Boolean(object.hasOutput);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".dataform.ActionConfig.OperationConfig.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.OperationConfig.columns: object expected");
                        message.columns[i] = $root.dataform.ActionConfig.ColumnDescriptor.fromObject(object.columns[i]);
                    }
                }
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                if (object.hermetic != null)
                    message.hermetic = Boolean(object.hermetic);
                return message;
            };

            /**
             * Creates a plain object from an OperationConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {dataform.ActionConfig.OperationConfig} message OperationConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                    object.columns = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object.hasOutput = false;
                    object.description = "";
                    object.dependOnDependencyAssertions = false;
                    object.hermetic = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                    object.hasOutput = message.hasOutput;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.dataform.ActionConfig.ColumnDescriptor.toObject(message.columns[j], options);
                }
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                if (message.hermetic != null && message.hasOwnProperty("hermetic"))
                    object.hermetic = message.hermetic;
                return object;
            };

            /**
             * Converts this OperationConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.OperationConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OperationConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.OperationConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OperationConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.OperationConfig";
            };

            return OperationConfig;
        })();

        ActionConfig.DeclarationConfig = (function() {

            /**
             * Properties of a DeclarationConfig.
             * @memberof dataform.ActionConfig
             * @interface IDeclarationConfig
             * @property {string|null} [name] DeclarationConfig name
             * @property {string|null} [dataset] DeclarationConfig dataset
             * @property {string|null} [project] DeclarationConfig project
             * @property {string|null} [description] DeclarationConfig description
             * @property {Array.<dataform.ActionConfig.IColumnDescriptor>|null} [columns] DeclarationConfig columns
             */

            /**
             * Constructs a new DeclarationConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a DeclarationConfig.
             * @implements IDeclarationConfig
             * @constructor
             * @param {dataform.ActionConfig.IDeclarationConfig=} [properties] Properties to set
             */
            function DeclarationConfig(properties) {
                this.columns = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeclarationConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             */
            DeclarationConfig.prototype.name = "";

            /**
             * DeclarationConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             */
            DeclarationConfig.prototype.dataset = "";

            /**
             * DeclarationConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             */
            DeclarationConfig.prototype.project = "";

            /**
             * DeclarationConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             */
            DeclarationConfig.prototype.description = "";

            /**
             * DeclarationConfig columns.
             * @member {Array.<dataform.ActionConfig.IColumnDescriptor>} columns
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             */
            DeclarationConfig.prototype.columns = $util.emptyArray;

            /**
             * Creates a new DeclarationConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {dataform.ActionConfig.IDeclarationConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.DeclarationConfig} DeclarationConfig instance
             */
            DeclarationConfig.create = function create(properties) {
                return new DeclarationConfig(properties);
            };

            /**
             * Encodes the specified DeclarationConfig message. Does not implicitly {@link dataform.ActionConfig.DeclarationConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {dataform.ActionConfig.IDeclarationConfig} message DeclarationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeclarationConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                if (message.columns != null && message.columns.length)
                    for (let i = 0; i < message.columns.length; ++i)
                        $root.dataform.ActionConfig.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeclarationConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.DeclarationConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {dataform.ActionConfig.IDeclarationConfig} message DeclarationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeclarationConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeclarationConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.DeclarationConfig} DeclarationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeclarationConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.DeclarationConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    case 5: {
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.dataform.ActionConfig.ColumnDescriptor.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeclarationConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.DeclarationConfig} DeclarationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeclarationConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeclarationConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeclarationConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (let i = 0; i < message.columns.length; ++i) {
                        let error = $root.dataform.ActionConfig.ColumnDescriptor.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DeclarationConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.DeclarationConfig} DeclarationConfig
             */
            DeclarationConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.DeclarationConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.DeclarationConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".dataform.ActionConfig.DeclarationConfig.columns: array expected");
                    message.columns = [];
                    for (let i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.DeclarationConfig.columns: object expected");
                        message.columns[i] = $root.dataform.ActionConfig.ColumnDescriptor.fromObject(object.columns[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DeclarationConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {dataform.ActionConfig.DeclarationConfig} message DeclarationConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeclarationConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.columns = [];
                if (options.defaults) {
                    object.name = "";
                    object.dataset = "";
                    object.project = "";
                    object.description = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (let j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.dataform.ActionConfig.ColumnDescriptor.toObject(message.columns[j], options);
                }
                return object;
            };

            /**
             * Converts this DeclarationConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeclarationConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeclarationConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.DeclarationConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeclarationConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.DeclarationConfig";
            };

            return DeclarationConfig;
        })();

        ActionConfig.NotebookConfig = (function() {

            /**
             * Properties of a NotebookConfig.
             * @memberof dataform.ActionConfig
             * @interface INotebookConfig
             * @property {string|null} [name] NotebookConfig name
             * @property {string|null} [location] NotebookConfig location
             * @property {string|null} [project] NotebookConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] NotebookConfig dependencyTargets
             * @property {string|null} [filename] NotebookConfig filename
             * @property {Array.<string>|null} [tags] NotebookConfig tags
             * @property {boolean|null} [disabled] NotebookConfig disabled
             * @property {string|null} [description] NotebookConfig description
             * @property {boolean|null} [dependOnDependencyAssertions] NotebookConfig dependOnDependencyAssertions
             */

            /**
             * Constructs a new NotebookConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a NotebookConfig.
             * @implements INotebookConfig
             * @constructor
             * @param {dataform.ActionConfig.INotebookConfig=} [properties] Properties to set
             */
            function NotebookConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotebookConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.name = "";

            /**
             * NotebookConfig location.
             * @member {string} location
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.location = "";

            /**
             * NotebookConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.project = "";

            /**
             * NotebookConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * NotebookConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.filename = "";

            /**
             * NotebookConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.tags = $util.emptyArray;

            /**
             * NotebookConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.disabled = false;

            /**
             * NotebookConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.description = "";

            /**
             * NotebookConfig dependOnDependencyAssertions.
             * @member {boolean} dependOnDependencyAssertions
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             */
            NotebookConfig.prototype.dependOnDependencyAssertions = false;

            /**
             * Creates a new NotebookConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {dataform.ActionConfig.INotebookConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.NotebookConfig} NotebookConfig instance
             */
            NotebookConfig.create = function create(properties) {
                return new NotebookConfig(properties);
            };

            /**
             * Encodes the specified NotebookConfig message. Does not implicitly {@link dataform.ActionConfig.NotebookConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {dataform.ActionConfig.INotebookConfig} message NotebookConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotebookConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.location);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
                if (message.dependOnDependencyAssertions != null && Object.hasOwnProperty.call(message, "dependOnDependencyAssertions"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.dependOnDependencyAssertions);
                return writer;
            };

            /**
             * Encodes the specified NotebookConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.NotebookConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {dataform.ActionConfig.INotebookConfig} message NotebookConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotebookConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotebookConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.NotebookConfig} NotebookConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotebookConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.NotebookConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.location = reader.string();
                            break;
                        }
                    case 3: {
                            message.project = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.filename = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.description = reader.string();
                            break;
                        }
                    case 9: {
                            message.dependOnDependencyAssertions = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotebookConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.NotebookConfig} NotebookConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotebookConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotebookConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotebookConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    if (typeof message.dependOnDependencyAssertions !== "boolean")
                        return "dependOnDependencyAssertions: boolean expected";
                return null;
            };

            /**
             * Creates a NotebookConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.NotebookConfig} NotebookConfig
             */
            NotebookConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.NotebookConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.NotebookConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.location != null)
                    message.location = String(object.location);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.NotebookConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.NotebookConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.NotebookConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.dependOnDependencyAssertions != null)
                    message.dependOnDependencyAssertions = Boolean(object.dependOnDependencyAssertions);
                return message;
            };

            /**
             * Creates a plain object from a NotebookConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {dataform.ActionConfig.NotebookConfig} message NotebookConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotebookConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.location = "";
                    object.project = "";
                    object.filename = "";
                    object.disabled = false;
                    object.description = "";
                    object.dependOnDependencyAssertions = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.dependOnDependencyAssertions != null && message.hasOwnProperty("dependOnDependencyAssertions"))
                    object.dependOnDependencyAssertions = message.dependOnDependencyAssertions;
                return object;
            };

            /**
             * Converts this NotebookConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.NotebookConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotebookConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NotebookConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.NotebookConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NotebookConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.NotebookConfig";
            };

            return NotebookConfig;
        })();

        ActionConfig.DataPreparationConfig = (function() {

            /**
             * Properties of a DataPreparationConfig.
             * @memberof dataform.ActionConfig
             * @interface IDataPreparationConfig
             * @property {string|null} [name] DataPreparationConfig name
             * @property {string|null} [dataset] DataPreparationConfig dataset
             * @property {string|null} [project] DataPreparationConfig project
             * @property {Array.<dataform.ActionConfig.ITarget>|null} [dependencyTargets] DataPreparationConfig dependencyTargets
             * @property {string|null} [filename] DataPreparationConfig filename
             * @property {Array.<string>|null} [tags] DataPreparationConfig tags
             * @property {boolean|null} [disabled] DataPreparationConfig disabled
             * @property {string|null} [description] DataPreparationConfig description
             * @property {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig|null} [errorTable] DataPreparationConfig errorTable
             * @property {dataform.ActionConfig.ILoadModeConfig|null} [loadMode] DataPreparationConfig loadMode
             */

            /**
             * Constructs a new DataPreparationConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a DataPreparationConfig.
             * @implements IDataPreparationConfig
             * @constructor
             * @param {dataform.ActionConfig.IDataPreparationConfig=} [properties] Properties to set
             */
            function DataPreparationConfig(properties) {
                this.dependencyTargets = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DataPreparationConfig name.
             * @member {string} name
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.name = "";

            /**
             * DataPreparationConfig dataset.
             * @member {string} dataset
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.dataset = "";

            /**
             * DataPreparationConfig project.
             * @member {string} project
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.project = "";

            /**
             * DataPreparationConfig dependencyTargets.
             * @member {Array.<dataform.ActionConfig.ITarget>} dependencyTargets
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.dependencyTargets = $util.emptyArray;

            /**
             * DataPreparationConfig filename.
             * @member {string} filename
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.filename = "";

            /**
             * DataPreparationConfig tags.
             * @member {Array.<string>} tags
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.tags = $util.emptyArray;

            /**
             * DataPreparationConfig disabled.
             * @member {boolean} disabled
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.disabled = false;

            /**
             * DataPreparationConfig description.
             * @member {string} description
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.description = "";

            /**
             * DataPreparationConfig errorTable.
             * @member {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig|null|undefined} errorTable
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.errorTable = null;

            /**
             * DataPreparationConfig loadMode.
             * @member {dataform.ActionConfig.ILoadModeConfig|null|undefined} loadMode
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             */
            DataPreparationConfig.prototype.loadMode = null;

            /**
             * Creates a new DataPreparationConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {dataform.ActionConfig.IDataPreparationConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.DataPreparationConfig} DataPreparationConfig instance
             */
            DataPreparationConfig.create = function create(properties) {
                return new DataPreparationConfig(properties);
            };

            /**
             * Encodes the specified DataPreparationConfig message. Does not implicitly {@link dataform.ActionConfig.DataPreparationConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {dataform.ActionConfig.IDataPreparationConfig} message DataPreparationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataPreparationConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dependencyTargets != null && message.dependencyTargets.length)
                    for (let i = 0; i < message.dependencyTargets.length; ++i)
                        $root.dataform.ActionConfig.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filename);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.disabled);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
                if (message.errorTable != null && Object.hasOwnProperty.call(message, "errorTable"))
                    $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.encode(message.errorTable, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.loadMode != null && Object.hasOwnProperty.call(message, "loadMode"))
                    $root.dataform.ActionConfig.LoadModeConfig.encode(message.loadMode, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.dataset);
                if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.project);
                return writer;
            };

            /**
             * Encodes the specified DataPreparationConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.DataPreparationConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {dataform.ActionConfig.IDataPreparationConfig} message DataPreparationConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DataPreparationConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DataPreparationConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.DataPreparationConfig} DataPreparationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataPreparationConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.DataPreparationConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 13: {
                            message.dataset = reader.string();
                            break;
                        }
                    case 14: {
                            message.project = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.dependencyTargets && message.dependencyTargets.length))
                                message.dependencyTargets = [];
                            message.dependencyTargets.push($root.dataform.ActionConfig.Target.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.filename = reader.string();
                            break;
                        }
                    case 4: {
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        }
                    case 7: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 8: {
                            message.description = reader.string();
                            break;
                        }
                    case 11: {
                            message.errorTable = $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.loadMode = $root.dataform.ActionConfig.LoadModeConfig.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DataPreparationConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.DataPreparationConfig} DataPreparationConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DataPreparationConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DataPreparationConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DataPreparationConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    if (!$util.isString(message.dataset))
                        return "dataset: string expected";
                if (message.project != null && message.hasOwnProperty("project"))
                    if (!$util.isString(message.project))
                        return "project: string expected";
                if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                    if (!Array.isArray(message.dependencyTargets))
                        return "dependencyTargets: array expected";
                    for (let i = 0; i < message.dependencyTargets.length; ++i) {
                        let error = $root.dataform.ActionConfig.Target.verify(message.dependencyTargets[i]);
                        if (error)
                            return "dependencyTargets." + error;
                    }
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    if (!$util.isString(message.filename))
                        return "filename: string expected";
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.errorTable != null && message.hasOwnProperty("errorTable")) {
                    let error = $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.verify(message.errorTable);
                    if (error)
                        return "errorTable." + error;
                }
                if (message.loadMode != null && message.hasOwnProperty("loadMode")) {
                    let error = $root.dataform.ActionConfig.LoadModeConfig.verify(message.loadMode);
                    if (error)
                        return "loadMode." + error;
                }
                return null;
            };

            /**
             * Creates a DataPreparationConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.DataPreparationConfig} DataPreparationConfig
             */
            DataPreparationConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.DataPreparationConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.DataPreparationConfig();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dataset != null)
                    message.dataset = String(object.dataset);
                if (object.project != null)
                    message.project = String(object.project);
                if (object.dependencyTargets) {
                    if (!Array.isArray(object.dependencyTargets))
                        throw TypeError(".dataform.ActionConfig.DataPreparationConfig.dependencyTargets: array expected");
                    message.dependencyTargets = [];
                    for (let i = 0; i < object.dependencyTargets.length; ++i) {
                        if (typeof object.dependencyTargets[i] !== "object")
                            throw TypeError(".dataform.ActionConfig.DataPreparationConfig.dependencyTargets: object expected");
                        message.dependencyTargets[i] = $root.dataform.ActionConfig.Target.fromObject(object.dependencyTargets[i]);
                    }
                }
                if (object.filename != null)
                    message.filename = String(object.filename);
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.ActionConfig.DataPreparationConfig.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.errorTable != null) {
                    if (typeof object.errorTable !== "object")
                        throw TypeError(".dataform.ActionConfig.DataPreparationConfig.errorTable: object expected");
                    message.errorTable = $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.fromObject(object.errorTable);
                }
                if (object.loadMode != null) {
                    if (typeof object.loadMode !== "object")
                        throw TypeError(".dataform.ActionConfig.DataPreparationConfig.loadMode: object expected");
                    message.loadMode = $root.dataform.ActionConfig.LoadModeConfig.fromObject(object.loadMode);
                }
                return message;
            };

            /**
             * Creates a plain object from a DataPreparationConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {dataform.ActionConfig.DataPreparationConfig} message DataPreparationConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DataPreparationConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependencyTargets = [];
                    object.tags = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.filename = "";
                    object.disabled = false;
                    object.description = "";
                    object.errorTable = null;
                    object.loadMode = null;
                    object.dataset = "";
                    object.project = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dependencyTargets && message.dependencyTargets.length) {
                    object.dependencyTargets = [];
                    for (let j = 0; j < message.dependencyTargets.length; ++j)
                        object.dependencyTargets[j] = $root.dataform.ActionConfig.Target.toObject(message.dependencyTargets[j], options);
                }
                if (message.filename != null && message.hasOwnProperty("filename"))
                    object.filename = message.filename;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.errorTable != null && message.hasOwnProperty("errorTable"))
                    object.errorTable = $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.toObject(message.errorTable, options);
                if (message.loadMode != null && message.hasOwnProperty("loadMode"))
                    object.loadMode = $root.dataform.ActionConfig.LoadModeConfig.toObject(message.loadMode, options);
                if (message.dataset != null && message.hasOwnProperty("dataset"))
                    object.dataset = message.dataset;
                if (message.project != null && message.hasOwnProperty("project"))
                    object.project = message.project;
                return object;
            };

            /**
             * Converts this DataPreparationConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DataPreparationConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DataPreparationConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.DataPreparationConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DataPreparationConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.DataPreparationConfig";
            };

            DataPreparationConfig.ErrorTableConfig = (function() {

                /**
                 * Properties of an ErrorTableConfig.
                 * @memberof dataform.ActionConfig.DataPreparationConfig
                 * @interface IErrorTableConfig
                 * @property {string|null} [name] ErrorTableConfig name
                 * @property {string|null} [dataset] ErrorTableConfig dataset
                 * @property {string|null} [project] ErrorTableConfig project
                 * @property {number|null} [retentionDays] ErrorTableConfig retentionDays
                 */

                /**
                 * Constructs a new ErrorTableConfig.
                 * @memberof dataform.ActionConfig.DataPreparationConfig
                 * @classdesc Represents an ErrorTableConfig.
                 * @implements IErrorTableConfig
                 * @constructor
                 * @param {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig=} [properties] Properties to set
                 */
                function ErrorTableConfig(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ErrorTableConfig name.
                 * @member {string} name
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @instance
                 */
                ErrorTableConfig.prototype.name = "";

                /**
                 * ErrorTableConfig dataset.
                 * @member {string} dataset
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @instance
                 */
                ErrorTableConfig.prototype.dataset = "";

                /**
                 * ErrorTableConfig project.
                 * @member {string} project
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @instance
                 */
                ErrorTableConfig.prototype.project = "";

                /**
                 * ErrorTableConfig retentionDays.
                 * @member {number} retentionDays
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @instance
                 */
                ErrorTableConfig.prototype.retentionDays = 0;

                /**
                 * Creates a new ErrorTableConfig instance using the specified properties.
                 * @function create
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig=} [properties] Properties to set
                 * @returns {dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig} ErrorTableConfig instance
                 */
                ErrorTableConfig.create = function create(properties) {
                    return new ErrorTableConfig(properties);
                };

                /**
                 * Encodes the specified ErrorTableConfig message. Does not implicitly {@link dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig} message ErrorTableConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ErrorTableConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.dataset != null && Object.hasOwnProperty.call(message, "dataset"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataset);
                    if (message.project != null && Object.hasOwnProperty.call(message, "project"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                    if (message.retentionDays != null && Object.hasOwnProperty.call(message, "retentionDays"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.retentionDays);
                    return writer;
                };

                /**
                 * Encodes the specified ErrorTableConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {dataform.ActionConfig.DataPreparationConfig.IErrorTableConfig} message ErrorTableConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ErrorTableConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ErrorTableConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig} ErrorTableConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ErrorTableConfig.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.dataset = reader.string();
                                break;
                            }
                        case 3: {
                                message.project = reader.string();
                                break;
                            }
                        case 4: {
                                message.retentionDays = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ErrorTableConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig} ErrorTableConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ErrorTableConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ErrorTableConfig message.
                 * @function verify
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ErrorTableConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.dataset != null && message.hasOwnProperty("dataset"))
                        if (!$util.isString(message.dataset))
                            return "dataset: string expected";
                    if (message.project != null && message.hasOwnProperty("project"))
                        if (!$util.isString(message.project))
                            return "project: string expected";
                    if (message.retentionDays != null && message.hasOwnProperty("retentionDays"))
                        if (!$util.isInteger(message.retentionDays))
                            return "retentionDays: integer expected";
                    return null;
                };

                /**
                 * Creates an ErrorTableConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig} ErrorTableConfig
                 */
                ErrorTableConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig)
                        return object;
                    let message = new $root.dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.dataset != null)
                        message.dataset = String(object.dataset);
                    if (object.project != null)
                        message.project = String(object.project);
                    if (object.retentionDays != null)
                        message.retentionDays = object.retentionDays | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ErrorTableConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig} message ErrorTableConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ErrorTableConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.dataset = "";
                        object.project = "";
                        object.retentionDays = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.dataset != null && message.hasOwnProperty("dataset"))
                        object.dataset = message.dataset;
                    if (message.project != null && message.hasOwnProperty("project"))
                        object.project = message.project;
                    if (message.retentionDays != null && message.hasOwnProperty("retentionDays"))
                        object.retentionDays = message.retentionDays;
                    return object;
                };

                /**
                 * Converts this ErrorTableConfig to JSON.
                 * @function toJSON
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ErrorTableConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ErrorTableConfig
                 * @function getTypeUrl
                 * @memberof dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ErrorTableConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/dataform.ActionConfig.DataPreparationConfig.ErrorTableConfig";
                };

                return ErrorTableConfig;
            })();

            return DataPreparationConfig;
        })();

        ActionConfig.LoadModeConfig = (function() {

            /**
             * Properties of a LoadModeConfig.
             * @memberof dataform.ActionConfig
             * @interface ILoadModeConfig
             * @property {dataform.ActionConfig.LoadMode|null} [mode] LoadModeConfig mode
             * @property {string|null} [incrementalColumn] LoadModeConfig incrementalColumn
             */

            /**
             * Constructs a new LoadModeConfig.
             * @memberof dataform.ActionConfig
             * @classdesc Represents a LoadModeConfig.
             * @implements ILoadModeConfig
             * @constructor
             * @param {dataform.ActionConfig.ILoadModeConfig=} [properties] Properties to set
             */
            function LoadModeConfig(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadModeConfig mode.
             * @member {dataform.ActionConfig.LoadMode} mode
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @instance
             */
            LoadModeConfig.prototype.mode = 0;

            /**
             * LoadModeConfig incrementalColumn.
             * @member {string} incrementalColumn
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @instance
             */
            LoadModeConfig.prototype.incrementalColumn = "";

            /**
             * Creates a new LoadModeConfig instance using the specified properties.
             * @function create
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {dataform.ActionConfig.ILoadModeConfig=} [properties] Properties to set
             * @returns {dataform.ActionConfig.LoadModeConfig} LoadModeConfig instance
             */
            LoadModeConfig.create = function create(properties) {
                return new LoadModeConfig(properties);
            };

            /**
             * Encodes the specified LoadModeConfig message. Does not implicitly {@link dataform.ActionConfig.LoadModeConfig.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {dataform.ActionConfig.ILoadModeConfig} message LoadModeConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModeConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                if (message.incrementalColumn != null && Object.hasOwnProperty.call(message, "incrementalColumn"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.incrementalColumn);
                return writer;
            };

            /**
             * Encodes the specified LoadModeConfig message, length delimited. Does not implicitly {@link dataform.ActionConfig.LoadModeConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {dataform.ActionConfig.ILoadModeConfig} message LoadModeConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModeConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadModeConfig message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionConfig.LoadModeConfig} LoadModeConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModeConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionConfig.LoadModeConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mode = reader.int32();
                            break;
                        }
                    case 2: {
                            message.incrementalColumn = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadModeConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionConfig.LoadModeConfig} LoadModeConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModeConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadModeConfig message.
             * @function verify
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadModeConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.incrementalColumn != null && message.hasOwnProperty("incrementalColumn"))
                    if (!$util.isString(message.incrementalColumn))
                        return "incrementalColumn: string expected";
                return null;
            };

            /**
             * Creates a LoadModeConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionConfig.LoadModeConfig} LoadModeConfig
             */
            LoadModeConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionConfig.LoadModeConfig)
                    return object;
                let message = new $root.dataform.ActionConfig.LoadModeConfig();
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "REPLACE_TABLE":
                case 0:
                    message.mode = 0;
                    break;
                case "APPEND":
                case 1:
                    message.mode = 1;
                    break;
                case "MAXIMUM":
                case 2:
                    message.mode = 2;
                    break;
                case "UNIQUE":
                case 3:
                    message.mode = 3;
                    break;
                }
                if (object.incrementalColumn != null)
                    message.incrementalColumn = String(object.incrementalColumn);
                return message;
            };

            /**
             * Creates a plain object from a LoadModeConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {dataform.ActionConfig.LoadModeConfig} message LoadModeConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadModeConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.mode = options.enums === String ? "REPLACE_TABLE" : 0;
                    object.incrementalColumn = "";
                }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.dataform.ActionConfig.LoadMode[message.mode] === undefined ? message.mode : $root.dataform.ActionConfig.LoadMode[message.mode] : message.mode;
                if (message.incrementalColumn != null && message.hasOwnProperty("incrementalColumn"))
                    object.incrementalColumn = message.incrementalColumn;
                return object;
            };

            /**
             * Converts this LoadModeConfig to JSON.
             * @function toJSON
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadModeConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadModeConfig
             * @function getTypeUrl
             * @memberof dataform.ActionConfig.LoadModeConfig
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadModeConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ActionConfig.LoadModeConfig";
            };

            return LoadModeConfig;
        })();

        /**
         * LoadMode enum.
         * @name dataform.ActionConfig.LoadMode
         * @enum {number}
         * @property {number} REPLACE_TABLE=0 REPLACE_TABLE value
         * @property {number} APPEND=1 APPEND value
         * @property {number} MAXIMUM=2 MAXIMUM value
         * @property {number} UNIQUE=3 UNIQUE value
         */
        ActionConfig.LoadMode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REPLACE_TABLE"] = 0;
            values[valuesById[1] = "APPEND"] = 1;
            values[valuesById[2] = "MAXIMUM"] = 2;
            values[valuesById[3] = "UNIQUE"] = 3;
            return values;
        })();

        return ActionConfig;
    })();

    dataform.NotebookRuntimeOptionsConfig = (function() {

        /**
         * Properties of a NotebookRuntimeOptionsConfig.
         * @memberof dataform
         * @interface INotebookRuntimeOptionsConfig
         * @property {string|null} [outputBucket] NotebookRuntimeOptionsConfig outputBucket
         * @property {string|null} [runtimeTemplateName] NotebookRuntimeOptionsConfig runtimeTemplateName
         */

        /**
         * Constructs a new NotebookRuntimeOptionsConfig.
         * @memberof dataform
         * @classdesc Represents a NotebookRuntimeOptionsConfig.
         * @implements INotebookRuntimeOptionsConfig
         * @constructor
         * @param {dataform.INotebookRuntimeOptionsConfig=} [properties] Properties to set
         */
        function NotebookRuntimeOptionsConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotebookRuntimeOptionsConfig outputBucket.
         * @member {string|null|undefined} outputBucket
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @instance
         */
        NotebookRuntimeOptionsConfig.prototype.outputBucket = null;

        /**
         * NotebookRuntimeOptionsConfig runtimeTemplateName.
         * @member {string} runtimeTemplateName
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @instance
         */
        NotebookRuntimeOptionsConfig.prototype.runtimeTemplateName = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * NotebookRuntimeOptionsConfig outputSink.
         * @member {"outputBucket"|undefined} outputSink
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @instance
         */
        Object.defineProperty(NotebookRuntimeOptionsConfig.prototype, "outputSink", {
            get: $util.oneOfGetter($oneOfFields = ["outputBucket"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new NotebookRuntimeOptionsConfig instance using the specified properties.
         * @function create
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {dataform.INotebookRuntimeOptionsConfig=} [properties] Properties to set
         * @returns {dataform.NotebookRuntimeOptionsConfig} NotebookRuntimeOptionsConfig instance
         */
        NotebookRuntimeOptionsConfig.create = function create(properties) {
            return new NotebookRuntimeOptionsConfig(properties);
        };

        /**
         * Encodes the specified NotebookRuntimeOptionsConfig message. Does not implicitly {@link dataform.NotebookRuntimeOptionsConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {dataform.INotebookRuntimeOptionsConfig} message NotebookRuntimeOptionsConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotebookRuntimeOptionsConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outputBucket != null && Object.hasOwnProperty.call(message, "outputBucket"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputBucket);
            if (message.runtimeTemplateName != null && Object.hasOwnProperty.call(message, "runtimeTemplateName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.runtimeTemplateName);
            return writer;
        };

        /**
         * Encodes the specified NotebookRuntimeOptionsConfig message, length delimited. Does not implicitly {@link dataform.NotebookRuntimeOptionsConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {dataform.INotebookRuntimeOptionsConfig} message NotebookRuntimeOptionsConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotebookRuntimeOptionsConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotebookRuntimeOptionsConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.NotebookRuntimeOptionsConfig} NotebookRuntimeOptionsConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotebookRuntimeOptionsConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.NotebookRuntimeOptionsConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.outputBucket = reader.string();
                        break;
                    }
                case 2: {
                        message.runtimeTemplateName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotebookRuntimeOptionsConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.NotebookRuntimeOptionsConfig} NotebookRuntimeOptionsConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotebookRuntimeOptionsConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotebookRuntimeOptionsConfig message.
         * @function verify
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotebookRuntimeOptionsConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outputBucket != null && message.hasOwnProperty("outputBucket")) {
                if (!$util.isString(message.outputBucket))
                    return "outputBucket: string expected";
            }
            if (message.runtimeTemplateName != null && message.hasOwnProperty("runtimeTemplateName"))
                if (!$util.isString(message.runtimeTemplateName))
                    return "runtimeTemplateName: string expected";
            return null;
        };

        /**
         * Creates a NotebookRuntimeOptionsConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.NotebookRuntimeOptionsConfig} NotebookRuntimeOptionsConfig
         */
        NotebookRuntimeOptionsConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.NotebookRuntimeOptionsConfig)
                return object;
            let message = new $root.dataform.NotebookRuntimeOptionsConfig();
            if (object.outputBucket != null)
                message.outputBucket = String(object.outputBucket);
            if (object.runtimeTemplateName != null)
                message.runtimeTemplateName = String(object.runtimeTemplateName);
            return message;
        };

        /**
         * Creates a plain object from a NotebookRuntimeOptionsConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {dataform.NotebookRuntimeOptionsConfig} message NotebookRuntimeOptionsConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotebookRuntimeOptionsConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.runtimeTemplateName = "";
            if (message.outputBucket != null && message.hasOwnProperty("outputBucket")) {
                object.outputBucket = message.outputBucket;
                if (options.oneofs)
                    object.outputSink = "outputBucket";
            }
            if (message.runtimeTemplateName != null && message.hasOwnProperty("runtimeTemplateName"))
                object.runtimeTemplateName = message.runtimeTemplateName;
            return object;
        };

        /**
         * Converts this NotebookRuntimeOptionsConfig to JSON.
         * @function toJSON
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotebookRuntimeOptionsConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NotebookRuntimeOptionsConfig
         * @function getTypeUrl
         * @memberof dataform.NotebookRuntimeOptionsConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NotebookRuntimeOptionsConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.NotebookRuntimeOptionsConfig";
        };

        return NotebookRuntimeOptionsConfig;
    })();

    dataform.ProjectConfig = (function() {

        /**
         * Properties of a ProjectConfig.
         * @memberof dataform
         * @interface IProjectConfig
         * @property {string|null} [warehouse] ProjectConfig warehouse
         * @property {string|null} [defaultDatabase] ProjectConfig defaultDatabase
         * @property {string|null} [defaultSchema] ProjectConfig defaultSchema
         * @property {string|null} [defaultLocation] ProjectConfig defaultLocation
         * @property {string|null} [assertionSchema] ProjectConfig assertionSchema
         * @property {Object.<string,string>|null} [vars] ProjectConfig vars
         * @property {string|null} [databaseSuffix] ProjectConfig databaseSuffix
         * @property {string|null} [schemaSuffix] ProjectConfig schemaSuffix
         * @property {string|null} [tablePrefix] ProjectConfig tablePrefix
         * @property {string|null} [builtinAssertionNamePrefix] ProjectConfig builtinAssertionNamePrefix
         * @property {dataform.INotebookRuntimeOptions|null} [defaultNotebookRuntimeOptions] ProjectConfig defaultNotebookRuntimeOptions
         */

        /**
         * Constructs a new ProjectConfig.
         * @memberof dataform
         * @classdesc Represents a ProjectConfig.
         * @implements IProjectConfig
         * @constructor
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         */
        function ProjectConfig(properties) {
            this.vars = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProjectConfig warehouse.
         * @member {string} warehouse
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.warehouse = "";

        /**
         * ProjectConfig defaultDatabase.
         * @member {string} defaultDatabase
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultDatabase = "";

        /**
         * ProjectConfig defaultSchema.
         * @member {string} defaultSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultSchema = "";

        /**
         * ProjectConfig defaultLocation.
         * @member {string} defaultLocation
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultLocation = "";

        /**
         * ProjectConfig assertionSchema.
         * @member {string} assertionSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.assertionSchema = "";

        /**
         * ProjectConfig vars.
         * @member {Object.<string,string>} vars
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.vars = $util.emptyObject;

        /**
         * ProjectConfig databaseSuffix.
         * @member {string} databaseSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.databaseSuffix = "";

        /**
         * ProjectConfig schemaSuffix.
         * @member {string} schemaSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.schemaSuffix = "";

        /**
         * ProjectConfig tablePrefix.
         * @member {string} tablePrefix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.tablePrefix = "";

        /**
         * ProjectConfig builtinAssertionNamePrefix.
         * @member {string} builtinAssertionNamePrefix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.builtinAssertionNamePrefix = "";

        /**
         * ProjectConfig defaultNotebookRuntimeOptions.
         * @member {dataform.INotebookRuntimeOptions|null|undefined} defaultNotebookRuntimeOptions
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultNotebookRuntimeOptions = null;

        /**
         * Creates a new ProjectConfig instance using the specified properties.
         * @function create
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         * @returns {dataform.ProjectConfig} ProjectConfig instance
         */
        ProjectConfig.create = function create(properties) {
            return new ProjectConfig(properties);
        };

        /**
         * Encodes the specified ProjectConfig message. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warehouse != null && Object.hasOwnProperty.call(message, "warehouse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.warehouse);
            if (message.defaultSchema != null && Object.hasOwnProperty.call(message, "defaultSchema"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.defaultSchema);
            if (message.assertionSchema != null && Object.hasOwnProperty.call(message, "assertionSchema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.assertionSchema);
            if (message.schemaSuffix != null && Object.hasOwnProperty.call(message, "schemaSuffix"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.schemaSuffix);
            if (message.defaultDatabase != null && Object.hasOwnProperty.call(message, "defaultDatabase"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultDatabase);
            if (message.tablePrefix != null && Object.hasOwnProperty.call(message, "tablePrefix"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.tablePrefix);
            if (message.vars != null && Object.hasOwnProperty.call(message, "vars"))
                for (let keys = Object.keys(message.vars), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.vars[keys[i]]).ldelim();
            if (message.databaseSuffix != null && Object.hasOwnProperty.call(message, "databaseSuffix"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.databaseSuffix);
            if (message.defaultLocation != null && Object.hasOwnProperty.call(message, "defaultLocation"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.defaultLocation);
            if (message.defaultNotebookRuntimeOptions != null && Object.hasOwnProperty.call(message, "defaultNotebookRuntimeOptions"))
                $root.dataform.NotebookRuntimeOptions.encode(message.defaultNotebookRuntimeOptions, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.builtinAssertionNamePrefix != null && Object.hasOwnProperty.call(message, "builtinAssertionNamePrefix"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.builtinAssertionNamePrefix);
            return writer;
        };

        /**
         * Encodes the specified ProjectConfig message, length delimited. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ProjectConfig(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.warehouse = reader.string();
                        break;
                    }
                case 9: {
                        message.defaultDatabase = reader.string();
                        break;
                    }
                case 2: {
                        message.defaultSchema = reader.string();
                        break;
                    }
                case 16: {
                        message.defaultLocation = reader.string();
                        break;
                    }
                case 5: {
                        message.assertionSchema = reader.string();
                        break;
                    }
                case 14: {
                        if (message.vars === $util.emptyObject)
                            message.vars = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.vars[key] = value;
                        break;
                    }
                case 15: {
                        message.databaseSuffix = reader.string();
                        break;
                    }
                case 7: {
                        message.schemaSuffix = reader.string();
                        break;
                    }
                case 11: {
                        message.tablePrefix = reader.string();
                        break;
                    }
                case 18: {
                        message.builtinAssertionNamePrefix = reader.string();
                        break;
                    }
                case 17: {
                        message.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProjectConfig message.
         * @function verify
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProjectConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                if (!$util.isString(message.defaultDatabase))
                    return "defaultDatabase: string expected";
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                if (!$util.isString(message.defaultSchema))
                    return "defaultSchema: string expected";
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                if (!$util.isString(message.defaultLocation))
                    return "defaultLocation: string expected";
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                if (!$util.isString(message.assertionSchema))
                    return "assertionSchema: string expected";
            if (message.vars != null && message.hasOwnProperty("vars")) {
                if (!$util.isObject(message.vars))
                    return "vars: object expected";
                let key = Object.keys(message.vars);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.vars[key[i]]))
                        return "vars: string{k:string} expected";
            }
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                if (!$util.isString(message.databaseSuffix))
                    return "databaseSuffix: string expected";
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                if (!$util.isString(message.schemaSuffix))
                    return "schemaSuffix: string expected";
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                if (!$util.isString(message.tablePrefix))
                    return "tablePrefix: string expected";
            if (message.builtinAssertionNamePrefix != null && message.hasOwnProperty("builtinAssertionNamePrefix"))
                if (!$util.isString(message.builtinAssertionNamePrefix))
                    return "builtinAssertionNamePrefix: string expected";
            if (message.defaultNotebookRuntimeOptions != null && message.hasOwnProperty("defaultNotebookRuntimeOptions")) {
                let error = $root.dataform.NotebookRuntimeOptions.verify(message.defaultNotebookRuntimeOptions);
                if (error)
                    return "defaultNotebookRuntimeOptions." + error;
            }
            return null;
        };

        /**
         * Creates a ProjectConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ProjectConfig} ProjectConfig
         */
        ProjectConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ProjectConfig)
                return object;
            let message = new $root.dataform.ProjectConfig();
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            if (object.defaultDatabase != null)
                message.defaultDatabase = String(object.defaultDatabase);
            if (object.defaultSchema != null)
                message.defaultSchema = String(object.defaultSchema);
            if (object.defaultLocation != null)
                message.defaultLocation = String(object.defaultLocation);
            if (object.assertionSchema != null)
                message.assertionSchema = String(object.assertionSchema);
            if (object.vars) {
                if (typeof object.vars !== "object")
                    throw TypeError(".dataform.ProjectConfig.vars: object expected");
                message.vars = {};
                for (let keys = Object.keys(object.vars), i = 0; i < keys.length; ++i)
                    message.vars[keys[i]] = String(object.vars[keys[i]]);
            }
            if (object.databaseSuffix != null)
                message.databaseSuffix = String(object.databaseSuffix);
            if (object.schemaSuffix != null)
                message.schemaSuffix = String(object.schemaSuffix);
            if (object.tablePrefix != null)
                message.tablePrefix = String(object.tablePrefix);
            if (object.builtinAssertionNamePrefix != null)
                message.builtinAssertionNamePrefix = String(object.builtinAssertionNamePrefix);
            if (object.defaultNotebookRuntimeOptions != null) {
                if (typeof object.defaultNotebookRuntimeOptions !== "object")
                    throw TypeError(".dataform.ProjectConfig.defaultNotebookRuntimeOptions: object expected");
                message.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptions.fromObject(object.defaultNotebookRuntimeOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a ProjectConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.ProjectConfig} message ProjectConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProjectConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.vars = {};
            if (options.defaults) {
                object.warehouse = "";
                object.defaultSchema = "";
                object.assertionSchema = "";
                object.schemaSuffix = "";
                object.defaultDatabase = "";
                object.tablePrefix = "";
                object.databaseSuffix = "";
                object.defaultLocation = "";
                object.defaultNotebookRuntimeOptions = null;
                object.builtinAssertionNamePrefix = "";
            }
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                object.defaultSchema = message.defaultSchema;
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                object.assertionSchema = message.assertionSchema;
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                object.schemaSuffix = message.schemaSuffix;
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                object.defaultDatabase = message.defaultDatabase;
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                object.tablePrefix = message.tablePrefix;
            let keys2;
            if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                object.vars = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.vars[keys2[j]] = message.vars[keys2[j]];
            }
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                object.databaseSuffix = message.databaseSuffix;
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                object.defaultLocation = message.defaultLocation;
            if (message.defaultNotebookRuntimeOptions != null && message.hasOwnProperty("defaultNotebookRuntimeOptions"))
                object.defaultNotebookRuntimeOptions = $root.dataform.NotebookRuntimeOptions.toObject(message.defaultNotebookRuntimeOptions, options);
            if (message.builtinAssertionNamePrefix != null && message.hasOwnProperty("builtinAssertionNamePrefix"))
                object.builtinAssertionNamePrefix = message.builtinAssertionNamePrefix;
            return object;
        };

        /**
         * Converts this ProjectConfig to JSON.
         * @function toJSON
         * @memberof dataform.ProjectConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProjectConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProjectConfig
         * @function getTypeUrl
         * @memberof dataform.ProjectConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProjectConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ProjectConfig";
        };

        return ProjectConfig;
    })();

    dataform.CompileConfig = (function() {

        /**
         * Properties of a CompileConfig.
         * @memberof dataform
         * @interface ICompileConfig
         * @property {string|null} [projectDir] CompileConfig projectDir
         * @property {Array.<string>|null} [filePaths] CompileConfig filePaths
         * @property {dataform.IProjectConfig|null} [projectConfigOverride] CompileConfig projectConfigOverride
         * @property {number|null} [timeoutMillis] CompileConfig timeoutMillis
         */

        /**
         * Constructs a new CompileConfig.
         * @memberof dataform
         * @classdesc Represents a CompileConfig.
         * @implements ICompileConfig
         * @constructor
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         */
        function CompileConfig(properties) {
            this.filePaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileConfig projectDir.
         * @member {string} projectDir
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectDir = "";

        /**
         * CompileConfig filePaths.
         * @member {Array.<string>} filePaths
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.filePaths = $util.emptyArray;

        /**
         * CompileConfig projectConfigOverride.
         * @member {dataform.IProjectConfig|null|undefined} projectConfigOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectConfigOverride = null;

        /**
         * CompileConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.timeoutMillis = 0;

        /**
         * Creates a new CompileConfig instance using the specified properties.
         * @function create
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         * @returns {dataform.CompileConfig} CompileConfig instance
         */
        CompileConfig.create = function create(properties) {
            return new CompileConfig(properties);
        };

        /**
         * Encodes the specified CompileConfig message. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectDir != null && Object.hasOwnProperty.call(message, "projectDir"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
            if (message.projectConfigOverride != null && Object.hasOwnProperty.call(message, "projectConfigOverride"))
                $root.dataform.ProjectConfig.encode(message.projectConfigOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timeoutMillis != null && Object.hasOwnProperty.call(message, "timeoutMillis"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMillis);
            if (message.filePaths != null && message.filePaths.length)
                for (let i = 0; i < message.filePaths.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.filePaths[i]);
            return writer;
        };

        /**
         * Encodes the specified CompileConfig message, length delimited. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectDir = reader.string();
                        break;
                    }
                case 8: {
                        if (!(message.filePaths && message.filePaths.length))
                            message.filePaths = [];
                        message.filePaths.push(reader.string());
                        break;
                    }
                case 3: {
                        message.projectConfigOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.timeoutMillis = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileConfig message.
         * @function verify
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                if (!$util.isString(message.projectDir))
                    return "projectDir: string expected";
            if (message.filePaths != null && message.hasOwnProperty("filePaths")) {
                if (!Array.isArray(message.filePaths))
                    return "filePaths: array expected";
                for (let i = 0; i < message.filePaths.length; ++i)
                    if (!$util.isString(message.filePaths[i]))
                        return "filePaths: string[] expected";
            }
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfigOverride);
                if (error)
                    return "projectConfigOverride." + error;
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            return null;
        };

        /**
         * Creates a CompileConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileConfig} CompileConfig
         */
        CompileConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileConfig)
                return object;
            let message = new $root.dataform.CompileConfig();
            if (object.projectDir != null)
                message.projectDir = String(object.projectDir);
            if (object.filePaths) {
                if (!Array.isArray(object.filePaths))
                    throw TypeError(".dataform.CompileConfig.filePaths: array expected");
                message.filePaths = [];
                for (let i = 0; i < object.filePaths.length; ++i)
                    message.filePaths[i] = String(object.filePaths[i]);
            }
            if (object.projectConfigOverride != null) {
                if (typeof object.projectConfigOverride !== "object")
                    throw TypeError(".dataform.CompileConfig.projectConfigOverride: object expected");
                message.projectConfigOverride = $root.dataform.ProjectConfig.fromObject(object.projectConfigOverride);
            }
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            return message;
        };

        /**
         * Creates a plain object from a CompileConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.CompileConfig} message CompileConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.filePaths = [];
            if (options.defaults) {
                object.projectDir = "";
                object.projectConfigOverride = null;
                object.timeoutMillis = 0;
            }
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                object.projectDir = message.projectDir;
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                object.projectConfigOverride = $root.dataform.ProjectConfig.toObject(message.projectConfigOverride, options);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.filePaths && message.filePaths.length) {
                object.filePaths = [];
                for (let j = 0; j < message.filePaths.length; ++j)
                    object.filePaths[j] = message.filePaths[j];
            }
            return object;
        };

        /**
         * Converts this CompileConfig to JSON.
         * @function toJSON
         * @memberof dataform.CompileConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileConfig
         * @function getTypeUrl
         * @memberof dataform.CompileConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileConfig";
        };

        return CompileConfig;
    })();

    dataform.Target = (function() {

        /**
         * Properties of a Target.
         * @memberof dataform
         * @interface ITarget
         * @property {string|null} [database] Target database
         * @property {string|null} [schema] Target schema
         * @property {string|null} [name] Target name
         * @property {boolean|null} [includeDependentAssertions] Target includeDependentAssertions
         */

        /**
         * Constructs a new Target.
         * @memberof dataform
         * @classdesc Represents a Target.
         * @implements ITarget
         * @constructor
         * @param {dataform.ITarget=} [properties] Properties to set
         */
        function Target(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Target database.
         * @member {string} database
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.database = "";

        /**
         * Target schema.
         * @member {string} schema
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.schema = "";

        /**
         * Target name.
         * @member {string} name
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.name = "";

        /**
         * Target includeDependentAssertions.
         * @member {boolean} includeDependentAssertions
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.includeDependentAssertions = false;

        /**
         * Creates a new Target instance using the specified properties.
         * @function create
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget=} [properties] Properties to set
         * @returns {dataform.Target} Target instance
         */
        Target.create = function create(properties) {
            return new Target(properties);
        };

        /**
         * Encodes the specified Target message. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encode
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.schema);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
            if (message.includeDependentAssertions != null && Object.hasOwnProperty.call(message, "includeDependentAssertions"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeDependentAssertions);
            return writer;
        };

        /**
         * Encodes the specified Target message, length delimited. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Target message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Target();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.database = reader.string();
                        break;
                    }
                case 1: {
                        message.schema = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.includeDependentAssertions = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Target message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Target message.
         * @function verify
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Target.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.includeDependentAssertions != null && message.hasOwnProperty("includeDependentAssertions"))
                if (typeof message.includeDependentAssertions !== "boolean")
                    return "includeDependentAssertions: boolean expected";
            return null;
        };

        /**
         * Creates a Target message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Target} Target
         */
        Target.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Target)
                return object;
            let message = new $root.dataform.Target();
            if (object.database != null)
                message.database = String(object.database);
            if (object.schema != null)
                message.schema = String(object.schema);
            if (object.name != null)
                message.name = String(object.name);
            if (object.includeDependentAssertions != null)
                message.includeDependentAssertions = Boolean(object.includeDependentAssertions);
            return message;
        };

        /**
         * Creates a plain object from a Target message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Target
         * @static
         * @param {dataform.Target} message Target
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Target.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.schema = "";
                object.name = "";
                object.database = "";
                object.includeDependentAssertions = false;
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            if (message.includeDependentAssertions != null && message.hasOwnProperty("includeDependentAssertions"))
                object.includeDependentAssertions = message.includeDependentAssertions;
            return object;
        };

        /**
         * Converts this Target to JSON.
         * @function toJSON
         * @memberof dataform.Target
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Target.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Target
         * @function getTypeUrl
         * @memberof dataform.Target
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Target.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Target";
        };

        return Target;
    })();

    dataform.BigQueryOptions = (function() {

        /**
         * Properties of a BigQueryOptions.
         * @memberof dataform
         * @interface IBigQueryOptions
         * @property {string|null} [partitionBy] BigQueryOptions partitionBy
         * @property {Array.<string>|null} [clusterBy] BigQueryOptions clusterBy
         * @property {string|null} [updatePartitionFilter] BigQueryOptions updatePartitionFilter
         * @property {Object.<string,string>|null} [labels] BigQueryOptions labels
         * @property {number|null} [partitionExpirationDays] BigQueryOptions partitionExpirationDays
         * @property {boolean|null} [requirePartitionFilter] BigQueryOptions requirePartitionFilter
         * @property {Object.<string,string>|null} [additionalOptions] BigQueryOptions additionalOptions
         */

        /**
         * Constructs a new BigQueryOptions.
         * @memberof dataform
         * @classdesc Represents a BigQueryOptions.
         * @implements IBigQueryOptions
         * @constructor
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         */
        function BigQueryOptions(properties) {
            this.clusterBy = [];
            this.labels = {};
            this.additionalOptions = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQueryOptions partitionBy.
         * @member {string} partitionBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionBy = "";

        /**
         * BigQueryOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * BigQueryOptions updatePartitionFilter.
         * @member {string} updatePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.updatePartitionFilter = "";

        /**
         * BigQueryOptions labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.labels = $util.emptyObject;

        /**
         * BigQueryOptions partitionExpirationDays.
         * @member {number} partitionExpirationDays
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionExpirationDays = 0;

        /**
         * BigQueryOptions requirePartitionFilter.
         * @member {boolean} requirePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.requirePartitionFilter = false;

        /**
         * BigQueryOptions additionalOptions.
         * @member {Object.<string,string>} additionalOptions
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.additionalOptions = $util.emptyObject;

        /**
         * Creates a new BigQueryOptions instance using the specified properties.
         * @function create
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         * @returns {dataform.BigQueryOptions} BigQueryOptions instance
         */
        BigQueryOptions.create = function create(properties) {
            return new BigQueryOptions(properties);
        };

        /**
         * Encodes the specified BigQueryOptions message. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && Object.hasOwnProperty.call(message, "partitionBy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionBy);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterBy[i]);
            if (message.updatePartitionFilter != null && Object.hasOwnProperty.call(message, "updatePartitionFilter"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.updatePartitionFilter);
            if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.partitionExpirationDays != null && Object.hasOwnProperty.call(message, "partitionExpirationDays"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.partitionExpirationDays);
            if (message.requirePartitionFilter != null && Object.hasOwnProperty.call(message, "requirePartitionFilter"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.requirePartitionFilter);
            if (message.additionalOptions != null && Object.hasOwnProperty.call(message, "additionalOptions"))
                for (let keys = Object.keys(message.additionalOptions), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.additionalOptions[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BigQueryOptions message, length delimited. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQueryOptions(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.partitionBy = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.clusterBy && message.clusterBy.length))
                            message.clusterBy = [];
                        message.clusterBy.push(reader.string());
                        break;
                    }
                case 3: {
                        message.updatePartitionFilter = reader.string();
                        break;
                    }
                case 4: {
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    }
                case 5: {
                        message.partitionExpirationDays = reader.int32();
                        break;
                    }
                case 6: {
                        message.requirePartitionFilter = reader.bool();
                        break;
                    }
                case 7: {
                        if (message.additionalOptions === $util.emptyObject)
                            message.additionalOptions = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.additionalOptions[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQueryOptions message.
         * @function verify
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQueryOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                if (!$util.isString(message.partitionBy))
                    return "partitionBy: string expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                if (!$util.isString(message.updatePartitionFilter))
                    return "updatePartitionFilter: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                if (!$util.isInteger(message.partitionExpirationDays))
                    return "partitionExpirationDays: integer expected";
            if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                if (typeof message.requirePartitionFilter !== "boolean")
                    return "requirePartitionFilter: boolean expected";
            if (message.additionalOptions != null && message.hasOwnProperty("additionalOptions")) {
                if (!$util.isObject(message.additionalOptions))
                    return "additionalOptions: object expected";
                let key = Object.keys(message.additionalOptions);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.additionalOptions[key[i]]))
                        return "additionalOptions: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a BigQueryOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         */
        BigQueryOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQueryOptions)
                return object;
            let message = new $root.dataform.BigQueryOptions();
            if (object.partitionBy != null)
                message.partitionBy = String(object.partitionBy);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.BigQueryOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            if (object.updatePartitionFilter != null)
                message.updatePartitionFilter = String(object.updatePartitionFilter);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.BigQueryOptions.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.partitionExpirationDays != null)
                message.partitionExpirationDays = object.partitionExpirationDays | 0;
            if (object.requirePartitionFilter != null)
                message.requirePartitionFilter = Boolean(object.requirePartitionFilter);
            if (object.additionalOptions) {
                if (typeof object.additionalOptions !== "object")
                    throw TypeError(".dataform.BigQueryOptions.additionalOptions: object expected");
                message.additionalOptions = {};
                for (let keys = Object.keys(object.additionalOptions), i = 0; i < keys.length; ++i)
                    message.additionalOptions[keys[i]] = String(object.additionalOptions[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BigQueryOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.BigQueryOptions} message BigQueryOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQueryOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.objects || options.defaults) {
                object.labels = {};
                object.additionalOptions = {};
            }
            if (options.defaults) {
                object.partitionBy = "";
                object.updatePartitionFilter = "";
                object.partitionExpirationDays = 0;
                object.requirePartitionFilter = false;
            }
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                object.partitionBy = message.partitionBy;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                object.updatePartitionFilter = message.updatePartitionFilter;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                object.partitionExpirationDays = message.partitionExpirationDays;
            if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                object.requirePartitionFilter = message.requirePartitionFilter;
            if (message.additionalOptions && (keys2 = Object.keys(message.additionalOptions)).length) {
                object.additionalOptions = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.additionalOptions[keys2[j]] = message.additionalOptions[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this BigQueryOptions to JSON.
         * @function toJSON
         * @memberof dataform.BigQueryOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQueryOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BigQueryOptions
         * @function getTypeUrl
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BigQueryOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.BigQueryOptions";
        };

        return BigQueryOptions;
    })();

    dataform.GraphErrors = (function() {

        /**
         * Properties of a GraphErrors.
         * @memberof dataform
         * @interface IGraphErrors
         * @property {Array.<dataform.ICompilationError>|null} [compilationErrors] GraphErrors compilationErrors
         */

        /**
         * Constructs a new GraphErrors.
         * @memberof dataform
         * @classdesc Represents a GraphErrors.
         * @implements IGraphErrors
         * @constructor
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         */
        function GraphErrors(properties) {
            this.compilationErrors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphErrors compilationErrors.
         * @member {Array.<dataform.ICompilationError>} compilationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.compilationErrors = $util.emptyArray;

        /**
         * Creates a new GraphErrors instance using the specified properties.
         * @function create
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         * @returns {dataform.GraphErrors} GraphErrors instance
         */
        GraphErrors.create = function create(properties) {
            return new GraphErrors(properties);
        };

        /**
         * Encodes the specified GraphErrors message. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encode
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compilationErrors != null && message.compilationErrors.length)
                for (let i = 0; i < message.compilationErrors.length; ++i)
                    $root.dataform.CompilationError.encode(message.compilationErrors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphErrors message, length delimited. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GraphErrors();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.compilationErrors && message.compilationErrors.length))
                            message.compilationErrors = [];
                        message.compilationErrors.push($root.dataform.CompilationError.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphErrors message.
         * @function verify
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphErrors.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compilationErrors != null && message.hasOwnProperty("compilationErrors")) {
                if (!Array.isArray(message.compilationErrors))
                    return "compilationErrors: array expected";
                for (let i = 0; i < message.compilationErrors.length; ++i) {
                    let error = $root.dataform.CompilationError.verify(message.compilationErrors[i]);
                    if (error)
                        return "compilationErrors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphErrors message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GraphErrors} GraphErrors
         */
        GraphErrors.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GraphErrors)
                return object;
            let message = new $root.dataform.GraphErrors();
            if (object.compilationErrors) {
                if (!Array.isArray(object.compilationErrors))
                    throw TypeError(".dataform.GraphErrors.compilationErrors: array expected");
                message.compilationErrors = [];
                for (let i = 0; i < object.compilationErrors.length; ++i) {
                    if (typeof object.compilationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.compilationErrors: object expected");
                    message.compilationErrors[i] = $root.dataform.CompilationError.fromObject(object.compilationErrors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphErrors message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.GraphErrors} message GraphErrors
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphErrors.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.compilationErrors = [];
            if (message.compilationErrors && message.compilationErrors.length) {
                object.compilationErrors = [];
                for (let j = 0; j < message.compilationErrors.length; ++j)
                    object.compilationErrors[j] = $root.dataform.CompilationError.toObject(message.compilationErrors[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphErrors to JSON.
         * @function toJSON
         * @memberof dataform.GraphErrors
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphErrors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GraphErrors
         * @function getTypeUrl
         * @memberof dataform.GraphErrors
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GraphErrors.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.GraphErrors";
        };

        return GraphErrors;
    })();

    dataform.CompilationError = (function() {

        /**
         * Properties of a CompilationError.
         * @memberof dataform
         * @interface ICompilationError
         * @property {string|null} [fileName] CompilationError fileName
         * @property {string|null} [actionName] CompilationError actionName
         * @property {dataform.ITarget|null} [actionTarget] CompilationError actionTarget
         * @property {string|null} [message] CompilationError message
         * @property {string|null} [stack] CompilationError stack
         */

        /**
         * Constructs a new CompilationError.
         * @memberof dataform
         * @classdesc Represents a CompilationError.
         * @implements ICompilationError
         * @constructor
         * @param {dataform.ICompilationError=} [properties] Properties to set
         */
        function CompilationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompilationError fileName.
         * @member {string} fileName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.fileName = "";

        /**
         * CompilationError actionName.
         * @member {string} actionName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionName = "";

        /**
         * CompilationError actionTarget.
         * @member {dataform.ITarget|null|undefined} actionTarget
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionTarget = null;

        /**
         * CompilationError message.
         * @member {string} message
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.message = "";

        /**
         * CompilationError stack.
         * @member {string} stack
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.stack = "";

        /**
         * Creates a new CompilationError instance using the specified properties.
         * @function create
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError=} [properties] Properties to set
         * @returns {dataform.CompilationError} CompilationError instance
         */
        CompilationError.create = function create(properties) {
            return new CompilationError(properties);
        };

        /**
         * Encodes the specified CompilationError message. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.stack != null && Object.hasOwnProperty.call(message, "stack"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stack);
            if (message.actionName != null && Object.hasOwnProperty.call(message, "actionName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.actionName);
            if (message.actionTarget != null && Object.hasOwnProperty.call(message, "actionTarget"))
                $root.dataform.Target.encode(message.actionTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompilationError message, length delimited. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompilationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.fileName = reader.string();
                        break;
                    }
                case 4: {
                        message.actionName = reader.string();
                        break;
                    }
                case 5: {
                        message.actionTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.message = reader.string();
                        break;
                    }
                case 3: {
                        message.stack = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompilationError message.
         * @function verify
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompilationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.actionTarget != null && message.hasOwnProperty("actionTarget")) {
                let error = $root.dataform.Target.verify(message.actionTarget);
                if (error)
                    return "actionTarget." + error;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isString(message.stack))
                    return "stack: string expected";
            return null;
        };

        /**
         * Creates a CompilationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompilationError} CompilationError
         */
        CompilationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompilationError)
                return object;
            let message = new $root.dataform.CompilationError();
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.actionTarget != null) {
                if (typeof object.actionTarget !== "object")
                    throw TypeError(".dataform.CompilationError.actionTarget: object expected");
                message.actionTarget = $root.dataform.Target.fromObject(object.actionTarget);
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.stack != null)
                message.stack = String(object.stack);
            return message;
        };

        /**
         * Creates a plain object from a CompilationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.CompilationError} message CompilationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompilationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fileName = "";
                object.message = "";
                object.stack = "";
                object.actionName = "";
                object.actionTarget = null;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            if (message.actionTarget != null && message.hasOwnProperty("actionTarget"))
                object.actionTarget = $root.dataform.Target.toObject(message.actionTarget, options);
            return object;
        };

        /**
         * Converts this CompilationError to JSON.
         * @function toJSON
         * @memberof dataform.CompilationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompilationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompilationError
         * @function getTypeUrl
         * @memberof dataform.CompilationError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompilationError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompilationError";
        };

        return CompilationError;
    })();

    dataform.ActionDescriptor = (function() {

        /**
         * Properties of an ActionDescriptor.
         * @memberof dataform
         * @interface IActionDescriptor
         * @property {string|null} [description] ActionDescriptor description
         * @property {Array.<dataform.IColumnDescriptor>|null} [columns] ActionDescriptor columns
         * @property {Object.<string,string>|null} [bigqueryLabels] ActionDescriptor bigqueryLabels
         */

        /**
         * Constructs a new ActionDescriptor.
         * @memberof dataform
         * @classdesc Represents an ActionDescriptor.
         * @implements IActionDescriptor
         * @constructor
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         */
        function ActionDescriptor(properties) {
            this.columns = [];
            this.bigqueryLabels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionDescriptor description.
         * @member {string} description
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.description = "";

        /**
         * ActionDescriptor columns.
         * @member {Array.<dataform.IColumnDescriptor>} columns
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.columns = $util.emptyArray;

        /**
         * ActionDescriptor bigqueryLabels.
         * @member {Object.<string,string>} bigqueryLabels
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.bigqueryLabels = $util.emptyObject;

        /**
         * Creates a new ActionDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         * @returns {dataform.ActionDescriptor} ActionDescriptor instance
         */
        ActionDescriptor.create = function create(properties) {
            return new ActionDescriptor(properties);
        };

        /**
         * Encodes the specified ActionDescriptor message. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.columns != null && message.columns.length)
                for (let i = 0; i < message.columns.length; ++i)
                    $root.dataform.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bigqueryLabels != null && Object.hasOwnProperty.call(message, "bigqueryLabels"))
                for (let keys = Object.keys(message.bigqueryLabels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.bigqueryLabels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionDescriptor message, length delimited. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionDescriptor(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.description = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.dataform.ColumnDescriptor.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (message.bigqueryLabels === $util.emptyObject)
                            message.bigqueryLabels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.bigqueryLabels[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionDescriptor message.
         * @function verify
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (let i = 0; i < message.columns.length; ++i) {
                    let error = $root.dataform.ColumnDescriptor.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels")) {
                if (!$util.isObject(message.bigqueryLabels))
                    return "bigqueryLabels: object expected";
                let key = Object.keys(message.bigqueryLabels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.bigqueryLabels[key[i]]))
                        return "bigqueryLabels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an ActionDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         */
        ActionDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionDescriptor)
                return object;
            let message = new $root.dataform.ActionDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".dataform.ActionDescriptor.columns: array expected");
                message.columns = [];
                for (let i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".dataform.ActionDescriptor.columns: object expected");
                    message.columns[i] = $root.dataform.ColumnDescriptor.fromObject(object.columns[i]);
                }
            }
            if (object.bigqueryLabels) {
                if (typeof object.bigqueryLabels !== "object")
                    throw TypeError(".dataform.ActionDescriptor.bigqueryLabels: object expected");
                message.bigqueryLabels = {};
                for (let keys = Object.keys(object.bigqueryLabels), i = 0; i < keys.length; ++i)
                    message.bigqueryLabels[keys[i]] = String(object.bigqueryLabels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.ActionDescriptor} message ActionDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.columns = [];
            if (options.objects || options.defaults)
                object.bigqueryLabels = {};
            if (options.defaults)
                object.description = "";
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (let j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.dataform.ColumnDescriptor.toObject(message.columns[j], options);
            }
            let keys2;
            if (message.bigqueryLabels && (keys2 = Object.keys(message.bigqueryLabels)).length) {
                object.bigqueryLabels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.bigqueryLabels[keys2[j]] = message.bigqueryLabels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ActionDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ActionDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionDescriptor
         * @function getTypeUrl
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionDescriptor";
        };

        return ActionDescriptor;
    })();

    dataform.ColumnDescriptor = (function() {

        /**
         * Properties of a ColumnDescriptor.
         * @memberof dataform
         * @interface IColumnDescriptor
         * @property {string|null} [description] ColumnDescriptor description
         * @property {Array.<string>|null} [path] ColumnDescriptor path
         * @property {string|null} [displayName] ColumnDescriptor displayName
         * @property {Array.<string>|null} [tags] ColumnDescriptor tags
         * @property {Array.<string>|null} [bigqueryPolicyTags] ColumnDescriptor bigqueryPolicyTags
         */

        /**
         * Constructs a new ColumnDescriptor.
         * @memberof dataform
         * @classdesc Represents a ColumnDescriptor.
         * @implements IColumnDescriptor
         * @constructor
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         */
        function ColumnDescriptor(properties) {
            this.path = [];
            this.tags = [];
            this.bigqueryPolicyTags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColumnDescriptor description.
         * @member {string} description
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.description = "";

        /**
         * ColumnDescriptor path.
         * @member {Array.<string>} path
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.path = $util.emptyArray;

        /**
         * ColumnDescriptor displayName.
         * @member {string} displayName
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.displayName = "";

        /**
         * ColumnDescriptor tags.
         * @member {Array.<string>} tags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.tags = $util.emptyArray;

        /**
         * ColumnDescriptor bigqueryPolicyTags.
         * @member {Array.<string>} bigqueryPolicyTags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.bigqueryPolicyTags = $util.emptyArray;

        /**
         * Creates a new ColumnDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor instance
         */
        ColumnDescriptor.create = function create(properties) {
            return new ColumnDescriptor(properties);
        };

        /**
         * Encodes the specified ColumnDescriptor message. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.path != null && message.path.length)
                for (let i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path[i]);
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.displayName);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
            if (message.bigqueryPolicyTags != null && message.bigqueryPolicyTags.length)
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.bigqueryPolicyTags[i]);
            return writer;
        };

        /**
         * Encodes the specified ColumnDescriptor message, length delimited. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ColumnDescriptor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.description = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push(reader.string());
                        break;
                    }
                case 3: {
                        message.displayName = reader.string();
                        break;
                    }
                case 7: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 8: {
                        if (!(message.bigqueryPolicyTags && message.bigqueryPolicyTags.length))
                            message.bigqueryPolicyTags = [];
                        message.bigqueryPolicyTags.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColumnDescriptor message.
         * @function verify
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColumnDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (let i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.bigqueryPolicyTags != null && message.hasOwnProperty("bigqueryPolicyTags")) {
                if (!Array.isArray(message.bigqueryPolicyTags))
                    return "bigqueryPolicyTags: array expected";
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    if (!$util.isString(message.bigqueryPolicyTags[i]))
                        return "bigqueryPolicyTags: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ColumnDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         */
        ColumnDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ColumnDescriptor)
                return object;
            let message = new $root.dataform.ColumnDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".dataform.ColumnDescriptor.path: array expected");
                message.path = [];
                for (let i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.ColumnDescriptor.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.bigqueryPolicyTags) {
                if (!Array.isArray(object.bigqueryPolicyTags))
                    throw TypeError(".dataform.ColumnDescriptor.bigqueryPolicyTags: array expected");
                message.bigqueryPolicyTags = [];
                for (let i = 0; i < object.bigqueryPolicyTags.length; ++i)
                    message.bigqueryPolicyTags[i] = String(object.bigqueryPolicyTags[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColumnDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.ColumnDescriptor} message ColumnDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColumnDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.path = [];
                object.tags = [];
                object.bigqueryPolicyTags = [];
            }
            if (options.defaults) {
                object.description = "";
                object.displayName = "";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.path && message.path.length) {
                object.path = [];
                for (let j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.bigqueryPolicyTags && message.bigqueryPolicyTags.length) {
                object.bigqueryPolicyTags = [];
                for (let j = 0; j < message.bigqueryPolicyTags.length; ++j)
                    object.bigqueryPolicyTags[j] = message.bigqueryPolicyTags[j];
            }
            return object;
        };

        /**
         * Converts this ColumnDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ColumnDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColumnDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColumnDescriptor
         * @function getTypeUrl
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColumnDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ColumnDescriptor";
        };

        return ColumnDescriptor;
    })();

    /**
     * TableType enum.
     * @name dataform.TableType
     * @enum {number}
     * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
     * @property {number} TABLE=1 TABLE value
     * @property {number} INCREMENTAL=2 INCREMENTAL value
     * @property {number} VIEW=3 VIEW value
     */
    dataform.TableType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
        values[valuesById[1] = "TABLE"] = 1;
        values[valuesById[2] = "INCREMENTAL"] = 2;
        values[valuesById[3] = "VIEW"] = 3;
        return values;
    })();

    /**
     * OnSchemaChange enum.
     * @name dataform.OnSchemaChange
     * @enum {number}
     * @property {number} IGNORE=0 IGNORE value
     * @property {number} FAIL=1 FAIL value
     * @property {number} EXTEND=2 EXTEND value
     * @property {number} SYNCHRONIZE=3 SYNCHRONIZE value
     */
    dataform.OnSchemaChange = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "IGNORE"] = 0;
        values[valuesById[1] = "FAIL"] = 1;
        values[valuesById[2] = "EXTEND"] = 2;
        values[valuesById[3] = "SYNCHRONIZE"] = 3;
        return values;
    })();

    dataform.Table = (function() {

        /**
         * Properties of a Table.
         * @memberof dataform
         * @interface ITable
         * @property {dataform.TableType|null} [enumType] Table enumType
         * @property {dataform.ITarget|null} [target] Table target
         * @property {dataform.ITarget|null} [canonicalTarget] Table canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Table dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Table hermeticity
         * @property {boolean|null} [disabled] Table disabled
         * @property {string|null} [type] Table type
         * @property {string|null} [query] Table query
         * @property {boolean|null} ["protected"] Table protected
         * @property {boolean|null} [materialized] Table materialized
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Table actionDescriptor
         * @property {Array.<string>|null} [tags] Table tags
         * @property {string|null} [where] Table where
         * @property {string|null} [incrementalQuery] Table incrementalQuery
         * @property {Array.<string>|null} [uniqueKey] Table uniqueKey
         * @property {dataform.OnSchemaChange|null} [onSchemaChange] Table onSchemaChange
         * @property {Array.<string>|null} [preOps] Table preOps
         * @property {Array.<string>|null} [postOps] Table postOps
         * @property {Array.<string>|null} [incrementalPreOps] Table incrementalPreOps
         * @property {Array.<string>|null} [incrementalPostOps] Table incrementalPostOps
         * @property {dataform.IBigQueryOptions|null} [bigquery] Table bigquery
         * @property {string|null} [fileName] Table fileName
         */

        /**
         * Constructs a new Table.
         * @memberof dataform
         * @classdesc Represents a Table.
         * @implements ITable
         * @constructor
         * @param {dataform.ITable=} [properties] Properties to set
         */
        function Table(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.uniqueKey = [];
            this.preOps = [];
            this.postOps = [];
            this.incrementalPreOps = [];
            this.incrementalPostOps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Table enumType.
         * @member {dataform.TableType} enumType
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.enumType = 0;

        /**
         * Table target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.target = null;

        /**
         * Table canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.canonicalTarget = null;

        /**
         * Table dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Table hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.hermeticity = 0;

        /**
         * Table disabled.
         * @member {boolean} disabled
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.disabled = false;

        /**
         * Table type.
         * @member {string} type
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.type = "";

        /**
         * Table query.
         * @member {string} query
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.query = "";

        /**
         * Table protected.
         * @member {boolean} protected
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype["protected"] = false;

        /**
         * Table materialized.
         * @member {boolean} materialized
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.materialized = false;

        /**
         * Table actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.actionDescriptor = null;

        /**
         * Table tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.tags = $util.emptyArray;

        /**
         * Table where.
         * @member {string} where
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.where = "";

        /**
         * Table incrementalQuery.
         * @member {string} incrementalQuery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalQuery = "";

        /**
         * Table uniqueKey.
         * @member {Array.<string>} uniqueKey
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.uniqueKey = $util.emptyArray;

        /**
         * Table onSchemaChange.
         * @member {dataform.OnSchemaChange} onSchemaChange
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.onSchemaChange = 0;

        /**
         * Table preOps.
         * @member {Array.<string>} preOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.preOps = $util.emptyArray;

        /**
         * Table postOps.
         * @member {Array.<string>} postOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.postOps = $util.emptyArray;

        /**
         * Table incrementalPreOps.
         * @member {Array.<string>} incrementalPreOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPreOps = $util.emptyArray;

        /**
         * Table incrementalPostOps.
         * @member {Array.<string>} incrementalPostOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPostOps = $util.emptyArray;

        /**
         * Table bigquery.
         * @member {dataform.IBigQueryOptions|null|undefined} bigquery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.bigquery = null;

        /**
         * Table fileName.
         * @member {string} fileName
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.fileName = "";

        /**
         * Creates a new Table instance using the specified properties.
         * @function create
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable=} [properties] Properties to set
         * @returns {dataform.Table} Table instance
         */
        Table.create = function create(properties) {
            return new Table(properties);
        };

        /**
         * Encodes the specified Table message. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encode
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.query);
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.where != null && Object.hasOwnProperty.call(message, "where"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.where);
            if (message["protected"] != null && Object.hasOwnProperty.call(message, "protected"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message["protected"]);
            if (message.preOps != null && message.preOps.length)
                for (let i = 0; i < message.preOps.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.preOps[i]);
            if (message.postOps != null && message.postOps.length)
                for (let i = 0; i < message.postOps.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.postOps[i]);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.fileName);
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.BigQueryOptions.encode(message.bigquery, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 23, wireType 2 =*/186).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.incrementalQuery != null && Object.hasOwnProperty.call(message, "incrementalQuery"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.incrementalQuery);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.incrementalPreOps != null && message.incrementalPreOps.length)
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.incrementalPreOps[i]);
            if (message.incrementalPostOps != null && message.incrementalPostOps.length)
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    writer.uint32(/* id 29, wireType 2 =*/234).string(message.incrementalPostOps[i]);
            if (message.uniqueKey != null && message.uniqueKey.length)
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    writer.uint32(/* id 30, wireType 2 =*/242).string(message.uniqueKey[i]);
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.materialized != null && Object.hasOwnProperty.call(message, "materialized"))
                writer.uint32(/* id 35, wireType 0 =*/280).bool(message.materialized);
            if (message.enumType != null && Object.hasOwnProperty.call(message, "enumType"))
                writer.uint32(/* id 36, wireType 0 =*/288).int32(message.enumType);
            if (message.onSchemaChange != null && Object.hasOwnProperty.call(message, "onSchemaChange"))
                writer.uint32(/* id 37, wireType 0 =*/296).int32(message.onSchemaChange);
            return writer;
        };

        /**
         * Encodes the specified Table message, length delimited. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Table message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Table();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 36: {
                        message.enumType = reader.int32();
                        break;
                    }
                case 4: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 31: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 6: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 3: {
                        message.type = reader.string();
                        break;
                    }
                case 5: {
                        message.query = reader.string();
                        break;
                    }
                case 9: {
                        message["protected"] = reader.bool();
                        break;
                    }
                case 35: {
                        message.materialized = reader.bool();
                        break;
                    }
                case 24: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 8: {
                        message.where = reader.string();
                        break;
                    }
                case 26: {
                        message.incrementalQuery = reader.string();
                        break;
                    }
                case 30: {
                        if (!(message.uniqueKey && message.uniqueKey.length))
                            message.uniqueKey = [];
                        message.uniqueKey.push(reader.string());
                        break;
                    }
                case 37: {
                        message.onSchemaChange = reader.int32();
                        break;
                    }
                case 13: {
                        if (!(message.preOps && message.preOps.length))
                            message.preOps = [];
                        message.preOps.push(reader.string());
                        break;
                    }
                case 14: {
                        if (!(message.postOps && message.postOps.length))
                            message.postOps = [];
                        message.postOps.push(reader.string());
                        break;
                    }
                case 28: {
                        if (!(message.incrementalPreOps && message.incrementalPreOps.length))
                            message.incrementalPreOps = [];
                        message.incrementalPreOps.push(reader.string());
                        break;
                    }
                case 29: {
                        if (!(message.incrementalPostOps && message.incrementalPostOps.length))
                            message.incrementalPostOps = [];
                        message.incrementalPostOps.push(reader.string());
                        break;
                    }
                case 22: {
                        message.bigquery = $root.dataform.BigQueryOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Table message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Table message.
         * @function verify
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Table.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enumType != null && message.hasOwnProperty("enumType"))
                switch (message.enumType) {
                default:
                    return "enumType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                if (typeof message["protected"] !== "boolean")
                    return "protected: boolean expected";
            if (message.materialized != null && message.hasOwnProperty("materialized"))
                if (typeof message.materialized !== "boolean")
                    return "materialized: boolean expected";
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.where != null && message.hasOwnProperty("where"))
                if (!$util.isString(message.where))
                    return "where: string expected";
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                if (!$util.isString(message.incrementalQuery))
                    return "incrementalQuery: string expected";
            if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                if (!Array.isArray(message.uniqueKey))
                    return "uniqueKey: array expected";
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    if (!$util.isString(message.uniqueKey[i]))
                        return "uniqueKey: string[] expected";
            }
            if (message.onSchemaChange != null && message.hasOwnProperty("onSchemaChange"))
                switch (message.onSchemaChange) {
                default:
                    return "onSchemaChange: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.preOps != null && message.hasOwnProperty("preOps")) {
                if (!Array.isArray(message.preOps))
                    return "preOps: array expected";
                for (let i = 0; i < message.preOps.length; ++i)
                    if (!$util.isString(message.preOps[i]))
                        return "preOps: string[] expected";
            }
            if (message.postOps != null && message.hasOwnProperty("postOps")) {
                if (!Array.isArray(message.postOps))
                    return "postOps: array expected";
                for (let i = 0; i < message.postOps.length; ++i)
                    if (!$util.isString(message.postOps[i]))
                        return "postOps: string[] expected";
            }
            if (message.incrementalPreOps != null && message.hasOwnProperty("incrementalPreOps")) {
                if (!Array.isArray(message.incrementalPreOps))
                    return "incrementalPreOps: array expected";
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    if (!$util.isString(message.incrementalPreOps[i]))
                        return "incrementalPreOps: string[] expected";
            }
            if (message.incrementalPostOps != null && message.hasOwnProperty("incrementalPostOps")) {
                if (!Array.isArray(message.incrementalPostOps))
                    return "incrementalPostOps: array expected";
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    if (!$util.isString(message.incrementalPostOps[i]))
                        return "incrementalPostOps: string[] expected";
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.BigQueryOptions.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Table message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Table} Table
         */
        Table.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Table)
                return object;
            let message = new $root.dataform.Table();
            switch (object.enumType) {
            default:
                if (typeof object.enumType === "number") {
                    message.enumType = object.enumType;
                    break;
                }
                break;
            case "UNKNOWN_TYPE":
            case 0:
                message.enumType = 0;
                break;
            case "TABLE":
            case 1:
                message.enumType = 1;
                break;
            case "INCREMENTAL":
            case 2:
                message.enumType = 2;
                break;
            case "VIEW":
            case 3:
                message.enumType = 3;
                break;
            }
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Table.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Table.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Table.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Table.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            default:
                if (typeof object.hermeticity === "number") {
                    message.hermeticity = object.hermeticity;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.type != null)
                message.type = String(object.type);
            if (object.query != null)
                message.query = String(object.query);
            if (object["protected"] != null)
                message["protected"] = Boolean(object["protected"]);
            if (object.materialized != null)
                message.materialized = Boolean(object.materialized);
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Table.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Table.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.where != null)
                message.where = String(object.where);
            if (object.incrementalQuery != null)
                message.incrementalQuery = String(object.incrementalQuery);
            if (object.uniqueKey) {
                if (!Array.isArray(object.uniqueKey))
                    throw TypeError(".dataform.Table.uniqueKey: array expected");
                message.uniqueKey = [];
                for (let i = 0; i < object.uniqueKey.length; ++i)
                    message.uniqueKey[i] = String(object.uniqueKey[i]);
            }
            switch (object.onSchemaChange) {
            default:
                if (typeof object.onSchemaChange === "number") {
                    message.onSchemaChange = object.onSchemaChange;
                    break;
                }
                break;
            case "IGNORE":
            case 0:
                message.onSchemaChange = 0;
                break;
            case "FAIL":
            case 1:
                message.onSchemaChange = 1;
                break;
            case "EXTEND":
            case 2:
                message.onSchemaChange = 2;
                break;
            case "SYNCHRONIZE":
            case 3:
                message.onSchemaChange = 3;
                break;
            }
            if (object.preOps) {
                if (!Array.isArray(object.preOps))
                    throw TypeError(".dataform.Table.preOps: array expected");
                message.preOps = [];
                for (let i = 0; i < object.preOps.length; ++i)
                    message.preOps[i] = String(object.preOps[i]);
            }
            if (object.postOps) {
                if (!Array.isArray(object.postOps))
                    throw TypeError(".dataform.Table.postOps: array expected");
                message.postOps = [];
                for (let i = 0; i < object.postOps.length; ++i)
                    message.postOps[i] = String(object.postOps[i]);
            }
            if (object.incrementalPreOps) {
                if (!Array.isArray(object.incrementalPreOps))
                    throw TypeError(".dataform.Table.incrementalPreOps: array expected");
                message.incrementalPreOps = [];
                for (let i = 0; i < object.incrementalPreOps.length; ++i)
                    message.incrementalPreOps[i] = String(object.incrementalPreOps[i]);
            }
            if (object.incrementalPostOps) {
                if (!Array.isArray(object.incrementalPostOps))
                    throw TypeError(".dataform.Table.incrementalPostOps: array expected");
                message.incrementalPostOps = [];
                for (let i = 0; i < object.incrementalPostOps.length; ++i)
                    message.incrementalPostOps[i] = String(object.incrementalPostOps[i]);
            }
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.Table.bigquery: object expected");
                message.bigquery = $root.dataform.BigQueryOptions.fromObject(object.bigquery);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Table message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Table
         * @static
         * @param {dataform.Table} message Table
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Table.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.preOps = [];
                object.postOps = [];
                object.tags = [];
                object.dependencyTargets = [];
                object.incrementalPreOps = [];
                object.incrementalPostOps = [];
                object.uniqueKey = [];
            }
            if (options.defaults) {
                object.type = "";
                object.target = null;
                object.query = "";
                object.disabled = false;
                object.where = "";
                object["protected"] = false;
                object.fileName = "";
                object.bigquery = null;
                object.actionDescriptor = null;
                object.incrementalQuery = "";
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.materialized = false;
                object.enumType = options.enums === String ? "UNKNOWN_TYPE" : 0;
                object.onSchemaChange = options.enums === String ? "IGNORE" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.where != null && message.hasOwnProperty("where"))
                object.where = message.where;
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                object["protected"] = message["protected"];
            if (message.preOps && message.preOps.length) {
                object.preOps = [];
                for (let j = 0; j < message.preOps.length; ++j)
                    object.preOps[j] = message.preOps[j];
            }
            if (message.postOps && message.postOps.length) {
                object.postOps = [];
                for (let j = 0; j < message.postOps.length; ++j)
                    object.postOps[j] = message.postOps[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.BigQueryOptions.toObject(message.bigquery, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                object.incrementalQuery = message.incrementalQuery;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.incrementalPreOps && message.incrementalPreOps.length) {
                object.incrementalPreOps = [];
                for (let j = 0; j < message.incrementalPreOps.length; ++j)
                    object.incrementalPreOps[j] = message.incrementalPreOps[j];
            }
            if (message.incrementalPostOps && message.incrementalPostOps.length) {
                object.incrementalPostOps = [];
                for (let j = 0; j < message.incrementalPostOps.length; ++j)
                    object.incrementalPostOps[j] = message.incrementalPostOps[j];
            }
            if (message.uniqueKey && message.uniqueKey.length) {
                object.uniqueKey = [];
                for (let j = 0; j < message.uniqueKey.length; ++j)
                    object.uniqueKey[j] = message.uniqueKey[j];
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] === undefined ? message.hermeticity : $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.materialized != null && message.hasOwnProperty("materialized"))
                object.materialized = message.materialized;
            if (message.enumType != null && message.hasOwnProperty("enumType"))
                object.enumType = options.enums === String ? $root.dataform.TableType[message.enumType] === undefined ? message.enumType : $root.dataform.TableType[message.enumType] : message.enumType;
            if (message.onSchemaChange != null && message.hasOwnProperty("onSchemaChange"))
                object.onSchemaChange = options.enums === String ? $root.dataform.OnSchemaChange[message.onSchemaChange] === undefined ? message.onSchemaChange : $root.dataform.OnSchemaChange[message.onSchemaChange] : message.onSchemaChange;
            return object;
        };

        /**
         * Converts this Table to JSON.
         * @function toJSON
         * @memberof dataform.Table
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Table.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Table
         * @function getTypeUrl
         * @memberof dataform.Table
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Table.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Table";
        };

        return Table;
    })();

    dataform.Operation = (function() {

        /**
         * Properties of an Operation.
         * @memberof dataform
         * @interface IOperation
         * @property {dataform.ITarget|null} [target] Operation target
         * @property {dataform.ITarget|null} [canonicalTarget] Operation canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Operation dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Operation hermeticity
         * @property {boolean|null} [disabled] Operation disabled
         * @property {Array.<string>|null} [queries] Operation queries
         * @property {boolean|null} [hasOutput] Operation hasOutput
         * @property {Array.<string>|null} [tags] Operation tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Operation actionDescriptor
         * @property {string|null} [fileName] Operation fileName
         */

        /**
         * Constructs a new Operation.
         * @memberof dataform
         * @classdesc Represents an Operation.
         * @implements IOperation
         * @constructor
         * @param {dataform.IOperation=} [properties] Properties to set
         */
        function Operation(properties) {
            this.dependencyTargets = [];
            this.queries = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Operation target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.target = null;

        /**
         * Operation canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.canonicalTarget = null;

        /**
         * Operation dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Operation hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hermeticity = 0;

        /**
         * Operation disabled.
         * @member {boolean} disabled
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.disabled = false;

        /**
         * Operation queries.
         * @member {Array.<string>} queries
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.queries = $util.emptyArray;

        /**
         * Operation hasOutput.
         * @member {boolean} hasOutput
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hasOutput = false;

        /**
         * Operation tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.tags = $util.emptyArray;

        /**
         * Operation actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.actionDescriptor = null;

        /**
         * Operation fileName.
         * @member {string} fileName
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.fileName = "";

        /**
         * Creates a new Operation instance using the specified properties.
         * @function create
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation=} [properties] Properties to set
         * @returns {dataform.Operation} Operation instance
         */
        Operation.create = function create(properties) {
            return new Operation(properties);
        };

        /**
         * Encodes the specified Operation message. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encode
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (let i = 0; i < message.queries.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.queries[i]);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.hasOutput != null && Object.hasOwnProperty.call(message, "hasOutput"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasOutput);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            return writer;
        };

        /**
         * Encodes the specified Operation message, length delimited. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Operation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Operation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 14: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 6: {
                        if (!(message.queries && message.queries.length))
                            message.queries = [];
                        message.queries.push(reader.string());
                        break;
                    }
                case 8: {
                        message.hasOutput = reader.bool();
                        break;
                    }
                case 9: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 10: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Operation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Operation message.
         * @function verify
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Operation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (let i = 0; i < message.queries.length; ++i)
                    if (!$util.isString(message.queries[i]))
                        return "queries: string[] expected";
            }
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                if (typeof message.hasOutput !== "boolean")
                    return "hasOutput: boolean expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates an Operation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Operation} Operation
         */
        Operation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Operation)
                return object;
            let message = new $root.dataform.Operation();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Operation.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Operation.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Operation.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Operation.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            default:
                if (typeof object.hermeticity === "number") {
                    message.hermeticity = object.hermeticity;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".dataform.Operation.queries: array expected");
                message.queries = [];
                for (let i = 0; i < object.queries.length; ++i)
                    message.queries[i] = String(object.queries[i]);
            }
            if (object.hasOutput != null)
                message.hasOutput = Boolean(object.hasOutput);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Operation.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Operation.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from an Operation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Operation
         * @static
         * @param {dataform.Operation} message Operation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Operation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.queries = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.target = null;
                object.fileName = "";
                object.hasOutput = false;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (let j = 0; j < message.queries.length; ++j)
                    object.queries[j] = message.queries[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                object.hasOutput = message.hasOutput;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] === undefined ? message.hermeticity : $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            return object;
        };

        /**
         * Converts this Operation to JSON.
         * @function toJSON
         * @memberof dataform.Operation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Operation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Operation
         * @function getTypeUrl
         * @memberof dataform.Operation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Operation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Operation";
        };

        return Operation;
    })();

    dataform.Assertion = (function() {

        /**
         * Properties of an Assertion.
         * @memberof dataform
         * @interface IAssertion
         * @property {dataform.ITarget|null} [target] Assertion target
         * @property {dataform.ITarget|null} [canonicalTarget] Assertion canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Assertion dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Assertion hermeticity
         * @property {boolean|null} [disabled] Assertion disabled
         * @property {string|null} [query] Assertion query
         * @property {Array.<string>|null} [tags] Assertion tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Assertion actionDescriptor
         * @property {dataform.ITarget|null} [parentAction] Assertion parentAction
         * @property {string|null} [fileName] Assertion fileName
         */

        /**
         * Constructs a new Assertion.
         * @memberof dataform
         * @classdesc Represents an Assertion.
         * @implements IAssertion
         * @constructor
         * @param {dataform.IAssertion=} [properties] Properties to set
         */
        function Assertion(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Assertion target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.target = null;

        /**
         * Assertion canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.canonicalTarget = null;

        /**
         * Assertion dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Assertion hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.hermeticity = 0;

        /**
         * Assertion disabled.
         * @member {boolean} disabled
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.disabled = false;

        /**
         * Assertion query.
         * @member {string} query
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.query = "";

        /**
         * Assertion tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.tags = $util.emptyArray;

        /**
         * Assertion actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.actionDescriptor = null;

        /**
         * Assertion parentAction.
         * @member {dataform.ITarget|null|undefined} parentAction
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.parentAction = null;

        /**
         * Assertion fileName.
         * @member {string} fileName
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.fileName = "";

        /**
         * Creates a new Assertion instance using the specified properties.
         * @function create
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion=} [properties] Properties to set
         * @returns {dataform.Assertion} Assertion instance
         */
        Assertion.create = function create(properties) {
            return new Assertion(properties);
        };

        /**
         * Encodes the specified Assertion message. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encode
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.query);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            if (message.parentAction != null && Object.hasOwnProperty.call(message, "parentAction"))
                $root.dataform.Target.encode(message.parentAction, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Assertion message, length delimited. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Assertion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 8: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 14: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 3: {
                        message.query = reader.string();
                        break;
                    }
                case 9: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 10: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.parentAction = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Assertion message.
         * @function verify
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Assertion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.parentAction != null && message.hasOwnProperty("parentAction")) {
                let error = $root.dataform.Target.verify(message.parentAction);
                if (error)
                    return "parentAction." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates an Assertion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Assertion} Assertion
         */
        Assertion.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Assertion)
                return object;
            let message = new $root.dataform.Assertion();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Assertion.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Assertion.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Assertion.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Assertion.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            default:
                if (typeof object.hermeticity === "number") {
                    message.hermeticity = object.hermeticity;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.query != null)
                message.query = String(object.query);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Assertion.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Assertion.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.parentAction != null) {
                if (typeof object.parentAction !== "object")
                    throw TypeError(".dataform.Assertion.parentAction: object expected");
                message.parentAction = $root.dataform.Target.fromObject(object.parentAction);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from an Assertion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.Assertion} message Assertion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Assertion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.query = "";
                object.fileName = "";
                object.target = null;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
                object.parentAction = null;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] === undefined ? message.hermeticity : $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                object.parentAction = $root.dataform.Target.toObject(message.parentAction, options);
            return object;
        };

        /**
         * Converts this Assertion to JSON.
         * @function toJSON
         * @memberof dataform.Assertion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Assertion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Assertion
         * @function getTypeUrl
         * @memberof dataform.Assertion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Assertion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Assertion";
        };

        return Assertion;
    })();

    /**
     * ActionHermeticity enum.
     * @name dataform.ActionHermeticity
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HERMETIC=1 HERMETIC value
     * @property {number} NON_HERMETIC=2 NON_HERMETIC value
     */
    dataform.ActionHermeticity = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HERMETIC"] = 1;
        values[valuesById[2] = "NON_HERMETIC"] = 2;
        return values;
    })();

    dataform.Declaration = (function() {

        /**
         * Properties of a Declaration.
         * @memberof dataform
         * @interface IDeclaration
         * @property {dataform.ITarget|null} [target] Declaration target
         * @property {dataform.ITarget|null} [canonicalTarget] Declaration canonicalTarget
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Declaration actionDescriptor
         * @property {string|null} [fileName] Declaration fileName
         */

        /**
         * Constructs a new Declaration.
         * @memberof dataform
         * @classdesc Represents a Declaration.
         * @implements IDeclaration
         * @constructor
         * @param {dataform.IDeclaration=} [properties] Properties to set
         */
        function Declaration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Declaration target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.target = null;

        /**
         * Declaration canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.canonicalTarget = null;

        /**
         * Declaration actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.actionDescriptor = null;

        /**
         * Declaration fileName.
         * @member {string} fileName
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.fileName = "";

        /**
         * Creates a new Declaration instance using the specified properties.
         * @function create
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration=} [properties] Properties to set
         * @returns {dataform.Declaration} Declaration instance
         */
        Declaration.create = function create(properties) {
            return new Declaration(properties);
        };

        /**
         * Encodes the specified Declaration message. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encode
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Declaration message, length delimited. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Declaration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Declaration message.
         * @function verify
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Declaration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Declaration} Declaration
         */
        Declaration.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Declaration)
                return object;
            let message = new $root.dataform.Declaration();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Declaration.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Declaration.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Declaration.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Declaration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.Declaration} message Declaration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Declaration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.target = null;
                object.actionDescriptor = null;
                object.fileName = "";
                object.canonicalTarget = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            return object;
        };

        /**
         * Converts this Declaration to JSON.
         * @function toJSON
         * @memberof dataform.Declaration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Declaration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Declaration
         * @function getTypeUrl
         * @memberof dataform.Declaration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Declaration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Declaration";
        };

        return Declaration;
    })();

    dataform.Test = (function() {

        /**
         * Properties of a Test.
         * @memberof dataform
         * @interface ITest
         * @property {string|null} [name] Test name
         * @property {string|null} [testQuery] Test testQuery
         * @property {string|null} [expectedOutputQuery] Test expectedOutputQuery
         * @property {string|null} [fileName] Test fileName
         */

        /**
         * Constructs a new Test.
         * @memberof dataform
         * @classdesc Represents a Test.
         * @implements ITest
         * @constructor
         * @param {dataform.ITest=} [properties] Properties to set
         */
        function Test(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test name.
         * @member {string} name
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.name = "";

        /**
         * Test testQuery.
         * @member {string} testQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.testQuery = "";

        /**
         * Test expectedOutputQuery.
         * @member {string} expectedOutputQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.expectedOutputQuery = "";

        /**
         * Test fileName.
         * @member {string} fileName
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.fileName = "";

        /**
         * Creates a new Test instance using the specified properties.
         * @function create
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest=} [properties] Properties to set
         * @returns {dataform.Test} Test instance
         */
        Test.create = function create(properties) {
            return new Test(properties);
        };

        /**
         * Encodes the specified Test message. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encode
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.testQuery != null && Object.hasOwnProperty.call(message, "testQuery"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testQuery);
            if (message.expectedOutputQuery != null && Object.hasOwnProperty.call(message, "expectedOutputQuery"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expectedOutputQuery);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            return writer;
        };

        /**
         * Encodes the specified Test message, length delimited. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Test message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Test();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.testQuery = reader.string();
                        break;
                    }
                case 3: {
                        message.expectedOutputQuery = reader.string();
                        break;
                    }
                case 4: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Test message.
         * @function verify
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                if (!$util.isString(message.testQuery))
                    return "testQuery: string expected";
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                if (!$util.isString(message.expectedOutputQuery))
                    return "expectedOutputQuery: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Test} Test
         */
        Test.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Test)
                return object;
            let message = new $root.dataform.Test();
            if (object.name != null)
                message.name = String(object.name);
            if (object.testQuery != null)
                message.testQuery = String(object.testQuery);
            if (object.expectedOutputQuery != null)
                message.expectedOutputQuery = String(object.expectedOutputQuery);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Test
         * @static
         * @param {dataform.Test} message Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.testQuery = "";
                object.expectedOutputQuery = "";
                object.fileName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                object.testQuery = message.testQuery;
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                object.expectedOutputQuery = message.expectedOutputQuery;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            return object;
        };

        /**
         * Converts this Test to JSON.
         * @function toJSON
         * @memberof dataform.Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Test
         * @function getTypeUrl
         * @memberof dataform.Test
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Test.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Test";
        };

        return Test;
    })();

    dataform.Notebook = (function() {

        /**
         * Properties of a Notebook.
         * @memberof dataform
         * @interface INotebook
         * @property {dataform.ITarget|null} [target] Notebook target
         * @property {dataform.ITarget|null} [canonicalTarget] Notebook canonicalTarget
         * @property {Array.<string>|null} [tags] Notebook tags
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Notebook dependencyTargets
         * @property {string|null} [fileName] Notebook fileName
         * @property {boolean|null} [disabled] Notebook disabled
         * @property {string|null} [notebookContents] Notebook notebookContents
         */

        /**
         * Constructs a new Notebook.
         * @memberof dataform
         * @classdesc Represents a Notebook.
         * @implements INotebook
         * @constructor
         * @param {dataform.INotebook=} [properties] Properties to set
         */
        function Notebook(properties) {
            this.tags = [];
            this.dependencyTargets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Notebook target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.target = null;

        /**
         * Notebook canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.canonicalTarget = null;

        /**
         * Notebook tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.tags = $util.emptyArray;

        /**
         * Notebook dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Notebook fileName.
         * @member {string} fileName
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.fileName = "";

        /**
         * Notebook disabled.
         * @member {boolean} disabled
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.disabled = false;

        /**
         * Notebook notebookContents.
         * @member {string} notebookContents
         * @memberof dataform.Notebook
         * @instance
         */
        Notebook.prototype.notebookContents = "";

        /**
         * Creates a new Notebook instance using the specified properties.
         * @function create
         * @memberof dataform.Notebook
         * @static
         * @param {dataform.INotebook=} [properties] Properties to set
         * @returns {dataform.Notebook} Notebook instance
         */
        Notebook.create = function create(properties) {
            return new Notebook(properties);
        };

        /**
         * Encodes the specified Notebook message. Does not implicitly {@link dataform.Notebook.verify|verify} messages.
         * @function encode
         * @memberof dataform.Notebook
         * @static
         * @param {dataform.INotebook} message Notebook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Notebook.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tags[i]);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileName);
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.notebookContents != null && Object.hasOwnProperty.call(message, "notebookContents"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.notebookContents);
            return writer;
        };

        /**
         * Encodes the specified Notebook message, length delimited. Does not implicitly {@link dataform.Notebook.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Notebook
         * @static
         * @param {dataform.INotebook} message Notebook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Notebook.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Notebook message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Notebook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Notebook} Notebook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Notebook.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Notebook();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.fileName = reader.string();
                        break;
                    }
                case 6: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 7: {
                        message.notebookContents = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Notebook message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Notebook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Notebook} Notebook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Notebook.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Notebook message.
         * @function verify
         * @memberof dataform.Notebook
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Notebook.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.notebookContents != null && message.hasOwnProperty("notebookContents"))
                if (!$util.isString(message.notebookContents))
                    return "notebookContents: string expected";
            return null;
        };

        /**
         * Creates a Notebook message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Notebook
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Notebook} Notebook
         */
        Notebook.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Notebook)
                return object;
            let message = new $root.dataform.Notebook();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Notebook.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Notebook.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Notebook.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Notebook.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Notebook.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.notebookContents != null)
                message.notebookContents = String(object.notebookContents);
            return message;
        };

        /**
         * Creates a plain object from a Notebook message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Notebook
         * @static
         * @param {dataform.Notebook} message Notebook
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Notebook.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.target = null;
                object.canonicalTarget = null;
                object.fileName = "";
                object.disabled = false;
                object.notebookContents = "";
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.notebookContents != null && message.hasOwnProperty("notebookContents"))
                object.notebookContents = message.notebookContents;
            return object;
        };

        /**
         * Converts this Notebook to JSON.
         * @function toJSON
         * @memberof dataform.Notebook
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Notebook.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Notebook
         * @function getTypeUrl
         * @memberof dataform.Notebook
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Notebook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Notebook";
        };

        return Notebook;
    })();

    dataform.NotebookRuntimeOptions = (function() {

        /**
         * Properties of a NotebookRuntimeOptions.
         * @memberof dataform
         * @interface INotebookRuntimeOptions
         * @property {string|null} [outputBucket] NotebookRuntimeOptions outputBucket
         * @property {string|null} [runtimeTemplateName] NotebookRuntimeOptions runtimeTemplateName
         */

        /**
         * Constructs a new NotebookRuntimeOptions.
         * @memberof dataform
         * @classdesc Represents a NotebookRuntimeOptions.
         * @implements INotebookRuntimeOptions
         * @constructor
         * @param {dataform.INotebookRuntimeOptions=} [properties] Properties to set
         */
        function NotebookRuntimeOptions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NotebookRuntimeOptions outputBucket.
         * @member {string|null|undefined} outputBucket
         * @memberof dataform.NotebookRuntimeOptions
         * @instance
         */
        NotebookRuntimeOptions.prototype.outputBucket = null;

        /**
         * NotebookRuntimeOptions runtimeTemplateName.
         * @member {string} runtimeTemplateName
         * @memberof dataform.NotebookRuntimeOptions
         * @instance
         */
        NotebookRuntimeOptions.prototype.runtimeTemplateName = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * NotebookRuntimeOptions outputSink.
         * @member {"outputBucket"|undefined} outputSink
         * @memberof dataform.NotebookRuntimeOptions
         * @instance
         */
        Object.defineProperty(NotebookRuntimeOptions.prototype, "outputSink", {
            get: $util.oneOfGetter($oneOfFields = ["outputBucket"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new NotebookRuntimeOptions instance using the specified properties.
         * @function create
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {dataform.INotebookRuntimeOptions=} [properties] Properties to set
         * @returns {dataform.NotebookRuntimeOptions} NotebookRuntimeOptions instance
         */
        NotebookRuntimeOptions.create = function create(properties) {
            return new NotebookRuntimeOptions(properties);
        };

        /**
         * Encodes the specified NotebookRuntimeOptions message. Does not implicitly {@link dataform.NotebookRuntimeOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {dataform.INotebookRuntimeOptions} message NotebookRuntimeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotebookRuntimeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outputBucket != null && Object.hasOwnProperty.call(message, "outputBucket"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.outputBucket);
            if (message.runtimeTemplateName != null && Object.hasOwnProperty.call(message, "runtimeTemplateName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.runtimeTemplateName);
            return writer;
        };

        /**
         * Encodes the specified NotebookRuntimeOptions message, length delimited. Does not implicitly {@link dataform.NotebookRuntimeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {dataform.INotebookRuntimeOptions} message NotebookRuntimeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NotebookRuntimeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NotebookRuntimeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.NotebookRuntimeOptions} NotebookRuntimeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotebookRuntimeOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.NotebookRuntimeOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.outputBucket = reader.string();
                        break;
                    }
                case 2: {
                        message.runtimeTemplateName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NotebookRuntimeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.NotebookRuntimeOptions} NotebookRuntimeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NotebookRuntimeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NotebookRuntimeOptions message.
         * @function verify
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NotebookRuntimeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outputBucket != null && message.hasOwnProperty("outputBucket")) {
                if (!$util.isString(message.outputBucket))
                    return "outputBucket: string expected";
            }
            if (message.runtimeTemplateName != null && message.hasOwnProperty("runtimeTemplateName"))
                if (!$util.isString(message.runtimeTemplateName))
                    return "runtimeTemplateName: string expected";
            return null;
        };

        /**
         * Creates a NotebookRuntimeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.NotebookRuntimeOptions} NotebookRuntimeOptions
         */
        NotebookRuntimeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.NotebookRuntimeOptions)
                return object;
            let message = new $root.dataform.NotebookRuntimeOptions();
            if (object.outputBucket != null)
                message.outputBucket = String(object.outputBucket);
            if (object.runtimeTemplateName != null)
                message.runtimeTemplateName = String(object.runtimeTemplateName);
            return message;
        };

        /**
         * Creates a plain object from a NotebookRuntimeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {dataform.NotebookRuntimeOptions} message NotebookRuntimeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NotebookRuntimeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.runtimeTemplateName = "";
            if (message.outputBucket != null && message.hasOwnProperty("outputBucket")) {
                object.outputBucket = message.outputBucket;
                if (options.oneofs)
                    object.outputSink = "outputBucket";
            }
            if (message.runtimeTemplateName != null && message.hasOwnProperty("runtimeTemplateName"))
                object.runtimeTemplateName = message.runtimeTemplateName;
            return object;
        };

        /**
         * Converts this NotebookRuntimeOptions to JSON.
         * @function toJSON
         * @memberof dataform.NotebookRuntimeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NotebookRuntimeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for NotebookRuntimeOptions
         * @function getTypeUrl
         * @memberof dataform.NotebookRuntimeOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        NotebookRuntimeOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.NotebookRuntimeOptions";
        };

        return NotebookRuntimeOptions;
    })();

    dataform.DataPreparation = (function() {

        /**
         * Properties of a DataPreparation.
         * @memberof dataform
         * @interface IDataPreparation
         * @property {dataform.ITarget|null} [target] DataPreparation target
         * @property {dataform.ITarget|null} [canonicalTarget] DataPreparation canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [targets] DataPreparation targets
         * @property {Array.<dataform.ITarget>|null} [canonicalTargets] DataPreparation canonicalTargets
         * @property {Array.<string>|null} [tags] DataPreparation tags
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] DataPreparation dependencyTargets
         * @property {string|null} [fileName] DataPreparation fileName
         * @property {boolean|null} [disabled] DataPreparation disabled
         * @property {string|null} [dataPreparationYaml] DataPreparation dataPreparationYaml
         * @property {string|null} [query] DataPreparation query
         * @property {dataform.ITarget|null} [errorTable] DataPreparation errorTable
         * @property {number|null} [errorTableRetentionDays] DataPreparation errorTableRetentionDays
         * @property {dataform.ILoadConfiguration|null} [load] DataPreparation load
         */

        /**
         * Constructs a new DataPreparation.
         * @memberof dataform
         * @classdesc Represents a DataPreparation.
         * @implements IDataPreparation
         * @constructor
         * @param {dataform.IDataPreparation=} [properties] Properties to set
         */
        function DataPreparation(properties) {
            this.targets = [];
            this.canonicalTargets = [];
            this.tags = [];
            this.dependencyTargets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataPreparation target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.target = null;

        /**
         * DataPreparation canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.canonicalTarget = null;

        /**
         * DataPreparation targets.
         * @member {Array.<dataform.ITarget>} targets
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.targets = $util.emptyArray;

        /**
         * DataPreparation canonicalTargets.
         * @member {Array.<dataform.ITarget>} canonicalTargets
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.canonicalTargets = $util.emptyArray;

        /**
         * DataPreparation tags.
         * @member {Array.<string>} tags
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.tags = $util.emptyArray;

        /**
         * DataPreparation dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.dependencyTargets = $util.emptyArray;

        /**
         * DataPreparation fileName.
         * @member {string} fileName
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.fileName = "";

        /**
         * DataPreparation disabled.
         * @member {boolean} disabled
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.disabled = false;

        /**
         * DataPreparation dataPreparationYaml.
         * @member {string|null|undefined} dataPreparationYaml
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.dataPreparationYaml = null;

        /**
         * DataPreparation query.
         * @member {string|null|undefined} query
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.query = null;

        /**
         * DataPreparation errorTable.
         * @member {dataform.ITarget|null|undefined} errorTable
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.errorTable = null;

        /**
         * DataPreparation errorTableRetentionDays.
         * @member {number} errorTableRetentionDays
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.errorTableRetentionDays = 0;

        /**
         * DataPreparation load.
         * @member {dataform.ILoadConfiguration|null|undefined} load
         * @memberof dataform.DataPreparation
         * @instance
         */
        DataPreparation.prototype.load = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * DataPreparation definition.
         * @member {"dataPreparationYaml"|"query"|undefined} definition
         * @memberof dataform.DataPreparation
         * @instance
         */
        Object.defineProperty(DataPreparation.prototype, "definition", {
            get: $util.oneOfGetter($oneOfFields = ["dataPreparationYaml", "query"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new DataPreparation instance using the specified properties.
         * @function create
         * @memberof dataform.DataPreparation
         * @static
         * @param {dataform.IDataPreparation=} [properties] Properties to set
         * @returns {dataform.DataPreparation} DataPreparation instance
         */
        DataPreparation.create = function create(properties) {
            return new DataPreparation(properties);
        };

        /**
         * Encodes the specified DataPreparation message. Does not implicitly {@link dataform.DataPreparation.verify|verify} messages.
         * @function encode
         * @memberof dataform.DataPreparation
         * @static
         * @param {dataform.IDataPreparation} message DataPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataPreparation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.dataform.Target.encode(message.targets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.canonicalTargets != null && message.canonicalTargets.length)
                for (let i = 0; i < message.canonicalTargets.length; ++i)
                    $root.dataform.Target.encode(message.canonicalTargets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tags[i]);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileName);
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.dataPreparationYaml != null && Object.hasOwnProperty.call(message, "dataPreparationYaml"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.dataPreparationYaml);
            if (message.errorTable != null && Object.hasOwnProperty.call(message, "errorTable"))
                $root.dataform.Target.encode(message.errorTable, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.errorTableRetentionDays != null && Object.hasOwnProperty.call(message, "errorTableRetentionDays"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.errorTableRetentionDays);
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.query);
            if (message.load != null && Object.hasOwnProperty.call(message, "load"))
                $root.dataform.LoadConfiguration.encode(message.load, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DataPreparation message, length delimited. Does not implicitly {@link dataform.DataPreparation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.DataPreparation
         * @static
         * @param {dataform.IDataPreparation} message DataPreparation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataPreparation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataPreparation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.DataPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.DataPreparation} DataPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataPreparation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.DataPreparation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 8: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 1: {
                        if (!(message.targets && message.targets.length))
                            message.targets = [];
                        message.targets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.canonicalTargets && message.canonicalTargets.length))
                            message.canonicalTargets = [];
                        message.canonicalTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 4: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.fileName = reader.string();
                        break;
                    }
                case 6: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 11: {
                        message.dataPreparationYaml = reader.string();
                        break;
                    }
                case 15: {
                        message.query = reader.string();
                        break;
                    }
                case 12: {
                        message.errorTable = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.errorTableRetentionDays = reader.int32();
                        break;
                    }
                case 16: {
                        message.load = $root.dataform.LoadConfiguration.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataPreparation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.DataPreparation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.DataPreparation} DataPreparation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataPreparation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataPreparation message.
         * @function verify
         * @memberof dataform.DataPreparation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataPreparation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            if (message.canonicalTargets != null && message.hasOwnProperty("canonicalTargets")) {
                if (!Array.isArray(message.canonicalTargets))
                    return "canonicalTargets: array expected";
                for (let i = 0; i < message.canonicalTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.canonicalTargets[i]);
                    if (error)
                        return "canonicalTargets." + error;
                }
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.dataPreparationYaml != null && message.hasOwnProperty("dataPreparationYaml")) {
                properties.definition = 1;
                if (!$util.isString(message.dataPreparationYaml))
                    return "dataPreparationYaml: string expected";
            }
            if (message.query != null && message.hasOwnProperty("query")) {
                if (properties.definition === 1)
                    return "definition: multiple values";
                properties.definition = 1;
                if (!$util.isString(message.query))
                    return "query: string expected";
            }
            if (message.errorTable != null && message.hasOwnProperty("errorTable")) {
                let error = $root.dataform.Target.verify(message.errorTable);
                if (error)
                    return "errorTable." + error;
            }
            if (message.errorTableRetentionDays != null && message.hasOwnProperty("errorTableRetentionDays"))
                if (!$util.isInteger(message.errorTableRetentionDays))
                    return "errorTableRetentionDays: integer expected";
            if (message.load != null && message.hasOwnProperty("load")) {
                let error = $root.dataform.LoadConfiguration.verify(message.load);
                if (error)
                    return "load." + error;
            }
            return null;
        };

        /**
         * Creates a DataPreparation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.DataPreparation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.DataPreparation} DataPreparation
         */
        DataPreparation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.DataPreparation)
                return object;
            let message = new $root.dataform.DataPreparation();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.DataPreparation.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.DataPreparation.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".dataform.DataPreparation.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".dataform.DataPreparation.targets: object expected");
                    message.targets[i] = $root.dataform.Target.fromObject(object.targets[i]);
                }
            }
            if (object.canonicalTargets) {
                if (!Array.isArray(object.canonicalTargets))
                    throw TypeError(".dataform.DataPreparation.canonicalTargets: array expected");
                message.canonicalTargets = [];
                for (let i = 0; i < object.canonicalTargets.length; ++i) {
                    if (typeof object.canonicalTargets[i] !== "object")
                        throw TypeError(".dataform.DataPreparation.canonicalTargets: object expected");
                    message.canonicalTargets[i] = $root.dataform.Target.fromObject(object.canonicalTargets[i]);
                }
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.DataPreparation.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.DataPreparation.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.DataPreparation.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.dataPreparationYaml != null)
                message.dataPreparationYaml = String(object.dataPreparationYaml);
            if (object.query != null)
                message.query = String(object.query);
            if (object.errorTable != null) {
                if (typeof object.errorTable !== "object")
                    throw TypeError(".dataform.DataPreparation.errorTable: object expected");
                message.errorTable = $root.dataform.Target.fromObject(object.errorTable);
            }
            if (object.errorTableRetentionDays != null)
                message.errorTableRetentionDays = object.errorTableRetentionDays | 0;
            if (object.load != null) {
                if (typeof object.load !== "object")
                    throw TypeError(".dataform.DataPreparation.load: object expected");
                message.load = $root.dataform.LoadConfiguration.fromObject(object.load);
            }
            return message;
        };

        /**
         * Creates a plain object from a DataPreparation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.DataPreparation
         * @static
         * @param {dataform.DataPreparation} message DataPreparation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataPreparation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.targets = [];
                object.canonicalTargets = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.fileName = "";
                object.disabled = false;
                object.target = null;
                object.canonicalTarget = null;
                object.errorTable = null;
                object.errorTableRetentionDays = 0;
                object.load = null;
            }
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.dataform.Target.toObject(message.targets[j], options);
            }
            if (message.canonicalTargets && message.canonicalTargets.length) {
                object.canonicalTargets = [];
                for (let j = 0; j < message.canonicalTargets.length; ++j)
                    object.canonicalTargets[j] = $root.dataform.Target.toObject(message.canonicalTargets[j], options);
            }
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.dataPreparationYaml != null && message.hasOwnProperty("dataPreparationYaml")) {
                object.dataPreparationYaml = message.dataPreparationYaml;
                if (options.oneofs)
                    object.definition = "dataPreparationYaml";
            }
            if (message.errorTable != null && message.hasOwnProperty("errorTable"))
                object.errorTable = $root.dataform.Target.toObject(message.errorTable, options);
            if (message.errorTableRetentionDays != null && message.hasOwnProperty("errorTableRetentionDays"))
                object.errorTableRetentionDays = message.errorTableRetentionDays;
            if (message.query != null && message.hasOwnProperty("query")) {
                object.query = message.query;
                if (options.oneofs)
                    object.definition = "query";
            }
            if (message.load != null && message.hasOwnProperty("load"))
                object.load = $root.dataform.LoadConfiguration.toObject(message.load, options);
            return object;
        };

        /**
         * Converts this DataPreparation to JSON.
         * @function toJSON
         * @memberof dataform.DataPreparation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataPreparation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DataPreparation
         * @function getTypeUrl
         * @memberof dataform.DataPreparation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DataPreparation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.DataPreparation";
        };

        return DataPreparation;
    })();

    dataform.LoadConfiguration = (function() {

        /**
         * Properties of a LoadConfiguration.
         * @memberof dataform
         * @interface ILoadConfiguration
         * @property {dataform.ISimpleLoadMode|null} [replace] LoadConfiguration replace
         * @property {dataform.ISimpleLoadMode|null} [append] LoadConfiguration append
         * @property {dataform.IIncrementalLoadMode|null} [maximum] LoadConfiguration maximum
         * @property {dataform.IIncrementalLoadMode|null} [unique] LoadConfiguration unique
         * @property {dataform.IIncrementalLoadMode|null} [automatic] LoadConfiguration automatic
         */

        /**
         * Constructs a new LoadConfiguration.
         * @memberof dataform
         * @classdesc Represents a LoadConfiguration.
         * @implements ILoadConfiguration
         * @constructor
         * @param {dataform.ILoadConfiguration=} [properties] Properties to set
         */
        function LoadConfiguration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoadConfiguration replace.
         * @member {dataform.ISimpleLoadMode|null|undefined} replace
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        LoadConfiguration.prototype.replace = null;

        /**
         * LoadConfiguration append.
         * @member {dataform.ISimpleLoadMode|null|undefined} append
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        LoadConfiguration.prototype.append = null;

        /**
         * LoadConfiguration maximum.
         * @member {dataform.IIncrementalLoadMode|null|undefined} maximum
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        LoadConfiguration.prototype.maximum = null;

        /**
         * LoadConfiguration unique.
         * @member {dataform.IIncrementalLoadMode|null|undefined} unique
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        LoadConfiguration.prototype.unique = null;

        /**
         * LoadConfiguration automatic.
         * @member {dataform.IIncrementalLoadMode|null|undefined} automatic
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        LoadConfiguration.prototype.automatic = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * LoadConfiguration mode.
         * @member {"replace"|"append"|"maximum"|"unique"|"automatic"|undefined} mode
         * @memberof dataform.LoadConfiguration
         * @instance
         */
        Object.defineProperty(LoadConfiguration.prototype, "mode", {
            get: $util.oneOfGetter($oneOfFields = ["replace", "append", "maximum", "unique", "automatic"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new LoadConfiguration instance using the specified properties.
         * @function create
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {dataform.ILoadConfiguration=} [properties] Properties to set
         * @returns {dataform.LoadConfiguration} LoadConfiguration instance
         */
        LoadConfiguration.create = function create(properties) {
            return new LoadConfiguration(properties);
        };

        /**
         * Encodes the specified LoadConfiguration message. Does not implicitly {@link dataform.LoadConfiguration.verify|verify} messages.
         * @function encode
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {dataform.ILoadConfiguration} message LoadConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.replace != null && Object.hasOwnProperty.call(message, "replace"))
                $root.dataform.SimpleLoadMode.encode(message.replace, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.append != null && Object.hasOwnProperty.call(message, "append"))
                $root.dataform.SimpleLoadMode.encode(message.append, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.maximum != null && Object.hasOwnProperty.call(message, "maximum"))
                $root.dataform.IncrementalLoadMode.encode(message.maximum, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.unique != null && Object.hasOwnProperty.call(message, "unique"))
                $root.dataform.IncrementalLoadMode.encode(message.unique, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.automatic != null && Object.hasOwnProperty.call(message, "automatic"))
                $root.dataform.IncrementalLoadMode.encode(message.automatic, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LoadConfiguration message, length delimited. Does not implicitly {@link dataform.LoadConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {dataform.ILoadConfiguration} message LoadConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoadConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.LoadConfiguration} LoadConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.LoadConfiguration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.replace = $root.dataform.SimpleLoadMode.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.append = $root.dataform.SimpleLoadMode.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.maximum = $root.dataform.IncrementalLoadMode.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.unique = $root.dataform.IncrementalLoadMode.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.automatic = $root.dataform.IncrementalLoadMode.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoadConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.LoadConfiguration} LoadConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoadConfiguration message.
         * @function verify
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoadConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.replace != null && message.hasOwnProperty("replace")) {
                properties.mode = 1;
                {
                    let error = $root.dataform.SimpleLoadMode.verify(message.replace);
                    if (error)
                        return "replace." + error;
                }
            }
            if (message.append != null && message.hasOwnProperty("append")) {
                if (properties.mode === 1)
                    return "mode: multiple values";
                properties.mode = 1;
                {
                    let error = $root.dataform.SimpleLoadMode.verify(message.append);
                    if (error)
                        return "append." + error;
                }
            }
            if (message.maximum != null && message.hasOwnProperty("maximum")) {
                if (properties.mode === 1)
                    return "mode: multiple values";
                properties.mode = 1;
                {
                    let error = $root.dataform.IncrementalLoadMode.verify(message.maximum);
                    if (error)
                        return "maximum." + error;
                }
            }
            if (message.unique != null && message.hasOwnProperty("unique")) {
                if (properties.mode === 1)
                    return "mode: multiple values";
                properties.mode = 1;
                {
                    let error = $root.dataform.IncrementalLoadMode.verify(message.unique);
                    if (error)
                        return "unique." + error;
                }
            }
            if (message.automatic != null && message.hasOwnProperty("automatic")) {
                if (properties.mode === 1)
                    return "mode: multiple values";
                properties.mode = 1;
                {
                    let error = $root.dataform.IncrementalLoadMode.verify(message.automatic);
                    if (error)
                        return "automatic." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LoadConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.LoadConfiguration} LoadConfiguration
         */
        LoadConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.LoadConfiguration)
                return object;
            let message = new $root.dataform.LoadConfiguration();
            if (object.replace != null) {
                if (typeof object.replace !== "object")
                    throw TypeError(".dataform.LoadConfiguration.replace: object expected");
                message.replace = $root.dataform.SimpleLoadMode.fromObject(object.replace);
            }
            if (object.append != null) {
                if (typeof object.append !== "object")
                    throw TypeError(".dataform.LoadConfiguration.append: object expected");
                message.append = $root.dataform.SimpleLoadMode.fromObject(object.append);
            }
            if (object.maximum != null) {
                if (typeof object.maximum !== "object")
                    throw TypeError(".dataform.LoadConfiguration.maximum: object expected");
                message.maximum = $root.dataform.IncrementalLoadMode.fromObject(object.maximum);
            }
            if (object.unique != null) {
                if (typeof object.unique !== "object")
                    throw TypeError(".dataform.LoadConfiguration.unique: object expected");
                message.unique = $root.dataform.IncrementalLoadMode.fromObject(object.unique);
            }
            if (object.automatic != null) {
                if (typeof object.automatic !== "object")
                    throw TypeError(".dataform.LoadConfiguration.automatic: object expected");
                message.automatic = $root.dataform.IncrementalLoadMode.fromObject(object.automatic);
            }
            return message;
        };

        /**
         * Creates a plain object from a LoadConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {dataform.LoadConfiguration} message LoadConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoadConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.replace != null && message.hasOwnProperty("replace")) {
                object.replace = $root.dataform.SimpleLoadMode.toObject(message.replace, options);
                if (options.oneofs)
                    object.mode = "replace";
            }
            if (message.append != null && message.hasOwnProperty("append")) {
                object.append = $root.dataform.SimpleLoadMode.toObject(message.append, options);
                if (options.oneofs)
                    object.mode = "append";
            }
            if (message.maximum != null && message.hasOwnProperty("maximum")) {
                object.maximum = $root.dataform.IncrementalLoadMode.toObject(message.maximum, options);
                if (options.oneofs)
                    object.mode = "maximum";
            }
            if (message.unique != null && message.hasOwnProperty("unique")) {
                object.unique = $root.dataform.IncrementalLoadMode.toObject(message.unique, options);
                if (options.oneofs)
                    object.mode = "unique";
            }
            if (message.automatic != null && message.hasOwnProperty("automatic")) {
                object.automatic = $root.dataform.IncrementalLoadMode.toObject(message.automatic, options);
                if (options.oneofs)
                    object.mode = "automatic";
            }
            return object;
        };

        /**
         * Converts this LoadConfiguration to JSON.
         * @function toJSON
         * @memberof dataform.LoadConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoadConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LoadConfiguration
         * @function getTypeUrl
         * @memberof dataform.LoadConfiguration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LoadConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.LoadConfiguration";
        };

        return LoadConfiguration;
    })();

    dataform.SimpleLoadMode = (function() {

        /**
         * Properties of a SimpleLoadMode.
         * @memberof dataform
         * @interface ISimpleLoadMode
         */

        /**
         * Constructs a new SimpleLoadMode.
         * @memberof dataform
         * @classdesc Represents a SimpleLoadMode.
         * @implements ISimpleLoadMode
         * @constructor
         * @param {dataform.ISimpleLoadMode=} [properties] Properties to set
         */
        function SimpleLoadMode(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SimpleLoadMode instance using the specified properties.
         * @function create
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {dataform.ISimpleLoadMode=} [properties] Properties to set
         * @returns {dataform.SimpleLoadMode} SimpleLoadMode instance
         */
        SimpleLoadMode.create = function create(properties) {
            return new SimpleLoadMode(properties);
        };

        /**
         * Encodes the specified SimpleLoadMode message. Does not implicitly {@link dataform.SimpleLoadMode.verify|verify} messages.
         * @function encode
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {dataform.ISimpleLoadMode} message SimpleLoadMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleLoadMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SimpleLoadMode message, length delimited. Does not implicitly {@link dataform.SimpleLoadMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {dataform.ISimpleLoadMode} message SimpleLoadMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleLoadMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleLoadMode message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SimpleLoadMode} SimpleLoadMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleLoadMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SimpleLoadMode();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleLoadMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SimpleLoadMode} SimpleLoadMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleLoadMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleLoadMode message.
         * @function verify
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleLoadMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SimpleLoadMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SimpleLoadMode} SimpleLoadMode
         */
        SimpleLoadMode.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SimpleLoadMode)
                return object;
            return new $root.dataform.SimpleLoadMode();
        };

        /**
         * Creates a plain object from a SimpleLoadMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {dataform.SimpleLoadMode} message SimpleLoadMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleLoadMode.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SimpleLoadMode to JSON.
         * @function toJSON
         * @memberof dataform.SimpleLoadMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleLoadMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimpleLoadMode
         * @function getTypeUrl
         * @memberof dataform.SimpleLoadMode
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimpleLoadMode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.SimpleLoadMode";
        };

        return SimpleLoadMode;
    })();

    dataform.IncrementalLoadMode = (function() {

        /**
         * Properties of an IncrementalLoadMode.
         * @memberof dataform
         * @interface IIncrementalLoadMode
         * @property {string|null} [columnName] IncrementalLoadMode columnName
         */

        /**
         * Constructs a new IncrementalLoadMode.
         * @memberof dataform
         * @classdesc Represents an IncrementalLoadMode.
         * @implements IIncrementalLoadMode
         * @constructor
         * @param {dataform.IIncrementalLoadMode=} [properties] Properties to set
         */
        function IncrementalLoadMode(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IncrementalLoadMode columnName.
         * @member {string} columnName
         * @memberof dataform.IncrementalLoadMode
         * @instance
         */
        IncrementalLoadMode.prototype.columnName = "";

        /**
         * Creates a new IncrementalLoadMode instance using the specified properties.
         * @function create
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {dataform.IIncrementalLoadMode=} [properties] Properties to set
         * @returns {dataform.IncrementalLoadMode} IncrementalLoadMode instance
         */
        IncrementalLoadMode.create = function create(properties) {
            return new IncrementalLoadMode(properties);
        };

        /**
         * Encodes the specified IncrementalLoadMode message. Does not implicitly {@link dataform.IncrementalLoadMode.verify|verify} messages.
         * @function encode
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {dataform.IIncrementalLoadMode} message IncrementalLoadMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncrementalLoadMode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.columnName != null && Object.hasOwnProperty.call(message, "columnName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.columnName);
            return writer;
        };

        /**
         * Encodes the specified IncrementalLoadMode message, length delimited. Does not implicitly {@link dataform.IncrementalLoadMode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {dataform.IIncrementalLoadMode} message IncrementalLoadMode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IncrementalLoadMode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IncrementalLoadMode message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.IncrementalLoadMode} IncrementalLoadMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncrementalLoadMode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.IncrementalLoadMode();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.columnName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IncrementalLoadMode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.IncrementalLoadMode} IncrementalLoadMode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IncrementalLoadMode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IncrementalLoadMode message.
         * @function verify
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IncrementalLoadMode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.columnName != null && message.hasOwnProperty("columnName"))
                if (!$util.isString(message.columnName))
                    return "columnName: string expected";
            return null;
        };

        /**
         * Creates an IncrementalLoadMode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.IncrementalLoadMode} IncrementalLoadMode
         */
        IncrementalLoadMode.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.IncrementalLoadMode)
                return object;
            let message = new $root.dataform.IncrementalLoadMode();
            if (object.columnName != null)
                message.columnName = String(object.columnName);
            return message;
        };

        /**
         * Creates a plain object from an IncrementalLoadMode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {dataform.IncrementalLoadMode} message IncrementalLoadMode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IncrementalLoadMode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.columnName = "";
            if (message.columnName != null && message.hasOwnProperty("columnName"))
                object.columnName = message.columnName;
            return object;
        };

        /**
         * Converts this IncrementalLoadMode to JSON.
         * @function toJSON
         * @memberof dataform.IncrementalLoadMode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IncrementalLoadMode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for IncrementalLoadMode
         * @function getTypeUrl
         * @memberof dataform.IncrementalLoadMode
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        IncrementalLoadMode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.IncrementalLoadMode";
        };

        return IncrementalLoadMode;
    })();

    dataform.CompiledGraph = (function() {

        /**
         * Properties of a CompiledGraph.
         * @memberof dataform
         * @interface ICompiledGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] CompiledGraph projectConfig
         * @property {Array.<dataform.ITable>|null} [tables] CompiledGraph tables
         * @property {Array.<dataform.IOperation>|null} [operations] CompiledGraph operations
         * @property {Array.<dataform.IAssertion>|null} [assertions] CompiledGraph assertions
         * @property {Array.<dataform.IDeclaration>|null} [declarations] CompiledGraph declarations
         * @property {Array.<dataform.ITest>|null} [tests] CompiledGraph tests
         * @property {Array.<dataform.INotebook>|null} [notebooks] CompiledGraph notebooks
         * @property {Array.<dataform.IDataPreparation>|null} [dataPreparations] CompiledGraph dataPreparations
         * @property {dataform.IGraphErrors|null} [graphErrors] CompiledGraph graphErrors
         * @property {string|null} [dataformCoreVersion] CompiledGraph dataformCoreVersion
         * @property {Array.<dataform.ITarget>|null} [targets] CompiledGraph targets
         */

        /**
         * Constructs a new CompiledGraph.
         * @memberof dataform
         * @classdesc Represents a CompiledGraph.
         * @implements ICompiledGraph
         * @constructor
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         */
        function CompiledGraph(properties) {
            this.tables = [];
            this.operations = [];
            this.assertions = [];
            this.declarations = [];
            this.tests = [];
            this.notebooks = [];
            this.dataPreparations = [];
            this.targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompiledGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.projectConfig = null;

        /**
         * CompiledGraph tables.
         * @member {Array.<dataform.ITable>} tables
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tables = $util.emptyArray;

        /**
         * CompiledGraph operations.
         * @member {Array.<dataform.IOperation>} operations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.operations = $util.emptyArray;

        /**
         * CompiledGraph assertions.
         * @member {Array.<dataform.IAssertion>} assertions
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.assertions = $util.emptyArray;

        /**
         * CompiledGraph declarations.
         * @member {Array.<dataform.IDeclaration>} declarations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.declarations = $util.emptyArray;

        /**
         * CompiledGraph tests.
         * @member {Array.<dataform.ITest>} tests
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tests = $util.emptyArray;

        /**
         * CompiledGraph notebooks.
         * @member {Array.<dataform.INotebook>} notebooks
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.notebooks = $util.emptyArray;

        /**
         * CompiledGraph dataPreparations.
         * @member {Array.<dataform.IDataPreparation>} dataPreparations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.dataPreparations = $util.emptyArray;

        /**
         * CompiledGraph graphErrors.
         * @member {dataform.IGraphErrors|null|undefined} graphErrors
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.graphErrors = null;

        /**
         * CompiledGraph dataformCoreVersion.
         * @member {string} dataformCoreVersion
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.dataformCoreVersion = "";

        /**
         * CompiledGraph targets.
         * @member {Array.<dataform.ITarget>} targets
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.targets = $util.emptyArray;

        /**
         * Creates a new CompiledGraph instance using the specified properties.
         * @function create
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         * @returns {dataform.CompiledGraph} CompiledGraph instance
         */
        CompiledGraph.create = function create(properties) {
            return new CompiledGraph(properties);
        };

        /**
         * Encodes the specified CompiledGraph message. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.Table.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.operations != null && message.operations.length)
                for (let i = 0; i < message.operations.length; ++i)
                    $root.dataform.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assertions != null && message.assertions.length)
                for (let i = 0; i < message.assertions.length; ++i)
                    $root.dataform.Assertion.encode(message.assertions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.projectConfig != null && Object.hasOwnProperty.call(message, "projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.graphErrors != null && Object.hasOwnProperty.call(message, "graphErrors"))
                $root.dataform.GraphErrors.encode(message.graphErrors, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tests != null && message.tests.length)
                for (let i = 0; i < message.tests.length; ++i)
                    $root.dataform.Test.encode(message.tests[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.declarations != null && message.declarations.length)
                for (let i = 0; i < message.declarations.length; ++i)
                    $root.dataform.Declaration.encode(message.declarations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.dataformCoreVersion != null && Object.hasOwnProperty.call(message, "dataformCoreVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.dataformCoreVersion);
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.dataform.Target.encode(message.targets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.notebooks != null && message.notebooks.length)
                for (let i = 0; i < message.notebooks.length; ++i)
                    $root.dataform.Notebook.encode(message.notebooks[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.dataPreparations != null && message.dataPreparations.length)
                for (let i = 0; i < message.dataPreparations.length; ++i)
                    $root.dataform.DataPreparation.encode(message.dataPreparations[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompiledGraph message, length delimited. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompiledGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4: {
                        message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 1: {
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.dataform.Table.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.dataform.Operation.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.assertions && message.assertions.length))
                            message.assertions = [];
                        message.assertions.push($root.dataform.Assertion.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.declarations && message.declarations.length))
                            message.declarations = [];
                        message.declarations.push($root.dataform.Declaration.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.tests && message.tests.length))
                            message.tests = [];
                        message.tests.push($root.dataform.Test.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        if (!(message.notebooks && message.notebooks.length))
                            message.notebooks = [];
                        message.notebooks.push($root.dataform.Notebook.decode(reader, reader.uint32()));
                        break;
                    }
                case 13: {
                        if (!(message.dataPreparations && message.dataPreparations.length))
                            message.dataPreparations = [];
                        message.dataPreparations.push($root.dataform.DataPreparation.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.graphErrors = $root.dataform.GraphErrors.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.dataformCoreVersion = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.targets && message.targets.length))
                            message.targets = [];
                        message.targets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompiledGraph message.
         * @function verify
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompiledGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.Table.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (let i = 0; i < message.operations.length; ++i) {
                    let error = $root.dataform.Operation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            if (message.assertions != null && message.hasOwnProperty("assertions")) {
                if (!Array.isArray(message.assertions))
                    return "assertions: array expected";
                for (let i = 0; i < message.assertions.length; ++i) {
                    let error = $root.dataform.Assertion.verify(message.assertions[i]);
                    if (error)
                        return "assertions." + error;
                }
            }
            if (message.declarations != null && message.hasOwnProperty("declarations")) {
                if (!Array.isArray(message.declarations))
                    return "declarations: array expected";
                for (let i = 0; i < message.declarations.length; ++i) {
                    let error = $root.dataform.Declaration.verify(message.declarations[i]);
                    if (error)
                        return "declarations." + error;
                }
            }
            if (message.tests != null && message.hasOwnProperty("tests")) {
                if (!Array.isArray(message.tests))
                    return "tests: array expected";
                for (let i = 0; i < message.tests.length; ++i) {
                    let error = $root.dataform.Test.verify(message.tests[i]);
                    if (error)
                        return "tests." + error;
                }
            }
            if (message.notebooks != null && message.hasOwnProperty("notebooks")) {
                if (!Array.isArray(message.notebooks))
                    return "notebooks: array expected";
                for (let i = 0; i < message.notebooks.length; ++i) {
                    let error = $root.dataform.Notebook.verify(message.notebooks[i]);
                    if (error)
                        return "notebooks." + error;
                }
            }
            if (message.dataPreparations != null && message.hasOwnProperty("dataPreparations")) {
                if (!Array.isArray(message.dataPreparations))
                    return "dataPreparations: array expected";
                for (let i = 0; i < message.dataPreparations.length; ++i) {
                    let error = $root.dataform.DataPreparation.verify(message.dataPreparations[i]);
                    if (error)
                        return "dataPreparations." + error;
                }
            }
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors")) {
                let error = $root.dataform.GraphErrors.verify(message.graphErrors);
                if (error)
                    return "graphErrors." + error;
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                if (!$util.isString(message.dataformCoreVersion))
                    return "dataformCoreVersion: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CompiledGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompiledGraph} CompiledGraph
         */
        CompiledGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompiledGraph)
                return object;
            let message = new $root.dataform.CompiledGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.CompiledGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.CompiledGraph.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tables: object expected");
                    message.tables[i] = $root.dataform.Table.fromObject(object.tables[i]);
                }
            }
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".dataform.CompiledGraph.operations: array expected");
                message.operations = [];
                for (let i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.operations: object expected");
                    message.operations[i] = $root.dataform.Operation.fromObject(object.operations[i]);
                }
            }
            if (object.assertions) {
                if (!Array.isArray(object.assertions))
                    throw TypeError(".dataform.CompiledGraph.assertions: array expected");
                message.assertions = [];
                for (let i = 0; i < object.assertions.length; ++i) {
                    if (typeof object.assertions[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.assertions: object expected");
                    message.assertions[i] = $root.dataform.Assertion.fromObject(object.assertions[i]);
                }
            }
            if (object.declarations) {
                if (!Array.isArray(object.declarations))
                    throw TypeError(".dataform.CompiledGraph.declarations: array expected");
                message.declarations = [];
                for (let i = 0; i < object.declarations.length; ++i) {
                    if (typeof object.declarations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.declarations: object expected");
                    message.declarations[i] = $root.dataform.Declaration.fromObject(object.declarations[i]);
                }
            }
            if (object.tests) {
                if (!Array.isArray(object.tests))
                    throw TypeError(".dataform.CompiledGraph.tests: array expected");
                message.tests = [];
                for (let i = 0; i < object.tests.length; ++i) {
                    if (typeof object.tests[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tests: object expected");
                    message.tests[i] = $root.dataform.Test.fromObject(object.tests[i]);
                }
            }
            if (object.notebooks) {
                if (!Array.isArray(object.notebooks))
                    throw TypeError(".dataform.CompiledGraph.notebooks: array expected");
                message.notebooks = [];
                for (let i = 0; i < object.notebooks.length; ++i) {
                    if (typeof object.notebooks[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.notebooks: object expected");
                    message.notebooks[i] = $root.dataform.Notebook.fromObject(object.notebooks[i]);
                }
            }
            if (object.dataPreparations) {
                if (!Array.isArray(object.dataPreparations))
                    throw TypeError(".dataform.CompiledGraph.dataPreparations: array expected");
                message.dataPreparations = [];
                for (let i = 0; i < object.dataPreparations.length; ++i) {
                    if (typeof object.dataPreparations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.dataPreparations: object expected");
                    message.dataPreparations[i] = $root.dataform.DataPreparation.fromObject(object.dataPreparations[i]);
                }
            }
            if (object.graphErrors != null) {
                if (typeof object.graphErrors !== "object")
                    throw TypeError(".dataform.CompiledGraph.graphErrors: object expected");
                message.graphErrors = $root.dataform.GraphErrors.fromObject(object.graphErrors);
            }
            if (object.dataformCoreVersion != null)
                message.dataformCoreVersion = String(object.dataformCoreVersion);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".dataform.CompiledGraph.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.targets: object expected");
                    message.targets[i] = $root.dataform.Target.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CompiledGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.CompiledGraph} message CompiledGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompiledGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.operations = [];
                object.assertions = [];
                object.tests = [];
                object.declarations = [];
                object.targets = [];
                object.notebooks = [];
                object.dataPreparations = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.graphErrors = null;
                object.dataformCoreVersion = "";
            }
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.Table.toObject(message.tables[j], options);
            }
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (let j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.dataform.Operation.toObject(message.operations[j], options);
            }
            if (message.assertions && message.assertions.length) {
                object.assertions = [];
                for (let j = 0; j < message.assertions.length; ++j)
                    object.assertions[j] = $root.dataform.Assertion.toObject(message.assertions[j], options);
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                object.graphErrors = $root.dataform.GraphErrors.toObject(message.graphErrors, options);
            if (message.tests && message.tests.length) {
                object.tests = [];
                for (let j = 0; j < message.tests.length; ++j)
                    object.tests[j] = $root.dataform.Test.toObject(message.tests[j], options);
            }
            if (message.declarations && message.declarations.length) {
                object.declarations = [];
                for (let j = 0; j < message.declarations.length; ++j)
                    object.declarations[j] = $root.dataform.Declaration.toObject(message.declarations[j], options);
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                object.dataformCoreVersion = message.dataformCoreVersion;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.dataform.Target.toObject(message.targets[j], options);
            }
            if (message.notebooks && message.notebooks.length) {
                object.notebooks = [];
                for (let j = 0; j < message.notebooks.length; ++j)
                    object.notebooks[j] = $root.dataform.Notebook.toObject(message.notebooks[j], options);
            }
            if (message.dataPreparations && message.dataPreparations.length) {
                object.dataPreparations = [];
                for (let j = 0; j < message.dataPreparations.length; ++j)
                    object.dataPreparations[j] = $root.dataform.DataPreparation.toObject(message.dataPreparations[j], options);
            }
            return object;
        };

        /**
         * Converts this CompiledGraph to JSON.
         * @function toJSON
         * @memberof dataform.CompiledGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompiledGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompiledGraph
         * @function getTypeUrl
         * @memberof dataform.CompiledGraph
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompiledGraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompiledGraph";
        };

        return CompiledGraph;
    })();

    dataform.CoreExecutionRequest = (function() {

        /**
         * Properties of a CoreExecutionRequest.
         * @memberof dataform
         * @interface ICoreExecutionRequest
         * @property {dataform.ICompileExecutionRequest|null} [compile] CoreExecutionRequest compile
         */

        /**
         * Constructs a new CoreExecutionRequest.
         * @memberof dataform
         * @classdesc Represents a CoreExecutionRequest.
         * @implements ICoreExecutionRequest
         * @constructor
         * @param {dataform.ICoreExecutionRequest=} [properties] Properties to set
         */
        function CoreExecutionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreExecutionRequest compile.
         * @member {dataform.ICompileExecutionRequest|null|undefined} compile
         * @memberof dataform.CoreExecutionRequest
         * @instance
         */
        CoreExecutionRequest.prototype.compile = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CoreExecutionRequest request.
         * @member {"compile"|undefined} request
         * @memberof dataform.CoreExecutionRequest
         * @instance
         */
        Object.defineProperty(CoreExecutionRequest.prototype, "request", {
            get: $util.oneOfGetter($oneOfFields = ["compile"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CoreExecutionRequest instance using the specified properties.
         * @function create
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest=} [properties] Properties to set
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest instance
         */
        CoreExecutionRequest.create = function create(properties) {
            return new CoreExecutionRequest(properties);
        };

        /**
         * Encodes the specified CoreExecutionRequest message. Does not implicitly {@link dataform.CoreExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest} message CoreExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compile != null && Object.hasOwnProperty.call(message, "compile"))
                $root.dataform.CompileExecutionRequest.encode(message.compile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CoreExecutionRequest message, length delimited. Does not implicitly {@link dataform.CoreExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest} message CoreExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CoreExecutionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compile = $root.dataform.CompileExecutionRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoreExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreExecutionRequest message.
         * @function verify
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compile != null && message.hasOwnProperty("compile")) {
                {
                    let error = $root.dataform.CompileExecutionRequest.verify(message.compile);
                    if (error)
                        return "compile." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CoreExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         */
        CoreExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CoreExecutionRequest)
                return object;
            let message = new $root.dataform.CoreExecutionRequest();
            if (object.compile != null) {
                if (typeof object.compile !== "object")
                    throw TypeError(".dataform.CoreExecutionRequest.compile: object expected");
                message.compile = $root.dataform.CompileExecutionRequest.fromObject(object.compile);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.CoreExecutionRequest} message CoreExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.compile != null && message.hasOwnProperty("compile")) {
                object.compile = $root.dataform.CompileExecutionRequest.toObject(message.compile, options);
                if (options.oneofs)
                    object.request = "compile";
            }
            return object;
        };

        /**
         * Converts this CoreExecutionRequest to JSON.
         * @function toJSON
         * @memberof dataform.CoreExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CoreExecutionRequest
         * @function getTypeUrl
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CoreExecutionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CoreExecutionRequest";
        };

        return CoreExecutionRequest;
    })();

    dataform.CoreExecutionResponse = (function() {

        /**
         * Properties of a CoreExecutionResponse.
         * @memberof dataform
         * @interface ICoreExecutionResponse
         * @property {dataform.ICompileExecutionResponse|null} [compile] CoreExecutionResponse compile
         */

        /**
         * Constructs a new CoreExecutionResponse.
         * @memberof dataform
         * @classdesc Represents a CoreExecutionResponse.
         * @implements ICoreExecutionResponse
         * @constructor
         * @param {dataform.ICoreExecutionResponse=} [properties] Properties to set
         */
        function CoreExecutionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreExecutionResponse compile.
         * @member {dataform.ICompileExecutionResponse|null|undefined} compile
         * @memberof dataform.CoreExecutionResponse
         * @instance
         */
        CoreExecutionResponse.prototype.compile = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CoreExecutionResponse response.
         * @member {"compile"|undefined} response
         * @memberof dataform.CoreExecutionResponse
         * @instance
         */
        Object.defineProperty(CoreExecutionResponse.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["compile"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CoreExecutionResponse instance using the specified properties.
         * @function create
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse=} [properties] Properties to set
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse instance
         */
        CoreExecutionResponse.create = function create(properties) {
            return new CoreExecutionResponse(properties);
        };

        /**
         * Encodes the specified CoreExecutionResponse message. Does not implicitly {@link dataform.CoreExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse} message CoreExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compile != null && Object.hasOwnProperty.call(message, "compile"))
                $root.dataform.CompileExecutionResponse.encode(message.compile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CoreExecutionResponse message, length delimited. Does not implicitly {@link dataform.CoreExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse} message CoreExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CoreExecutionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compile = $root.dataform.CompileExecutionResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoreExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreExecutionResponse message.
         * @function verify
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compile != null && message.hasOwnProperty("compile")) {
                {
                    let error = $root.dataform.CompileExecutionResponse.verify(message.compile);
                    if (error)
                        return "compile." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CoreExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         */
        CoreExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CoreExecutionResponse)
                return object;
            let message = new $root.dataform.CoreExecutionResponse();
            if (object.compile != null) {
                if (typeof object.compile !== "object")
                    throw TypeError(".dataform.CoreExecutionResponse.compile: object expected");
                message.compile = $root.dataform.CompileExecutionResponse.fromObject(object.compile);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.CoreExecutionResponse} message CoreExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.compile != null && message.hasOwnProperty("compile")) {
                object.compile = $root.dataform.CompileExecutionResponse.toObject(message.compile, options);
                if (options.oneofs)
                    object.response = "compile";
            }
            return object;
        };

        /**
         * Converts this CoreExecutionResponse to JSON.
         * @function toJSON
         * @memberof dataform.CoreExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CoreExecutionResponse
         * @function getTypeUrl
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CoreExecutionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CoreExecutionResponse";
        };

        return CoreExecutionResponse;
    })();

    dataform.CompileExecutionRequest = (function() {

        /**
         * Properties of a CompileExecutionRequest.
         * @memberof dataform
         * @interface ICompileExecutionRequest
         * @property {dataform.ICompileConfig|null} [compileConfig] CompileExecutionRequest compileConfig
         */

        /**
         * Constructs a new CompileExecutionRequest.
         * @memberof dataform
         * @classdesc Represents a CompileExecutionRequest.
         * @implements ICompileExecutionRequest
         * @constructor
         * @param {dataform.ICompileExecutionRequest=} [properties] Properties to set
         */
        function CompileExecutionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileExecutionRequest compileConfig.
         * @member {dataform.ICompileConfig|null|undefined} compileConfig
         * @memberof dataform.CompileExecutionRequest
         * @instance
         */
        CompileExecutionRequest.prototype.compileConfig = null;

        /**
         * Creates a new CompileExecutionRequest instance using the specified properties.
         * @function create
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest=} [properties] Properties to set
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest instance
         */
        CompileExecutionRequest.create = function create(properties) {
            return new CompileExecutionRequest(properties);
        };

        /**
         * Encodes the specified CompileExecutionRequest message. Does not implicitly {@link dataform.CompileExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest} message CompileExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compileConfig != null && Object.hasOwnProperty.call(message, "compileConfig"))
                $root.dataform.CompileConfig.encode(message.compileConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompileExecutionRequest message, length delimited. Does not implicitly {@link dataform.CompileExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest} message CompileExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileExecutionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compileConfig = $root.dataform.CompileConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileExecutionRequest message.
         * @function verify
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig")) {
                let error = $root.dataform.CompileConfig.verify(message.compileConfig);
                if (error)
                    return "compileConfig." + error;
            }
            return null;
        };

        /**
         * Creates a CompileExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         */
        CompileExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileExecutionRequest)
                return object;
            let message = new $root.dataform.CompileExecutionRequest();
            if (object.compileConfig != null) {
                if (typeof object.compileConfig !== "object")
                    throw TypeError(".dataform.CompileExecutionRequest.compileConfig: object expected");
                message.compileConfig = $root.dataform.CompileConfig.fromObject(object.compileConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a CompileExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.CompileExecutionRequest} message CompileExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.compileConfig = null;
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                object.compileConfig = $root.dataform.CompileConfig.toObject(message.compileConfig, options);
            return object;
        };

        /**
         * Converts this CompileExecutionRequest to JSON.
         * @function toJSON
         * @memberof dataform.CompileExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileExecutionRequest
         * @function getTypeUrl
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileExecutionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileExecutionRequest";
        };

        return CompileExecutionRequest;
    })();

    dataform.CompileExecutionResponse = (function() {

        /**
         * Properties of a CompileExecutionResponse.
         * @memberof dataform
         * @interface ICompileExecutionResponse
         * @property {dataform.ICompiledGraph|null} [compiledGraph] CompileExecutionResponse compiledGraph
         */

        /**
         * Constructs a new CompileExecutionResponse.
         * @memberof dataform
         * @classdesc Represents a CompileExecutionResponse.
         * @implements ICompileExecutionResponse
         * @constructor
         * @param {dataform.ICompileExecutionResponse=} [properties] Properties to set
         */
        function CompileExecutionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileExecutionResponse compiledGraph.
         * @member {dataform.ICompiledGraph|null|undefined} compiledGraph
         * @memberof dataform.CompileExecutionResponse
         * @instance
         */
        CompileExecutionResponse.prototype.compiledGraph = null;

        /**
         * Creates a new CompileExecutionResponse instance using the specified properties.
         * @function create
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse=} [properties] Properties to set
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse instance
         */
        CompileExecutionResponse.create = function create(properties) {
            return new CompileExecutionResponse(properties);
        };

        /**
         * Encodes the specified CompileExecutionResponse message. Does not implicitly {@link dataform.CompileExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse} message CompileExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compiledGraph != null && Object.hasOwnProperty.call(message, "compiledGraph"))
                $root.dataform.CompiledGraph.encode(message.compiledGraph, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompileExecutionResponse message, length delimited. Does not implicitly {@link dataform.CompileExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse} message CompileExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileExecutionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compiledGraph = $root.dataform.CompiledGraph.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileExecutionResponse message.
         * @function verify
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compiledGraph != null && message.hasOwnProperty("compiledGraph")) {
                let error = $root.dataform.CompiledGraph.verify(message.compiledGraph);
                if (error)
                    return "compiledGraph." + error;
            }
            return null;
        };

        /**
         * Creates a CompileExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         */
        CompileExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileExecutionResponse)
                return object;
            let message = new $root.dataform.CompileExecutionResponse();
            if (object.compiledGraph != null) {
                if (typeof object.compiledGraph !== "object")
                    throw TypeError(".dataform.CompileExecutionResponse.compiledGraph: object expected");
                message.compiledGraph = $root.dataform.CompiledGraph.fromObject(object.compiledGraph);
            }
            return message;
        };

        /**
         * Creates a plain object from a CompileExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.CompileExecutionResponse} message CompileExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.compiledGraph = null;
            if (message.compiledGraph != null && message.hasOwnProperty("compiledGraph"))
                object.compiledGraph = $root.dataform.CompiledGraph.toObject(message.compiledGraph, options);
            return object;
        };

        /**
         * Converts this CompileExecutionResponse to JSON.
         * @function toJSON
         * @memberof dataform.CompileExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileExecutionResponse
         * @function getTypeUrl
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileExecutionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileExecutionResponse";
        };

        return CompileExecutionResponse;
    })();

    /**
     * SupportedFeatures enum.
     * @name dataform.SupportedFeatures
     * @enum {number}
     * @property {number} UNKNOWN_FEATURE=0 UNKNOWN_FEATURE value
     * @property {number} ARRAY_BUFFER_IPC=1 ARRAY_BUFFER_IPC value
     */
    dataform.SupportedFeatures = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_FEATURE"] = 0;
        values[valuesById[1] = "ARRAY_BUFFER_IPC"] = 1;
        return values;
    })();

    dataform.QueryEvaluationError = (function() {

        /**
         * Properties of a QueryEvaluationError.
         * @memberof dataform
         * @interface IQueryEvaluationError
         * @property {string|null} [message] QueryEvaluationError message
         * @property {dataform.QueryEvaluationError.IErrorLocation|null} [errorLocation] QueryEvaluationError errorLocation
         */

        /**
         * Constructs a new QueryEvaluationError.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluationError.
         * @implements IQueryEvaluationError
         * @constructor
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         */
        function QueryEvaluationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluationError message.
         * @member {string} message
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.message = "";

        /**
         * QueryEvaluationError errorLocation.
         * @member {dataform.QueryEvaluationError.IErrorLocation|null|undefined} errorLocation
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.errorLocation = null;

        /**
         * Creates a new QueryEvaluationError instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError instance
         */
        QueryEvaluationError.create = function create(properties) {
            return new QueryEvaluationError(properties);
        };

        /**
         * Encodes the specified QueryEvaluationError message. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.errorLocation != null && Object.hasOwnProperty.call(message, "errorLocation"))
                $root.dataform.QueryEvaluationError.ErrorLocation.encode(message.errorLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluationError message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.message = reader.string();
                        break;
                    }
                case 2: {
                        message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluationError message.
         * @function verify
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation")) {
                let error = $root.dataform.QueryEvaluationError.ErrorLocation.verify(message.errorLocation);
                if (error)
                    return "errorLocation." + error;
            }
            return null;
        };

        /**
         * Creates a QueryEvaluationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         */
        QueryEvaluationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluationError)
                return object;
            let message = new $root.dataform.QueryEvaluationError();
            if (object.message != null)
                message.message = String(object.message);
            if (object.errorLocation != null) {
                if (typeof object.errorLocation !== "object")
                    throw TypeError(".dataform.QueryEvaluationError.errorLocation: object expected");
                message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.fromObject(object.errorLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.QueryEvaluationError} message QueryEvaluationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.message = "";
                object.errorLocation = null;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                object.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.toObject(message.errorLocation, options);
            return object;
        };

        /**
         * Converts this QueryEvaluationError to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QueryEvaluationError
         * @function getTypeUrl
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryEvaluationError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.QueryEvaluationError";
        };

        QueryEvaluationError.ErrorLocation = (function() {

            /**
             * Properties of an ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @interface IErrorLocation
             * @property {number|null} [line] ErrorLocation line
             * @property {number|null} [column] ErrorLocation column
             */

            /**
             * Constructs a new ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @classdesc Represents an ErrorLocation.
             * @implements IErrorLocation
             * @constructor
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             */
            function ErrorLocation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorLocation line.
             * @member {number} line
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.line = 0;

            /**
             * ErrorLocation column.
             * @member {number} column
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.column = 0;

            /**
             * Creates a new ErrorLocation instance using the specified properties.
             * @function create
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation instance
             */
            ErrorLocation.create = function create(properties) {
                return new ErrorLocation(properties);
            };

            /**
             * Encodes the specified ErrorLocation message. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.line);
                if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.column);
                return writer;
            };

            /**
             * Encodes the specified ErrorLocation message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.line = reader.int32();
                            break;
                        }
                    case 2: {
                            message.column = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorLocation message.
             * @function verify
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorLocation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.column != null && message.hasOwnProperty("column"))
                    if (!$util.isInteger(message.column))
                        return "column: integer expected";
                return null;
            };

            /**
             * Creates an ErrorLocation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             */
            ErrorLocation.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.QueryEvaluationError.ErrorLocation)
                    return object;
                let message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                if (object.line != null)
                    message.line = object.line | 0;
                if (object.column != null)
                    message.column = object.column | 0;
                return message;
            };

            /**
             * Creates a plain object from an ErrorLocation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.ErrorLocation} message ErrorLocation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorLocation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.line = 0;
                    object.column = 0;
                }
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.column != null && message.hasOwnProperty("column"))
                    object.column = message.column;
                return object;
            };

            /**
             * Converts this ErrorLocation to JSON.
             * @function toJSON
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorLocation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ErrorLocation
             * @function getTypeUrl
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ErrorLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.QueryEvaluationError.ErrorLocation";
            };

            return ErrorLocation;
        })();

        return QueryEvaluationError;
    })();

    dataform.QueryEvaluation = (function() {

        /**
         * Properties of a QueryEvaluation.
         * @memberof dataform
         * @interface IQueryEvaluation
         * @property {dataform.QueryEvaluation.QueryEvaluationStatus|null} [status] QueryEvaluation status
         * @property {dataform.IQueryEvaluationError|null} [error] QueryEvaluation error
         * @property {boolean|null} [incremental] QueryEvaluation incremental
         * @property {string|null} [query] QueryEvaluation query
         */

        /**
         * Constructs a new QueryEvaluation.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluation.
         * @implements IQueryEvaluation
         * @constructor
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         */
        function QueryEvaluation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluation status.
         * @member {dataform.QueryEvaluation.QueryEvaluationStatus} status
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.status = 0;

        /**
         * QueryEvaluation error.
         * @member {dataform.IQueryEvaluationError|null|undefined} error
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.error = null;

        /**
         * QueryEvaluation incremental.
         * @member {boolean} incremental
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.incremental = false;

        /**
         * QueryEvaluation query.
         * @member {string} query
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.query = "";

        /**
         * Creates a new QueryEvaluation instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         * @returns {dataform.QueryEvaluation} QueryEvaluation instance
         */
        QueryEvaluation.create = function create(properties) {
            return new QueryEvaluation(properties);
        };

        /**
         * Encodes the specified QueryEvaluation message. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.dataform.QueryEvaluationError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.incremental != null && Object.hasOwnProperty.call(message, "incremental"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.incremental);
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluation message, length delimited. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.error = $root.dataform.QueryEvaluationError.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.incremental = reader.bool();
                        break;
                    }
                case 4: {
                        message.query = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluation message.
         * @function verify
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.error != null && message.hasOwnProperty("error")) {
                let error = $root.dataform.QueryEvaluationError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a QueryEvaluation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         */
        QueryEvaluation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluation)
                return object;
            let message = new $root.dataform.QueryEvaluation();
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FAILURE":
            case 1:
                message.status = 1;
                break;
            }
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".dataform.QueryEvaluation.error: object expected");
                message.error = $root.dataform.QueryEvaluationError.fromObject(object.error);
            }
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.QueryEvaluation} message QueryEvaluation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "SUCCESS" : 0;
                object.error = null;
                object.incremental = false;
                object.query = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.QueryEvaluation.QueryEvaluationStatus[message.status] === undefined ? message.status : $root.dataform.QueryEvaluation.QueryEvaluationStatus[message.status] : message.status;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.dataform.QueryEvaluationError.toObject(message.error, options);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this QueryEvaluation to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QueryEvaluation
         * @function getTypeUrl
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryEvaluation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.QueryEvaluation";
        };

        /**
         * QueryEvaluationStatus enum.
         * @name dataform.QueryEvaluation.QueryEvaluationStatus
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} FAILURE=1 FAILURE value
         */
        QueryEvaluation.QueryEvaluationStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "FAILURE"] = 1;
            return values;
        })();

        return QueryEvaluation;
    })();

    dataform.RunConfig = (function() {

        /**
         * Properties of a RunConfig.
         * @memberof dataform
         * @interface IRunConfig
         * @property {Array.<string>|null} [actions] RunConfig actions
         * @property {Array.<string>|null} [tags] RunConfig tags
         * @property {boolean|null} [includeDependencies] RunConfig includeDependencies
         * @property {boolean|null} [includeDependents] RunConfig includeDependents
         * @property {boolean|null} [fullRefresh] RunConfig fullRefresh
         * @property {number|null} [timeoutMillis] RunConfig timeoutMillis
         * @property {boolean|null} [disableSetMetadata] RunConfig disableSetMetadata
         * @property {boolean|null} [useRunCache] RunConfig useRunCache
         */

        /**
         * Constructs a new RunConfig.
         * @memberof dataform
         * @classdesc Represents a RunConfig.
         * @implements IRunConfig
         * @constructor
         * @param {dataform.IRunConfig=} [properties] Properties to set
         */
        function RunConfig(properties) {
            this.actions = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunConfig actions.
         * @member {Array.<string>} actions
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.actions = $util.emptyArray;

        /**
         * RunConfig tags.
         * @member {Array.<string>} tags
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.tags = $util.emptyArray;

        /**
         * RunConfig includeDependencies.
         * @member {boolean} includeDependencies
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependencies = false;

        /**
         * RunConfig includeDependents.
         * @member {boolean} includeDependents
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependents = false;

        /**
         * RunConfig fullRefresh.
         * @member {boolean} fullRefresh
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.fullRefresh = false;

        /**
         * RunConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.timeoutMillis = 0;

        /**
         * RunConfig disableSetMetadata.
         * @member {boolean} disableSetMetadata
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.disableSetMetadata = false;

        /**
         * RunConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.useRunCache = false;

        /**
         * Creates a new RunConfig instance using the specified properties.
         * @function create
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig=} [properties] Properties to set
         * @returns {dataform.RunConfig} RunConfig instance
         */
        RunConfig.create = function create(properties) {
            return new RunConfig(properties);
        };

        /**
         * Encodes the specified RunConfig message. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
            if (message.fullRefresh != null && Object.hasOwnProperty.call(message, "fullRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullRefresh);
            if (message.includeDependencies != null && Object.hasOwnProperty.call(message, "includeDependencies"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeDependencies);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
            if (message.timeoutMillis != null && Object.hasOwnProperty.call(message, "timeoutMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timeoutMillis);
            if (message.useRunCache != null && Object.hasOwnProperty.call(message, "useRunCache"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.useRunCache);
            if (message.disableSetMetadata != null && Object.hasOwnProperty.call(message, "disableSetMetadata"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.disableSetMetadata);
            if (message.includeDependents != null && Object.hasOwnProperty.call(message, "includeDependents"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeDependents);
            return writer;
        };

        /**
         * Encodes the specified RunConfig message, length delimited. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 3: {
                        message.includeDependencies = reader.bool();
                        break;
                    }
                case 11: {
                        message.includeDependents = reader.bool();
                        break;
                    }
                case 2: {
                        message.fullRefresh = reader.bool();
                        break;
                    }
                case 7: {
                        message.timeoutMillis = reader.int32();
                        break;
                    }
                case 9: {
                        message.disableSetMetadata = reader.bool();
                        break;
                    }
                case 8: {
                        message.useRunCache = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunConfig message.
         * @function verify
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i)
                    if (!$util.isString(message.actions[i]))
                        return "actions: string[] expected";
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                if (typeof message.includeDependencies !== "boolean")
                    return "includeDependencies: boolean expected";
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                if (typeof message.includeDependents !== "boolean")
                    return "includeDependents: boolean expected";
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                if (typeof message.fullRefresh !== "boolean")
                    return "fullRefresh: boolean expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                if (typeof message.disableSetMetadata !== "boolean")
                    return "disableSetMetadata: boolean expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            return null;
        };

        /**
         * Creates a RunConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunConfig} RunConfig
         */
        RunConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunConfig)
                return object;
            let message = new $root.dataform.RunConfig();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunConfig.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i)
                    message.actions[i] = String(object.actions[i]);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.RunConfig.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.includeDependencies != null)
                message.includeDependencies = Boolean(object.includeDependencies);
            if (object.includeDependents != null)
                message.includeDependents = Boolean(object.includeDependents);
            if (object.fullRefresh != null)
                message.fullRefresh = Boolean(object.fullRefresh);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.disableSetMetadata != null)
                message.disableSetMetadata = Boolean(object.disableSetMetadata);
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            return message;
        };

        /**
         * Creates a plain object from a RunConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.RunConfig} message RunConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.tags = [];
            }
            if (options.defaults) {
                object.fullRefresh = false;
                object.includeDependencies = false;
                object.timeoutMillis = 0;
                object.useRunCache = false;
                object.disableSetMetadata = false;
                object.includeDependents = false;
            }
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = message.actions[j];
            }
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                object.fullRefresh = message.fullRefresh;
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                object.includeDependencies = message.includeDependencies;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                object.disableSetMetadata = message.disableSetMetadata;
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                object.includeDependents = message.includeDependents;
            return object;
        };

        /**
         * Converts this RunConfig to JSON.
         * @function toJSON
         * @memberof dataform.RunConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RunConfig
         * @function getTypeUrl
         * @memberof dataform.RunConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RunConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.RunConfig";
        };

        return RunConfig;
    })();

    dataform.ExecutionTask = (function() {

        /**
         * Properties of an ExecutionTask.
         * @memberof dataform
         * @interface IExecutionTask
         * @property {string|null} [type] ExecutionTask type
         * @property {string|null} [statement] ExecutionTask statement
         */

        /**
         * Constructs a new ExecutionTask.
         * @memberof dataform
         * @classdesc Represents an ExecutionTask.
         * @implements IExecutionTask
         * @constructor
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         */
        function ExecutionTask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionTask type.
         * @member {string} type
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.type = "";

        /**
         * ExecutionTask statement.
         * @member {string} statement
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.statement = "";

        /**
         * Creates a new ExecutionTask instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         * @returns {dataform.ExecutionTask} ExecutionTask instance
         */
        ExecutionTask.create = function create(properties) {
            return new ExecutionTask(properties);
        };

        /**
         * Encodes the specified ExecutionTask message. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.statement != null && Object.hasOwnProperty.call(message, "statement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.statement);
            return writer;
        };

        /**
         * Encodes the specified ExecutionTask message, length delimited. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionTask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.string();
                        break;
                    }
                case 2: {
                        message.statement = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionTask message.
         * @function verify
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.statement != null && message.hasOwnProperty("statement"))
                if (!$util.isString(message.statement))
                    return "statement: string expected";
            return null;
        };

        /**
         * Creates an ExecutionTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionTask} ExecutionTask
         */
        ExecutionTask.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionTask)
                return object;
            let message = new $root.dataform.ExecutionTask();
            if (object.type != null)
                message.type = String(object.type);
            if (object.statement != null)
                message.statement = String(object.statement);
            return message;
        };

        /**
         * Creates a plain object from an ExecutionTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.ExecutionTask} message ExecutionTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = "";
                object.statement = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.statement != null && message.hasOwnProperty("statement"))
                object.statement = message.statement;
            return object;
        };

        /**
         * Converts this ExecutionTask to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionTask
         * @function getTypeUrl
         * @memberof dataform.ExecutionTask
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionTask";
        };

        return ExecutionTask;
    })();

    dataform.ExecutionAction = (function() {

        /**
         * Properties of an ExecutionAction.
         * @memberof dataform
         * @interface IExecutionAction
         * @property {dataform.ITarget|null} [target] ExecutionAction target
         * @property {string|null} [fileName] ExecutionAction fileName
         * @property {string|null} [type] ExecutionAction type
         * @property {string|null} [tableType] ExecutionAction tableType
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] ExecutionAction dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] ExecutionAction hermeticity
         * @property {Array.<dataform.IExecutionTask>|null} [tasks] ExecutionAction tasks
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] ExecutionAction actionDescriptor
         */

        /**
         * Constructs a new ExecutionAction.
         * @memberof dataform
         * @classdesc Represents an ExecutionAction.
         * @implements IExecutionAction
         * @constructor
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         */
        function ExecutionAction(properties) {
            this.dependencyTargets = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionAction target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.target = null;

        /**
         * ExecutionAction fileName.
         * @member {string} fileName
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.fileName = "";

        /**
         * ExecutionAction type.
         * @member {string} type
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.type = "";

        /**
         * ExecutionAction tableType.
         * @member {string} tableType
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tableType = "";

        /**
         * ExecutionAction dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.dependencyTargets = $util.emptyArray;

        /**
         * ExecutionAction hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.hermeticity = 0;

        /**
         * ExecutionAction tasks.
         * @member {Array.<dataform.IExecutionTask>} tasks
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tasks = $util.emptyArray;

        /**
         * ExecutionAction actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.actionDescriptor = null;

        /**
         * Creates a new ExecutionAction instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         * @returns {dataform.ExecutionAction} ExecutionAction instance
         */
        ExecutionAction.create = function create(properties) {
            return new ExecutionAction(properties);
        };

        /**
         * Encodes the specified ExecutionAction message. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.ExecutionTask.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.tableType != null && Object.hasOwnProperty.call(message, "tableType"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tableType);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.hermeticity);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionAction message, length delimited. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.fileName = reader.string();
                        break;
                    }
                case 4: {
                        message.type = reader.string();
                        break;
                    }
                case 6: {
                        message.tableType = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.dataform.ExecutionTask.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionAction message.
         * @function verify
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                if (!$util.isString(message.tableType))
                    return "tableType: string expected";
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.ExecutionTask.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionAction} ExecutionAction
         */
        ExecutionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionAction)
                return object;
            let message = new $root.dataform.ExecutionAction();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ExecutionAction.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.type != null)
                message.type = String(object.type);
            if (object.tableType != null)
                message.tableType = String(object.tableType);
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.ExecutionAction.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            default:
                if (typeof object.hermeticity === "number") {
                    message.hermeticity = object.hermeticity;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ExecutionAction.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.tasks: object expected");
                    message.tasks[i] = $root.dataform.ExecutionTask.fromObject(object.tasks[i]);
                }
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.ExecutionAction.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.ExecutionAction} message ExecutionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.type = "";
                object.target = null;
                object.tableType = "";
                object.fileName = "";
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.ExecutionTask.toObject(message.tasks[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                object.tableType = message.tableType;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] === undefined ? message.hermeticity : $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionAction to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionAction
         * @function getTypeUrl
         * @memberof dataform.ExecutionAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionAction";
        };

        return ExecutionAction;
    })();

    dataform.WarehouseState = (function() {

        /**
         * Properties of a WarehouseState.
         * @memberof dataform
         * @interface IWarehouseState
         * @property {Array.<dataform.ITableMetadata>|null} [tables] WarehouseState tables
         */

        /**
         * Constructs a new WarehouseState.
         * @memberof dataform
         * @classdesc Represents a WarehouseState.
         * @implements IWarehouseState
         * @constructor
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         */
        function WarehouseState(properties) {
            this.tables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarehouseState tables.
         * @member {Array.<dataform.ITableMetadata>} tables
         * @memberof dataform.WarehouseState
         * @instance
         */
        WarehouseState.prototype.tables = $util.emptyArray;

        /**
         * Creates a new WarehouseState instance using the specified properties.
         * @function create
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         * @returns {dataform.WarehouseState} WarehouseState instance
         */
        WarehouseState.create = function create(properties) {
            return new WarehouseState(properties);
        };

        /**
         * Encodes the specified WarehouseState message. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encode
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.TableMetadata.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarehouseState message, length delimited. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.WarehouseState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.dataform.TableMetadata.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarehouseState message.
         * @function verify
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarehouseState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.TableMetadata.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WarehouseState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.WarehouseState} WarehouseState
         */
        WarehouseState.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.WarehouseState)
                return object;
            let message = new $root.dataform.WarehouseState();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.WarehouseState.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.WarehouseState.tables: object expected");
                    message.tables[i] = $root.dataform.TableMetadata.fromObject(object.tables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WarehouseState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.WarehouseState} message WarehouseState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarehouseState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.TableMetadata.toObject(message.tables[j], options);
            }
            return object;
        };

        /**
         * Converts this WarehouseState to JSON.
         * @function toJSON
         * @memberof dataform.WarehouseState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarehouseState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WarehouseState
         * @function getTypeUrl
         * @memberof dataform.WarehouseState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WarehouseState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.WarehouseState";
        };

        return WarehouseState;
    })();

    dataform.ExecutionGraph = (function() {

        /**
         * Properties of an ExecutionGraph.
         * @memberof dataform
         * @interface IExecutionGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] ExecutionGraph projectConfig
         * @property {dataform.IRunConfig|null} [runConfig] ExecutionGraph runConfig
         * @property {dataform.IWarehouseState|null} [warehouseState] ExecutionGraph warehouseState
         * @property {Array.<dataform.ITarget>|null} [declarationTargets] ExecutionGraph declarationTargets
         * @property {Array.<dataform.IExecutionAction>|null} [actions] ExecutionGraph actions
         */

        /**
         * Constructs a new ExecutionGraph.
         * @memberof dataform
         * @classdesc Represents an ExecutionGraph.
         * @implements IExecutionGraph
         * @constructor
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         */
        function ExecutionGraph(properties) {
            this.declarationTargets = [];
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.projectConfig = null;

        /**
         * ExecutionGraph runConfig.
         * @member {dataform.IRunConfig|null|undefined} runConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.runConfig = null;

        /**
         * ExecutionGraph warehouseState.
         * @member {dataform.IWarehouseState|null|undefined} warehouseState
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.warehouseState = null;

        /**
         * ExecutionGraph declarationTargets.
         * @member {Array.<dataform.ITarget>} declarationTargets
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.declarationTargets = $util.emptyArray;

        /**
         * ExecutionGraph actions.
         * @member {Array.<dataform.IExecutionAction>} actions
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.actions = $util.emptyArray;

        /**
         * Creates a new ExecutionGraph instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         * @returns {dataform.ExecutionGraph} ExecutionGraph instance
         */
        ExecutionGraph.create = function create(properties) {
            return new ExecutionGraph(properties);
        };

        /**
         * Encodes the specified ExecutionGraph message. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectConfig != null && Object.hasOwnProperty.call(message, "projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.runConfig != null && Object.hasOwnProperty.call(message, "runConfig"))
                $root.dataform.RunConfig.encode(message.runConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ExecutionAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.warehouseState != null && Object.hasOwnProperty.call(message, "warehouseState"))
                $root.dataform.WarehouseState.encode(message.warehouseState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.declarationTargets != null && message.declarationTargets.length)
                for (let i = 0; i < message.declarationTargets.length; ++i)
                    $root.dataform.Target.encode(message.declarationTargets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionGraph message, length delimited. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.runConfig = $root.dataform.RunConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.warehouseState = $root.dataform.WarehouseState.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.declarationTargets && message.declarationTargets.length))
                            message.declarationTargets = [];
                        message.declarationTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.dataform.ExecutionAction.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionGraph message.
         * @function verify
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.runConfig != null && message.hasOwnProperty("runConfig")) {
                let error = $root.dataform.RunConfig.verify(message.runConfig);
                if (error)
                    return "runConfig." + error;
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState")) {
                let error = $root.dataform.WarehouseState.verify(message.warehouseState);
                if (error)
                    return "warehouseState." + error;
            }
            if (message.declarationTargets != null && message.hasOwnProperty("declarationTargets")) {
                if (!Array.isArray(message.declarationTargets))
                    return "declarationTargets: array expected";
                for (let i = 0; i < message.declarationTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.declarationTargets[i]);
                    if (error)
                        return "declarationTargets." + error;
                }
            }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ExecutionAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecutionGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         */
        ExecutionGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionGraph)
                return object;
            let message = new $root.dataform.ExecutionGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.runConfig != null) {
                if (typeof object.runConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.runConfig: object expected");
                message.runConfig = $root.dataform.RunConfig.fromObject(object.runConfig);
            }
            if (object.warehouseState != null) {
                if (typeof object.warehouseState !== "object")
                    throw TypeError(".dataform.ExecutionGraph.warehouseState: object expected");
                message.warehouseState = $root.dataform.WarehouseState.fromObject(object.warehouseState);
            }
            if (object.declarationTargets) {
                if (!Array.isArray(object.declarationTargets))
                    throw TypeError(".dataform.ExecutionGraph.declarationTargets: array expected");
                message.declarationTargets = [];
                for (let i = 0; i < object.declarationTargets.length; ++i) {
                    if (typeof object.declarationTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.declarationTargets: object expected");
                    message.declarationTargets[i] = $root.dataform.Target.fromObject(object.declarationTargets[i]);
                }
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.ExecutionGraph.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.actions: object expected");
                    message.actions[i] = $root.dataform.ExecutionAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.ExecutionGraph} message ExecutionGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.declarationTargets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.runConfig = null;
                object.warehouseState = null;
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                object.runConfig = $root.dataform.RunConfig.toObject(message.runConfig, options);
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ExecutionAction.toObject(message.actions[j], options);
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                object.warehouseState = $root.dataform.WarehouseState.toObject(message.warehouseState, options);
            if (message.declarationTargets && message.declarationTargets.length) {
                object.declarationTargets = [];
                for (let j = 0; j < message.declarationTargets.length; ++j)
                    object.declarationTargets[j] = $root.dataform.Target.toObject(message.declarationTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionGraph to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionGraph
         * @function getTypeUrl
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionGraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionGraph";
        };

        return ExecutionGraph;
    })();

    dataform.Timing = (function() {

        /**
         * Properties of a Timing.
         * @memberof dataform
         * @interface ITiming
         * @property {Long|null} [startTimeMillis] Timing startTimeMillis
         * @property {Long|null} [endTimeMillis] Timing endTimeMillis
         */

        /**
         * Constructs a new Timing.
         * @memberof dataform
         * @classdesc Represents a Timing.
         * @implements ITiming
         * @constructor
         * @param {dataform.ITiming=} [properties] Properties to set
         */
        function Timing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timing startTimeMillis.
         * @member {Long} startTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.startTimeMillis = 0;

        /**
         * Timing endTimeMillis.
         * @member {Long} endTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.endTimeMillis = 0;

        /**
         * Creates a new Timing instance using the specified properties.
         * @function create
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming=} [properties] Properties to set
         * @returns {dataform.Timing} Timing instance
         */
        Timing.create = function create(properties) {
            return new Timing(properties);
        };

        /**
         * Encodes the specified Timing message. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encode
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimeMillis != null && Object.hasOwnProperty.call(message, "startTimeMillis"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTimeMillis);
            if (message.endTimeMillis != null && Object.hasOwnProperty.call(message, "endTimeMillis"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTimeMillis);
            return writer;
        };

        /**
         * Encodes the specified Timing message, length delimited. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timing message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Timing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTimeMillis = reader.int64();
                        break;
                    }
                case 2: {
                        message.endTimeMillis = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timing message.
         * @function verify
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                    return "startTimeMillis: integer|Long expected";
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (!$util.isInteger(message.endTimeMillis) && !(message.endTimeMillis && $util.isInteger(message.endTimeMillis.low) && $util.isInteger(message.endTimeMillis.high)))
                    return "endTimeMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates a Timing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Timing} Timing
         */
        Timing.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Timing)
                return object;
            let message = new $root.dataform.Timing();
            if (object.startTimeMillis != null)
                if ($util.Long)
                    (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                else if (typeof object.startTimeMillis === "string")
                    message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                else if (typeof object.startTimeMillis === "number")
                    message.startTimeMillis = object.startTimeMillis;
                else if (typeof object.startTimeMillis === "object")
                    message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
            if (object.endTimeMillis != null)
                if ($util.Long)
                    (message.endTimeMillis = $util.Long.fromValue(object.endTimeMillis)).unsigned = false;
                else if (typeof object.endTimeMillis === "string")
                    message.endTimeMillis = parseInt(object.endTimeMillis, 10);
                else if (typeof object.endTimeMillis === "number")
                    message.endTimeMillis = object.endTimeMillis;
                else if (typeof object.endTimeMillis === "object")
                    message.endTimeMillis = new $util.LongBits(object.endTimeMillis.low >>> 0, object.endTimeMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Timing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Timing
         * @static
         * @param {dataform.Timing} message Timing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.startTimeMillis = 0;
                object.endTimeMillis = 0;
            }
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (typeof message.startTimeMillis === "number")
                    object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                else
                    object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (typeof message.endTimeMillis === "number")
                    object.endTimeMillis = options.longs === String ? String(message.endTimeMillis) : message.endTimeMillis;
                else
                    object.endTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeMillis) : options.longs === Number ? new $util.LongBits(message.endTimeMillis.low >>> 0, message.endTimeMillis.high >>> 0).toNumber() : message.endTimeMillis;
            return object;
        };

        /**
         * Converts this Timing to JSON.
         * @function toJSON
         * @memberof dataform.Timing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Timing
         * @function getTypeUrl
         * @memberof dataform.Timing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Timing";
        };

        return Timing;
    })();

    dataform.RunResult = (function() {

        /**
         * Properties of a RunResult.
         * @memberof dataform
         * @interface IRunResult
         * @property {dataform.RunResult.ExecutionStatus|null} [status] RunResult status
         * @property {Array.<dataform.IActionResult>|null} [actions] RunResult actions
         * @property {dataform.ITiming|null} [timing] RunResult timing
         */

        /**
         * Constructs a new RunResult.
         * @memberof dataform
         * @classdesc Represents a RunResult.
         * @implements IRunResult
         * @constructor
         * @param {dataform.IRunResult=} [properties] Properties to set
         */
        function RunResult(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunResult status.
         * @member {dataform.RunResult.ExecutionStatus} status
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.status = 0;

        /**
         * RunResult actions.
         * @member {Array.<dataform.IActionResult>} actions
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.actions = $util.emptyArray;

        /**
         * RunResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.timing = null;

        /**
         * Creates a new RunResult instance using the specified properties.
         * @function create
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult=} [properties] Properties to set
         * @returns {dataform.RunResult} RunResult instance
         */
        RunResult.create = function create(properties) {
            return new RunResult(properties);
        };

        /**
         * Encodes the specified RunResult message. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ActionResult.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RunResult message, length delimited. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.dataform.ActionResult.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunResult message.
         * @function verify
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ActionResult.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates a RunResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunResult} RunResult
         */
        RunResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunResult)
                return object;
            let message = new $root.dataform.RunResult();
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "CANCELLED":
            case 4:
                message.status = 4;
                break;
            case "TIMED_OUT":
            case 5:
                message.status = 5;
                break;
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunResult.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.RunResult.actions: object expected");
                    message.actions[i] = $root.dataform.ActionResult.fromObject(object.actions[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.RunResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from a RunResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.RunResult} message RunResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.RunResult.ExecutionStatus[message.status] === undefined ? message.status : $root.dataform.RunResult.ExecutionStatus[message.status] : message.status;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ActionResult.toObject(message.actions[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            return object;
        };

        /**
         * Converts this RunResult to JSON.
         * @function toJSON
         * @memberof dataform.RunResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RunResult
         * @function getTypeUrl
         * @memberof dataform.RunResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RunResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.RunResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.RunResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} CANCELLED=4 CANCELLED value
         * @property {number} TIMED_OUT=5 TIMED_OUT value
         */
        RunResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "CANCELLED"] = 4;
            values[valuesById[5] = "TIMED_OUT"] = 5;
            return values;
        })();

        return RunResult;
    })();

    dataform.ActionResult = (function() {

        /**
         * Properties of an ActionResult.
         * @memberof dataform
         * @interface IActionResult
         * @property {dataform.ITarget|null} [target] ActionResult target
         * @property {dataform.ActionResult.ExecutionStatus|null} [status] ActionResult status
         * @property {Array.<dataform.ITaskResult>|null} [tasks] ActionResult tasks
         * @property {dataform.ITiming|null} [timing] ActionResult timing
         */

        /**
         * Constructs a new ActionResult.
         * @memberof dataform
         * @classdesc Represents an ActionResult.
         * @implements IActionResult
         * @constructor
         * @param {dataform.IActionResult=} [properties] Properties to set
         */
        function ActionResult(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionResult target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.target = null;

        /**
         * ActionResult status.
         * @member {dataform.ActionResult.ExecutionStatus} status
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.status = 0;

        /**
         * ActionResult tasks.
         * @member {Array.<dataform.ITaskResult>} tasks
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.tasks = $util.emptyArray;

        /**
         * ActionResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.timing = null;

        /**
         * Creates a new ActionResult instance using the specified properties.
         * @function create
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult=} [properties] Properties to set
         * @returns {dataform.ActionResult} ActionResult instance
         */
        ActionResult.create = function create(properties) {
            return new ActionResult(properties);
        };

        /**
         * Encodes the specified ActionResult message. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.TaskResult.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionResult message, length delimited. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.dataform.TaskResult.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionResult message.
         * @function verify
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.TaskResult.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates an ActionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionResult} ActionResult
         */
        ActionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionResult)
                return object;
            let message = new $root.dataform.ActionResult();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ActionResult.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "DISABLED":
            case 5:
                message.status = 5;
                break;
            case "CANCELLED":
            case 6:
                message.status = 6;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ActionResult.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ActionResult.tasks: object expected");
                    message.tasks[i] = $root.dataform.TaskResult.fromObject(object.tasks[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.ActionResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.ActionResult} message ActionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
                object.target = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.ActionResult.ExecutionStatus[message.status] === undefined ? message.status : $root.dataform.ActionResult.ExecutionStatus[message.status] : message.status;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.TaskResult.toObject(message.tasks[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            return object;
        };

        /**
         * Converts this ActionResult to JSON.
         * @function toJSON
         * @memberof dataform.ActionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionResult
         * @function getTypeUrl
         * @memberof dataform.ActionResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.ActionResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} DISABLED=5 DISABLED value
         * @property {number} CANCELLED=6 CANCELLED value
         */
        ActionResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "DISABLED"] = 5;
            values[valuesById[6] = "CANCELLED"] = 6;
            return values;
        })();

        return ActionResult;
    })();

    dataform.ExecutionMetadata = (function() {

        /**
         * Properties of an ExecutionMetadata.
         * @memberof dataform
         * @interface IExecutionMetadata
         * @property {dataform.ExecutionMetadata.IBigqueryMetadata|null} [bigquery] ExecutionMetadata bigquery
         */

        /**
         * Constructs a new ExecutionMetadata.
         * @memberof dataform
         * @classdesc Represents an ExecutionMetadata.
         * @implements IExecutionMetadata
         * @constructor
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         */
        function ExecutionMetadata(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionMetadata bigquery.
         * @member {dataform.ExecutionMetadata.IBigqueryMetadata|null|undefined} bigquery
         * @memberof dataform.ExecutionMetadata
         * @instance
         */
        ExecutionMetadata.prototype.bigquery = null;

        /**
         * Creates a new ExecutionMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata instance
         */
        ExecutionMetadata.create = function create(properties) {
            return new ExecutionMetadata(properties);
        };

        /**
         * Encodes the specified ExecutionMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.ExecutionMetadata.BigqueryMetadata.encode(message.bigquery, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionMetadata message.
         * @function verify
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.ExecutionMetadata.BigqueryMetadata.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         */
        ExecutionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionMetadata)
                return object;
            let message = new $root.dataform.ExecutionMetadata();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.ExecutionMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.ExecutionMetadata} message ExecutionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bigquery = null;
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this ExecutionMetadata to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionMetadata
         * @function getTypeUrl
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionMetadata";
        };

        ExecutionMetadata.BigqueryMetadata = (function() {

            /**
             * Properties of a BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @interface IBigqueryMetadata
             * @property {string|null} [jobId] BigqueryMetadata jobId
             * @property {Long|null} [totalBytesProcessed] BigqueryMetadata totalBytesProcessed
             * @property {Long|null} [totalBytesBilled] BigqueryMetadata totalBytesBilled
             */

            /**
             * Constructs a new BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @classdesc Represents a BigqueryMetadata.
             * @implements IBigqueryMetadata
             * @constructor
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             */
            function BigqueryMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigqueryMetadata jobId.
             * @member {string} jobId
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.jobId = "";

            /**
             * BigqueryMetadata totalBytesProcessed.
             * @member {Long} totalBytesProcessed
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesProcessed = 0;

            /**
             * BigqueryMetadata totalBytesBilled.
             * @member {Long} totalBytesBilled
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesBilled = 0;

            /**
             * Creates a new BigqueryMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata instance
             */
            BigqueryMetadata.create = function create(properties) {
                return new BigqueryMetadata(properties);
            };

            /**
             * Encodes the specified BigqueryMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jobId != null && Object.hasOwnProperty.call(message, "jobId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                if (message.totalBytesProcessed != null && Object.hasOwnProperty.call(message, "totalBytesProcessed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalBytesProcessed);
                if (message.totalBytesBilled != null && Object.hasOwnProperty.call(message, "totalBytesBilled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalBytesBilled);
                return writer;
            };

            /**
             * Encodes the specified BigqueryMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.jobId = reader.string();
                            break;
                        }
                    case 2: {
                            message.totalBytesProcessed = reader.int64();
                            break;
                        }
                    case 3: {
                            message.totalBytesBilled = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigqueryMetadata message.
             * @function verify
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigqueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    if (!$util.isString(message.jobId))
                        return "jobId: string expected";
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (!$util.isInteger(message.totalBytesProcessed) && !(message.totalBytesProcessed && $util.isInteger(message.totalBytesProcessed.low) && $util.isInteger(message.totalBytesProcessed.high)))
                        return "totalBytesProcessed: integer|Long expected";
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (!$util.isInteger(message.totalBytesBilled) && !(message.totalBytesBilled && $util.isInteger(message.totalBytesBilled.low) && $util.isInteger(message.totalBytesBilled.high)))
                        return "totalBytesBilled: integer|Long expected";
                return null;
            };

            /**
             * Creates a BigqueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             */
            BigqueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ExecutionMetadata.BigqueryMetadata)
                    return object;
                let message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                if (object.jobId != null)
                    message.jobId = String(object.jobId);
                if (object.totalBytesProcessed != null)
                    if ($util.Long)
                        (message.totalBytesProcessed = $util.Long.fromValue(object.totalBytesProcessed)).unsigned = false;
                    else if (typeof object.totalBytesProcessed === "string")
                        message.totalBytesProcessed = parseInt(object.totalBytesProcessed, 10);
                    else if (typeof object.totalBytesProcessed === "number")
                        message.totalBytesProcessed = object.totalBytesProcessed;
                    else if (typeof object.totalBytesProcessed === "object")
                        message.totalBytesProcessed = new $util.LongBits(object.totalBytesProcessed.low >>> 0, object.totalBytesProcessed.high >>> 0).toNumber();
                if (object.totalBytesBilled != null)
                    if ($util.Long)
                        (message.totalBytesBilled = $util.Long.fromValue(object.totalBytesBilled)).unsigned = false;
                    else if (typeof object.totalBytesBilled === "string")
                        message.totalBytesBilled = parseInt(object.totalBytesBilled, 10);
                    else if (typeof object.totalBytesBilled === "number")
                        message.totalBytesBilled = object.totalBytesBilled;
                    else if (typeof object.totalBytesBilled === "object")
                        message.totalBytesBilled = new $util.LongBits(object.totalBytesBilled.low >>> 0, object.totalBytesBilled.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BigqueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.BigqueryMetadata} message BigqueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigqueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.jobId = "";
                    object.totalBytesProcessed = 0;
                    object.totalBytesBilled = 0;
                }
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    object.jobId = message.jobId;
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (typeof message.totalBytesProcessed === "number")
                        object.totalBytesProcessed = options.longs === String ? String(message.totalBytesProcessed) : message.totalBytesProcessed;
                    else
                        object.totalBytesProcessed = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesProcessed) : options.longs === Number ? new $util.LongBits(message.totalBytesProcessed.low >>> 0, message.totalBytesProcessed.high >>> 0).toNumber() : message.totalBytesProcessed;
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (typeof message.totalBytesBilled === "number")
                        object.totalBytesBilled = options.longs === String ? String(message.totalBytesBilled) : message.totalBytesBilled;
                    else
                        object.totalBytesBilled = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesBilled) : options.longs === Number ? new $util.LongBits(message.totalBytesBilled.low >>> 0, message.totalBytesBilled.high >>> 0).toNumber() : message.totalBytesBilled;
                return object;
            };

            /**
             * Converts this BigqueryMetadata to JSON.
             * @function toJSON
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigqueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BigqueryMetadata
             * @function getTypeUrl
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BigqueryMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ExecutionMetadata.BigqueryMetadata";
            };

            return BigqueryMetadata;
        })();

        return ExecutionMetadata;
    })();

    dataform.TaskResult = (function() {

        /**
         * Properties of a TaskResult.
         * @memberof dataform
         * @interface ITaskResult
         * @property {dataform.TaskResult.ExecutionStatus|null} [status] TaskResult status
         * @property {string|null} [errorMessage] TaskResult errorMessage
         * @property {dataform.ITiming|null} [timing] TaskResult timing
         * @property {dataform.IExecutionMetadata|null} [metadata] TaskResult metadata
         */

        /**
         * Constructs a new TaskResult.
         * @memberof dataform
         * @classdesc Represents a TaskResult.
         * @implements ITaskResult
         * @constructor
         * @param {dataform.ITaskResult=} [properties] Properties to set
         */
        function TaskResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskResult status.
         * @member {dataform.TaskResult.ExecutionStatus} status
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.status = 0;

        /**
         * TaskResult errorMessage.
         * @member {string} errorMessage
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.errorMessage = "";

        /**
         * TaskResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.timing = null;

        /**
         * TaskResult metadata.
         * @member {dataform.IExecutionMetadata|null|undefined} metadata
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.metadata = null;

        /**
         * Creates a new TaskResult instance using the specified properties.
         * @function create
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult=} [properties] Properties to set
         * @returns {dataform.TaskResult} TaskResult instance
         */
        TaskResult.create = function create(properties) {
            return new TaskResult(properties);
        };

        /**
         * Encodes the specified TaskResult message. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                $root.dataform.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskResult message, length delimited. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TaskResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.errorMessage = reader.string();
                        break;
                    }
                case 3: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.metadata = $root.dataform.ExecutionMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskResult message.
         * @function verify
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                let error = $root.dataform.ExecutionMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a TaskResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TaskResult} TaskResult
         */
        TaskResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TaskResult)
                return object;
            let message = new $root.dataform.TaskResult();
            switch (object.status) {
            default:
                if (typeof object.status === "number") {
                    message.status = object.status;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "CANCELLED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.TaskResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".dataform.TaskResult.metadata: object expected");
                message.metadata = $root.dataform.ExecutionMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.TaskResult} message TaskResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.errorMessage = "";
                object.timing = null;
                object.metadata = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.TaskResult.ExecutionStatus[message.status] === undefined ? message.status : $root.dataform.TaskResult.ExecutionStatus[message.status] : message.status;
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.dataform.ExecutionMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this TaskResult to JSON.
         * @function toJSON
         * @memberof dataform.TaskResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TaskResult
         * @function getTypeUrl
         * @memberof dataform.TaskResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TaskResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TaskResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.TaskResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} CANCELLED=5 CANCELLED value
         */
        TaskResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "CANCELLED"] = 5;
            return values;
        })();

        return TaskResult;
    })();

    dataform.TestResult = (function() {

        /**
         * Properties of a TestResult.
         * @memberof dataform
         * @interface ITestResult
         * @property {string|null} [name] TestResult name
         * @property {boolean|null} [successful] TestResult successful
         * @property {Array.<string>|null} [messages] TestResult messages
         */

        /**
         * Constructs a new TestResult.
         * @memberof dataform
         * @classdesc Represents a TestResult.
         * @implements ITestResult
         * @constructor
         * @param {dataform.ITestResult=} [properties] Properties to set
         */
        function TestResult(properties) {
            this.messages = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestResult name.
         * @member {string} name
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.name = "";

        /**
         * TestResult successful.
         * @member {boolean} successful
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.successful = false;

        /**
         * TestResult messages.
         * @member {Array.<string>} messages
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.messages = $util.emptyArray;

        /**
         * Creates a new TestResult instance using the specified properties.
         * @function create
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult=} [properties] Properties to set
         * @returns {dataform.TestResult} TestResult instance
         */
        TestResult.create = function create(properties) {
            return new TestResult(properties);
        };

        /**
         * Encodes the specified TestResult message. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.successful != null && Object.hasOwnProperty.call(message, "successful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.successful);
            if (message.messages != null && message.messages.length)
                for (let i = 0; i < message.messages.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.messages[i]);
            return writer;
        };

        /**
         * Encodes the specified TestResult message, length delimited. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TestResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.successful = reader.bool();
                        break;
                    }
                case 3: {
                        if (!(message.messages && message.messages.length))
                            message.messages = [];
                        message.messages.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestResult message.
         * @function verify
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.successful != null && message.hasOwnProperty("successful"))
                if (typeof message.successful !== "boolean")
                    return "successful: boolean expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (let i = 0; i < message.messages.length; ++i)
                    if (!$util.isString(message.messages[i]))
                        return "messages: string[] expected";
            }
            return null;
        };

        /**
         * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TestResult} TestResult
         */
        TestResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TestResult)
                return object;
            let message = new $root.dataform.TestResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.successful != null)
                message.successful = Boolean(object.successful);
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".dataform.TestResult.messages: array expected");
                message.messages = [];
                for (let i = 0; i < object.messages.length; ++i)
                    message.messages[i] = String(object.messages[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.TestResult} message TestResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.name = "";
                object.successful = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.successful != null && message.hasOwnProperty("successful"))
                object.successful = message.successful;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (let j = 0; j < message.messages.length; ++j)
                    object.messages[j] = message.messages[j];
            }
            return object;
        };

        /**
         * Converts this TestResult to JSON.
         * @function toJSON
         * @memberof dataform.TestResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TestResult
         * @function getTypeUrl
         * @memberof dataform.TestResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TestResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TestResult";
        };

        return TestResult;
    })();

    dataform.Field = (function() {

        /**
         * Properties of a Field.
         * @memberof dataform
         * @interface IField
         * @property {string|null} [name] Field name
         * @property {Array.<dataform.Field.Flag>|null} [flags] Field flags
         * @property {dataform.Field.Primitive|null} [primitive] Field primitive
         * @property {dataform.IFields|null} [struct] Field struct
         * @property {string|null} [description] Field description
         */

        /**
         * Constructs a new Field.
         * @memberof dataform
         * @classdesc Represents a Field.
         * @implements IField
         * @constructor
         * @param {dataform.IField=} [properties] Properties to set
         */
        function Field(properties) {
            this.flags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Field name.
         * @member {string} name
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.name = "";

        /**
         * Field flags.
         * @member {Array.<dataform.Field.Flag>} flags
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flags = $util.emptyArray;

        /**
         * Field primitive.
         * @member {dataform.Field.Primitive|null|undefined} primitive
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.primitive = null;

        /**
         * Field struct.
         * @member {dataform.IFields|null|undefined} struct
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.struct = null;

        /**
         * Field description.
         * @member {string} description
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.description = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Field type.
         * @member {"primitive"|"struct"|undefined} type
         * @memberof dataform.Field
         * @instance
         */
        Object.defineProperty(Field.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["primitive", "struct"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Field instance using the specified properties.
         * @function create
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField=} [properties] Properties to set
         * @returns {dataform.Field} Field instance
         */
        Field.create = function create(properties) {
            return new Field(properties);
        };

        /**
         * Encodes the specified Field message. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encode
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.struct != null && Object.hasOwnProperty.call(message, "struct"))
                $root.dataform.Fields.encode(message.struct, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.flags != null && message.flags.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.flags.length; ++i)
                    writer.int32(message.flags[i]);
                writer.ldelim();
            }
            if (message.primitive != null && Object.hasOwnProperty.call(message, "primitive"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.primitive);
            return writer;
        };

        /**
         * Encodes the specified Field message, length delimited. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Field message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Field();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 6: {
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.flags.push(reader.int32());
                        } else
                            message.flags.push(reader.int32());
                        break;
                    }
                case 7: {
                        message.primitive = reader.int32();
                        break;
                    }
                case 3: {
                        message.struct = $root.dataform.Fields.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.description = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Field message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Field message.
         * @function verify
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Field.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i)
                    switch (message.flags[i]) {
                    default:
                        return "flags: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                properties.type = 1;
                switch (message.primitive) {
                default:
                    return "primitive: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            }
            if (message.struct != null && message.hasOwnProperty("struct")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.dataform.Fields.verify(message.struct);
                    if (error)
                        return "struct." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a Field message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Field} Field
         */
        Field.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Field)
                return object;
            let message = new $root.dataform.Field();
            if (object.name != null)
                message.name = String(object.name);
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".dataform.Field.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i)
                    switch (object.flags[i]) {
                    default:
                        if (typeof object.flags[i] === "number") {
                            message.flags[i] = object.flags[i];
                            break;
                        }
                    case "UNKNOWN_FLAG":
                    case 0:
                        message.flags[i] = 0;
                        break;
                    case "REPEATED":
                    case 1:
                        message.flags[i] = 1;
                        break;
                    }
            }
            switch (object.primitive) {
            default:
                if (typeof object.primitive === "number") {
                    message.primitive = object.primitive;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.primitive = 0;
                break;
            case "INTEGER":
            case 1:
                message.primitive = 1;
                break;
            case "FLOAT":
            case 2:
                message.primitive = 2;
                break;
            case "NUMERIC":
            case 5:
                message.primitive = 5;
                break;
            case "BOOLEAN":
            case 3:
                message.primitive = 3;
                break;
            case "STRING":
            case 4:
                message.primitive = 4;
                break;
            case "DATE":
            case 6:
                message.primitive = 6;
                break;
            case "DATETIME":
            case 7:
                message.primitive = 7;
                break;
            case "TIMESTAMP":
            case 8:
                message.primitive = 8;
                break;
            case "TIME":
            case 9:
                message.primitive = 9;
                break;
            case "BYTES":
            case 10:
                message.primitive = 10;
                break;
            case "ANY":
            case 11:
                message.primitive = 11;
                break;
            case "GEOGRAPHY":
            case 12:
                message.primitive = 12;
                break;
            }
            if (object.struct != null) {
                if (typeof object.struct !== "object")
                    throw TypeError(".dataform.Field.struct: object expected");
                message.struct = $root.dataform.Fields.fromObject(object.struct);
            }
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a Field message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Field
         * @static
         * @param {dataform.Field} message Field
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Field.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.flags = [];
            if (options.defaults) {
                object.name = "";
                object.description = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.struct != null && message.hasOwnProperty("struct")) {
                object.struct = $root.dataform.Fields.toObject(message.struct, options);
                if (options.oneofs)
                    object.type = "struct";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = options.enums === String ? $root.dataform.Field.Flag[message.flags[j]] === undefined ? message.flags[j] : $root.dataform.Field.Flag[message.flags[j]] : message.flags[j];
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                object.primitive = options.enums === String ? $root.dataform.Field.Primitive[message.primitive] === undefined ? message.primitive : $root.dataform.Field.Primitive[message.primitive] : message.primitive;
                if (options.oneofs)
                    object.type = "primitive";
            }
            return object;
        };

        /**
         * Converts this Field to JSON.
         * @function toJSON
         * @memberof dataform.Field
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Field.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Field
         * @function getTypeUrl
         * @memberof dataform.Field
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Field.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Field";
        };

        /**
         * Primitive enum.
         * @name dataform.Field.Primitive
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} NUMERIC=5 NUMERIC value
         * @property {number} BOOLEAN=3 BOOLEAN value
         * @property {number} STRING=4 STRING value
         * @property {number} DATE=6 DATE value
         * @property {number} DATETIME=7 DATETIME value
         * @property {number} TIMESTAMP=8 TIMESTAMP value
         * @property {number} TIME=9 TIME value
         * @property {number} BYTES=10 BYTES value
         * @property {number} ANY=11 ANY value
         * @property {number} GEOGRAPHY=12 GEOGRAPHY value
         */
        Field.Primitive = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[5] = "NUMERIC"] = 5;
            values[valuesById[3] = "BOOLEAN"] = 3;
            values[valuesById[4] = "STRING"] = 4;
            values[valuesById[6] = "DATE"] = 6;
            values[valuesById[7] = "DATETIME"] = 7;
            values[valuesById[8] = "TIMESTAMP"] = 8;
            values[valuesById[9] = "TIME"] = 9;
            values[valuesById[10] = "BYTES"] = 10;
            values[valuesById[11] = "ANY"] = 11;
            values[valuesById[12] = "GEOGRAPHY"] = 12;
            return values;
        })();

        /**
         * Flag enum.
         * @name dataform.Field.Flag
         * @enum {number}
         * @property {number} UNKNOWN_FLAG=0 UNKNOWN_FLAG value
         * @property {number} REPEATED=1 REPEATED value
         */
        Field.Flag = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_FLAG"] = 0;
            values[valuesById[1] = "REPEATED"] = 1;
            return values;
        })();

        return Field;
    })();

    dataform.Fields = (function() {

        /**
         * Properties of a Fields.
         * @memberof dataform
         * @interface IFields
         * @property {Array.<dataform.IField>|null} [fields] Fields fields
         */

        /**
         * Constructs a new Fields.
         * @memberof dataform
         * @classdesc Represents a Fields.
         * @implements IFields
         * @constructor
         * @param {dataform.IFields=} [properties] Properties to set
         */
        function Fields(properties) {
            this.fields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fields fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.Fields
         * @instance
         */
        Fields.prototype.fields = $util.emptyArray;

        /**
         * Creates a new Fields instance using the specified properties.
         * @function create
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields=} [properties] Properties to set
         * @returns {dataform.Fields} Fields instance
         */
        Fields.create = function create(properties) {
            return new Fields(properties);
        };

        /**
         * Encodes the specified Fields message. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encode
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Fields message, length delimited. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fields message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Fields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fields message.
         * @function verify
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Fields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Fields} Fields
         */
        Fields.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Fields)
                return object;
            let message = new $root.dataform.Fields();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.Fields.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.Fields.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Fields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Fields
         * @static
         * @param {dataform.Fields} message Fields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this Fields to JSON.
         * @function toJSON
         * @memberof dataform.Fields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Fields
         * @function getTypeUrl
         * @memberof dataform.Fields
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Fields.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Fields";
        };

        return Fields;
    })();

    dataform.TableMetadata = (function() {

        /**
         * Properties of a TableMetadata.
         * @memberof dataform
         * @interface ITableMetadata
         * @property {dataform.ITarget|null} [target] TableMetadata target
         * @property {dataform.TableMetadata.Type|null} [type] TableMetadata type
         * @property {Array.<dataform.IField>|null} [fields] TableMetadata fields
         * @property {string|null} [description] TableMetadata description
         * @property {Object.<string,string>|null} [labels] TableMetadata labels
         * @property {Long|null} [lastUpdatedMillis] TableMetadata lastUpdatedMillis
         * @property {dataform.TableMetadata.IBigQuery|null} [bigquery] TableMetadata bigquery
         */

        /**
         * Constructs a new TableMetadata.
         * @memberof dataform
         * @classdesc Represents a TableMetadata.
         * @implements ITableMetadata
         * @constructor
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         */
        function TableMetadata(properties) {
            this.fields = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.target = null;

        /**
         * TableMetadata type.
         * @member {dataform.TableMetadata.Type} type
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.type = 0;

        /**
         * TableMetadata fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.fields = $util.emptyArray;

        /**
         * TableMetadata description.
         * @member {string} description
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.description = "";

        /**
         * TableMetadata labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.labels = $util.emptyObject;

        /**
         * TableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.lastUpdatedMillis = 0;

        /**
         * TableMetadata bigquery.
         * @member {dataform.TableMetadata.IBigQuery|null|undefined} bigquery
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.bigquery = null;

        /**
         * Creates a new TableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         * @returns {dataform.TableMetadata} TableMetadata instance
         */
        TableMetadata.create = function create(properties) {
            return new TableMetadata(properties);
        };

        /**
         * Encodes the specified TableMetadata message. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.lastUpdatedMillis != null && Object.hasOwnProperty.call(message, "lastUpdatedMillis"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastUpdatedMillis);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.TableMetadata.BigQuery.encode(message.bigquery, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableMetadata message, length delimited. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.description = reader.string();
                        break;
                    }
                case 7: {
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    }
                case 4: {
                        message.lastUpdatedMillis = reader.int64();
                        break;
                    }
                case 8: {
                        message.bigquery = $root.dataform.TableMetadata.BigQuery.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableMetadata message.
         * @function verify
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.TableMetadata.BigQuery.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates a TableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TableMetadata} TableMetadata
         */
        TableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TableMetadata)
                return object;
            let message = new $root.dataform.TableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.TableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TABLE":
            case 1:
                message.type = 1;
                break;
            case "VIEW":
            case 2:
                message.type = 2;
                break;
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.TableMetadata.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.TableMetadata.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.TableMetadata.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.TableMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.TableMetadata.BigQuery.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from a TableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.TableMetadata} message TableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.target = null;
                object.lastUpdatedMillis = 0;
                object.description = "";
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.bigquery = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.dataform.TableMetadata.Type[message.type] === undefined ? message.type : $root.dataform.TableMetadata.Type[message.type] : message.type;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.TableMetadata.BigQuery.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this TableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.TableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TableMetadata
         * @function getTypeUrl
         * @memberof dataform.TableMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TableMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TableMetadata";
        };

        /**
         * Type enum.
         * @name dataform.TableMetadata.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TABLE=1 TABLE value
         * @property {number} VIEW=2 VIEW value
         */
        TableMetadata.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TABLE"] = 1;
            values[valuesById[2] = "VIEW"] = 2;
            return values;
        })();

        TableMetadata.BigQuery = (function() {

            /**
             * Properties of a BigQuery.
             * @memberof dataform.TableMetadata
             * @interface IBigQuery
             * @property {boolean|null} [hasStreamingBuffer] BigQuery hasStreamingBuffer
             */

            /**
             * Constructs a new BigQuery.
             * @memberof dataform.TableMetadata
             * @classdesc Represents a BigQuery.
             * @implements IBigQuery
             * @constructor
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             */
            function BigQuery(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigQuery hasStreamingBuffer.
             * @member {boolean} hasStreamingBuffer
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             */
            BigQuery.prototype.hasStreamingBuffer = false;

            /**
             * Creates a new BigQuery instance using the specified properties.
             * @function create
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             * @returns {dataform.TableMetadata.BigQuery} BigQuery instance
             */
            BigQuery.create = function create(properties) {
                return new BigQuery(properties);
            };

            /**
             * Encodes the specified BigQuery message. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hasStreamingBuffer != null && Object.hasOwnProperty.call(message, "hasStreamingBuffer"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasStreamingBuffer);
                return writer;
            };

            /**
             * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata.BigQuery();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.hasStreamingBuffer = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigQuery message.
             * @function verify
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    if (typeof message.hasStreamingBuffer !== "boolean")
                        return "hasStreamingBuffer: boolean expected";
                return null;
            };

            /**
             * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             */
            BigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.TableMetadata.BigQuery)
                    return object;
                let message = new $root.dataform.TableMetadata.BigQuery();
                if (object.hasStreamingBuffer != null)
                    message.hasStreamingBuffer = Boolean(object.hasStreamingBuffer);
                return message;
            };

            /**
             * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.BigQuery} message BigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hasStreamingBuffer = false;
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    object.hasStreamingBuffer = message.hasStreamingBuffer;
                return object;
            };

            /**
             * Converts this BigQuery to JSON.
             * @function toJSON
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BigQuery
             * @function getTypeUrl
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BigQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.TableMetadata.BigQuery";
            };

            return BigQuery;
        })();

        return TableMetadata;
    })();

    dataform.BigQuery = (function() {

        /**
         * Properties of a BigQuery.
         * @memberof dataform
         * @interface IBigQuery
         * @property {string|null} [projectId] BigQuery projectId
         * @property {string|null} [credentials] BigQuery credentials
         * @property {string|null} [location] BigQuery location
         */

        /**
         * Constructs a new BigQuery.
         * @memberof dataform
         * @classdesc Represents a BigQuery.
         * @implements IBigQuery
         * @constructor
         * @param {dataform.IBigQuery=} [properties] Properties to set
         */
        function BigQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQuery projectId.
         * @member {string} projectId
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.projectId = "";

        /**
         * BigQuery credentials.
         * @member {string} credentials
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.credentials = "";

        /**
         * BigQuery location.
         * @member {string} location
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.location = "";

        /**
         * Creates a new BigQuery instance using the specified properties.
         * @function create
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery=} [properties] Properties to set
         * @returns {dataform.BigQuery} BigQuery instance
         */
        BigQuery.create = function create(properties) {
            return new BigQuery(properties);
        };

        /**
         * Encodes the specified BigQuery message. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
            if (message.credentials != null && Object.hasOwnProperty.call(message, "credentials"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentials);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            return writer;
        };

        /**
         * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectId = reader.string();
                        break;
                    }
                case 3: {
                        message.credentials = reader.string();
                        break;
                    }
                case 4: {
                        message.location = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQuery message.
         * @function verify
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                if (!$util.isString(message.projectId))
                    return "projectId: string expected";
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                if (!$util.isString(message.credentials))
                    return "credentials: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            return null;
        };

        /**
         * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQuery} BigQuery
         */
        BigQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQuery)
                return object;
            let message = new $root.dataform.BigQuery();
            if (object.projectId != null)
                message.projectId = String(object.projectId);
            if (object.credentials != null)
                message.credentials = String(object.credentials);
            if (object.location != null)
                message.location = String(object.location);
            return message;
        };

        /**
         * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.BigQuery} message BigQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectId = "";
                object.credentials = "";
                object.location = "";
            }
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                object.projectId = message.projectId;
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                object.credentials = message.credentials;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            return object;
        };

        /**
         * Converts this BigQuery to JSON.
         * @function toJSON
         * @memberof dataform.BigQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf__namespace.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BigQuery
         * @function getTypeUrl
         * @memberof dataform.BigQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BigQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.BigQuery";
        };

        return BigQuery;
    })();

    return dataform;
})();

function compile(compileConfig) {
    if (!fs__namespace.existsSync(path__namespace.join(compileConfig.projectDir, "node_modules", "@dataform", "core", "bundle.js"))) {
        throw new Error("Could not find a recent installed version of @dataform/core in the project. Check that " +
            "either `dataformCoreVersion` is specified in `workflow_settings.yaml`, or " +
            "`@dataform/core` is specified in `package.json`. If using `package.json`, then run " +
            "`dataform install`.");
    }
    const vmIndexFileName = path__namespace.resolve(path__namespace.join(compileConfig.projectDir, "index.js"));
    const indexGeneratorVm = new vm2.NodeVM({
        wrapper: "none",
        require: {
            context: "sandbox",
            root: compileConfig.projectDir,
            external: true,
            builtin: ["path"]
        }
    });
    const compiler = indexGeneratorVm.run('return require("@dataform/core").compiler', vmIndexFileName);
    const userCodeVm = new vm2.NodeVM({
        wrapper: "none",
        require: {
            builtin: ["path"],
            context: "sandbox",
            external: true,
            root: compileConfig.projectDir,
            resolve: (moduleName, parentDirName) => path__namespace.join(parentDirName, path__namespace.relative(parentDirName, compileConfig.projectDir), moduleName)
        },
        sourceExtensions: ["js", "sql", "sqlx", "yaml"],
        compiler
    });
    const dataformCoreVersion = userCodeVm.run('return require("@dataform/core").version || "0.0.0"', vmIndexFileName);
    if (semver__namespace.lt(dataformCoreVersion, "3.0.0-alpha.0")) {
        throw new Error("@dataform/core ^3.0.0 required.");
    }
    return userCodeVm.run(`return require("@dataform/core").main("${createCoreExecutionRequest(compileConfig)}")`, vmIndexFileName);
}
function listenForCompileRequest() {
    process.on("message", (compileConfig) => {
        try {
            const compiledResult = compile(compileConfig);
            process.send(compiledResult);
        }
        catch (e) {
            const serializableError = {};
            for (const prop of Object.getOwnPropertyNames(e)) {
                serializableError[prop] = e[prop];
            }
            process.send(serializableError);
        }
    });
}
if (require.main === module) {
    listenForCompileRequest();
}
function createCoreExecutionRequest(compileConfig) {
    const filePaths = Array.from(new Set(glob__namespace.sync("!(node_modules)/**/*.*", { cwd: compileConfig.projectDir })));
    return encode64(dataform.CoreExecutionRequest, {
        compile: { compileConfig: Object.assign({ filePaths }, compileConfig) }
    });
}

listenForCompileRequest();
